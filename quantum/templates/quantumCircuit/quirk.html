<!DOCTYPE html>
<html>
    <head lang="en">
        <meta charset="UTF-8">
        <meta name="keywords" content="quantum,circuit,simulator,quirk">
        <meta name="description" content="Quirk is an open-source drag-and-drop quantum circuit simulator for exploring and understanding small quantum circuits.">
        <title>Quirk: Quantum Circuit Simulator</title>

        <!-- Whatever is between these start/end analytic tags is stripped by the 'downloading offline copy' code. -->
        <!-- Start Analytics -->
        <!-- End Analytics -->
    </head>
    <body style="margin: 0">
        <ul>
    {% if g.user %}
      <li><span>{{ g.user['username'] }}</span>
      <li><a href="{{ url_for('auth.logout') }}">退出</a>
    {% else %}
      <li><a href="{{ url_for('auth.register') }}">注册</a>
      <li><a href="{{ url_for('auth.login') }}">登陆</a>
    {% endif %}
        </ul>
        <!-- Primary content -->
        <div id="inspectorDiv" style="display: none">
            <!-- Buttons -->
            <div style="margin: 5px;">
                &nbsp;
                &nbsp;
                &nbsp;
                &nbsp;
                <button id="clear-circuit-button" style="min-width: 50px; min-height: 30px;">清除线路</button>
                <button id="clear-all-button" style="min-width: 50px; min-height: 30px;">清除所有</button>
                &nbsp;
                &nbsp;
                <button id="undo-button" style="min-width: 50px; min-height: 30px;">撤销</button>
                <button id="redo-button" style="min-width: 50px; min-height: 30px;">恢复</button>
                <button id="run-button" style="min-width: 50px; min-height: 30px;" >运行</button>
                &nbsp;
                &nbsp;

                &nbsp;

            </div>

            <!-- Circuit drawing area -->
            <div id="canvasDiv" style="width: 100%; touch-action: manipulation; tab-index: 0; position: relative;">
                <canvas id="drawCanvas"></canvas>
            </div>

            
<style>
  .axis path,
  .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
  }

  path.line {
    fill: none;
    stroke-width: 1px;
    pointer-events: none;
  }

  .zoomOut {
    fill: #66a;
    cursor: pointer;
  }

  .zoomOutText {
    pointer-events: none;
    fill: #ccc;
  }

  .zoomOverlay {
    pointer-events: all;
    fill: none;
  }

  .band {
    fill: none;
    stroke-width: 2px;
    stroke: black;
  }

</style>
<script type=text/javascript src="{{url_for('static', filename='d3.js') }}"></script>
<div id="run-div" style="display:none;">
    <div id="run-overlay" style="position:fixed; left: 0; top: 0; height: 1000vh; width: 1000vw; background: rgba(0, 0, 0,0.7);">
    </div>
    <div style="position: absolute; top: 20px; left: 50px; padding: 20px; background-color: white; border: 1px solid black;overflow:auto; max-width:6000px; max-height:10000px;">
        <div style="margin: 10px 0 0 20px;">
            <pre tabindex="104" id="run-circuit-json-pre" style="display:none;overflow:auto; max-width:600px; max-height:600px; border: 1px solid black; padding:5px; margin:2px;"></pre>
            <pre tabindex="104" id="run-circuit-json-show" style="overflow:auto; max-width:600px; max-height:10000px; border: 1px solid black; padding:5px; margin:2px;"></pre>
            <button onClick="zoomOut()"> Zoom Out </button>
            <div id="graph"></div>
        </div>
    </div>
</div>
<script>
var bandPos = [-1, -1];
var pos;
var colors = d3.scaleOrdinal(d3.schemeCategory10);

//initialized when data is pulled
var x, y, xDomain, yDomain, xDomainMin, yDomainMin, xAxis, yAxis, zoomArea, line;
xDomain = 0;
yDomain = 0;
xDomainMin = 0;
yDomainMin = 0;

var margin = {
    top: 40,
    right: 40,
    bottom: 50,
    left: 60
}
var width = 900 - margin.left - margin.right;
var height = 450 - margin.top - margin.bottom;
var drag = d3.drag();

var svg = d3.select("#graph").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


svg.append("clipPath")
    .attr("id", "clip")
    .append("rect")
    .attr("width", width)
    .attr("height", height);

var zoomOverlay = svg.append("rect")
    .attr("width", width - 10)
    .attr("height", height)
    .attr("class", "zoomOverlay")
    .call(drag);


var band = svg.append("rect")
    .attr("width", 0)
    .attr("height", 0)
    .attr("x", 0)
    .attr("y", 0)
    .attr("class", "band");

var zoomout = svg.append("g");

drag.on("end", function () {
    var pos = d3.mouse(this);
    var x1 = x.invert(bandPos[0]);
    var x2 = x.invert(pos[0]);

    if (x1 < x2) {
        zoomArea.x1 = x1;
        zoomArea.x2 = x2;
    } else {
        zoomArea.x1 = x2;
        zoomArea.x2 = x1;
    }

    var y1 = y.invert(pos[1]);
    var y2 = y.invert(bandPos[1]);

    if (x1 < x2) {
        zoomArea.y1 = y1;
        zoomArea.y2 = y2;
    } else {
        zoomArea.y1 = y2;
        zoomArea.y2 = y1;
    }

    bandPos = [-1, -1];

    d3.select(".band").transition()
        .attr("width", 0)
        .attr("height", 0)
        .attr("x", bandPos[0])
        .attr("y", bandPos[1]);

    zoom();

});

drag.on("drag", function () {

    var pos = d3.mouse(this);

    if (pos[0] < bandPos[0]) {
        d3.select(".band").attr("transform", "translate(" + (pos[0]) + "," + bandPos[1] + ")");
    }
    if (pos[1] < bandPos[1]) {
        d3.select(".band").attr("transform", "translate(" + (pos[0]) + "," + pos[1] + ")");
    }
    if (pos[1] < bandPos[1] && pos[0] > bandPos[0]) {
        d3.select(".band").attr("transform", "translate(" + (bandPos[0]) + "," + pos[1] + ")");
    }

    //set new position of band when user initializes drag
    if (bandPos[0] == -1) {
        bandPos = pos;
        d3.select(".band").attr("transform", "translate(" + bandPos[0] + "," + bandPos[1] + ")");
    }

    d3.select(".band").transition().duration(1)
        .attr("width", Math.abs(bandPos[0] - pos[0]))
        .attr("height", Math.abs(bandPos[1] - pos[1]));
});

function zoom() {
    //recalculate domains
    if (zoomArea.x1 > zoomArea.x2) {
        x.domain([zoomArea.x2, zoomArea.x1]);
    } else {
        x.domain([zoomArea.x1, zoomArea.x2]);
    }

    if (zoomArea.y1 > zoomArea.y2) {
        y.domain([zoomArea.y2, zoomArea.y1]);
    } else {
        y.domain([zoomArea.y1, zoomArea.y2]);
    }

    //update axis and redraw lines
    var t = svg.transition().duration(750);
    t.select(".x.axis").call(xAxis);
    t.select(".y.axis").call(yAxis);
    t.selectAll(".line").attr("d", line);

}

function updateChart(data) {
    var xmax, ymax, xmin, ymin;
    d3.selectAll('.line').remove();
    d3.selectAll(".axis").remove();

    data.forEach((da, idx) => {
        xmax = da.map(d => d.x).reduce((a, c) => Math.max(a, c))
        ymax = da.map(d => d.y).reduce((a, c) => Math.max(a, c))

        xmin = da.map(d => d.x).reduce((a, c) => Math.min(a, c))
        ymin = da.map(d => d.y).reduce((a, c) => Math.min(a, c))

        xDomain = Math.max(xDomain, xmax);
        yDomain = Math.max(yDomain, ymax);
        xDomainMin = Math.min(xDomainMin, xmin);
        yDomainMin = Math.min(yDomainMin, ymin);
    })
    xDomain += xDomain * .10;
    yDomain += yDomain * .10;
    xDomainMin += xDomainMin * .10;
    yDomainMin += yDomainMin * .10;


    line = d3.line()
        .x(function (d) {
            return x(d.x);
        })
        .y(function (d) {
            return y(d.y);
        });

    zoomArea = {
        x1: xDomainMin,
        y1: yDomainMin,
        x2: xDomain,
        y2: yDomain
    };

    x = d3.scaleLinear().range([0, width]).domain([xDomainMin, xDomain]);
    y = d3.scaleLinear().range([height, 0]).domain([yDomainMin, yDomain]);

    xAxis = d3.axisBottom(x)
    yAxis = d3.axisLeft(y)

    //UPDATE AXES
    svg.append("g")
        .attr("class", "x axis")
        .call(xAxis)
        .attr("transform", "translate(0," + height + ")");

    svg.append("g")
        .attr("class", "y axis")
        .call(yAxis)

    data.forEach((da, idx) => {
        svg.append("path")
            .datum(da)
            .attr("class", "line line" + idx)
            .attr("clip-path", "url(#clip)")
            .style("stroke", colors(idx))
            .attr("d", line);
    })

    d3.select(".band").raise();

    zoom();
}

var zoomOut = function () {
    x.domain([xDomainMin, xDomain]);
    y.domain([yDomainMin, yDomain]);

    var t = svg.transition().duration(750);
    t.select(".x.axis").call(xAxis);
    t.select(".y.axis").call(yAxis);

    t.selectAll(".line").attr("d", line);
}
</script>

            <div id="gate-forge-div" style="display:none">
    <div id="gate-forge-overlay" style="position:fixed; left: 0; top: 0; height: 100vh; width: 100vw; background: rgba(0, 0, 0, 0.7);">
    </div>
    <div style="position: absolute; top: 20px; left: 50px; padding: 20px; background-color: white; border: 1px solid black;">
        <style scoped>
            th {
                font-size: 20px;
            }
        </style>
        <table cellspacing="0">
            <colgroup>
                <col style="background-color:#EEE;"/>
                <col/>
                <col style="background-color:#EEE;"/>
                <col/>
                <col style="background-color:#EEE;"/>
            </colgroup>
            <tr>
                <th>From Rotation</th>
                <th></th>
                <th>From Matrix</th>
                <th></th>
                <th>From Circuit</th>
            </tr>
            <tr>
                <td>
                    <input tabindex="100" id='gate-forge-rotation-axis' type="text" size="8" placeholder="X+Z"> axis<br/>
                    <input tabindex="101" id='gate-forge-rotation-angle' type="text" size="8" placeholder="45" style="margin:0.5em 0 0 0;">° angle<br/>
                    <input tabindex="102" id='gate-forge-rotation-phase' type="text" size="8" placeholder="0" style="margin:0.5em 0 0 0;">° phase
                </td>
                <td></td>
                <td>
                    <style scoped>
                        input[type="checkbox"]:not(:checked) + label {
                            font-weight: bold;
                            background-color: pink;
                        }
                    </style>

                    <textarea tabindex="200" id="gate-forge-matrix" cols="25" rows="5" placeholder="1, i,  i, 1"></textarea><br/>

                    <input tabindex="201" id="gate-forge-matrix-fix" type="checkbox" checked>
                    <label for="gate-forge-matrix-fix">ensure unitary (by SVD)</label>
                </td>
                <td></td>
                <td>
                    From part of current circuit:<br/>
                    <input tabindex="300" id="gate-forge-circuit-cols" type="text" size="4" placeholder="1:∞" style="margin:0.5em 0 0 0;"> column range<br/>
                    <input tabindex="301" id="gate-forge-circuit-rows" type="text" size="4" placeholder="1:∞" style="margin:0.5em 0 0.5em 0;"> wire range<br/>
                    Inputs: <span id="gate-forge-circuit-inputs">(none)</span>, Weight: <span id="gate-forge-circuit-weight">0</span>
                </td>
            </tr>
            <tr>
                <td>
                    <canvas id="gate-forge-rotation-canvas" style="border:1px black solid;width:195px;height:100px;margin:10px 0 0 0;"></canvas>
                </td>
                <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>OR</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                <td>
                    <canvas id="gate-forge-matrix-canvas" style="border:1px black solid;width:195px;height:100px;margin:10px 0 0 0;"></canvas>
                </td>
                <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>OR</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                <td>
                    <canvas id="gate-forge-circuit-canvas" style="border:1px black solid;width:195px;height:100px;margin:10px 0 0 0;"></canvas>
                </td>
            </tr>
            <tr>
                <td>
                    <br/><input tabindex="110" id='gate-forge-rotation-name' type="text" placeholder="[the matrix]" style="width:7em;">  circuit symbol<br/><br/>
                </td>
                <td></td>
                <td>
                    <br/><input tabindex="210" id='gate-forge-matrix-name' type="text" placeholder="[the matrix]" style="width:7em;"> circuit symbol<br/><br/>
                </td>
                <td></td>
                <td>
                    <br/><input tabindex="310" id='gate-forge-circuit-name' type="text" placeholder="[the circuit]" style="width:7em;"> circuit symbol<br/><br/>
                </td>
            </tr>
            <tr>
                <td>
                    <button tabindex="120" id="gate-forge-rotation-button" style="width:100%;height:30px;">Create Rotation Gate</button>
                </td>
                <td></td>
                <td>
                    <button tabindex="220" id="gate-forge-matrix-button" style="width:100%;height:30px;">Create Matrix Gate</button>
                </td>
                <td></td>
                <td>
                    <button tabindex="320" id="gate-forge-circuit-button" style="width:100%;height:30px;">Create Circuit Gate</button>
                </td>
            </tr>
        </table>
    </div>
</div>

        </div>

        <div id="menu-div" style="display:none;">
    <div id="menu-overlay" style="position:fixed; left: 0; top: 0; height: 100vh; width: 100vw; background: rgba(0, 0, 0, 0.7);">
    </div>
    <div style="position:absolute; top:20px; left:50px; margin:0;">
        <div style="display:inline-block; padding:20px; background-color:white; border:1px solid black; text-align:center;">
            <div style="font-size: 32px;">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAJGUlEQVRYw6WXa2xUZRrHf+fM6ZyZdmY6M50yhdJSoLWtWUkLQmvF1W2AaAvpiss2Gy9LrLIJGq/EWyKJbnYDiTHRbDXULWtEN1sNYMuWRaAuKoyASitgOr1bLG1HhplhzrRz6XTOfmjniG3xts/59J7znuf5v+9z+z8CPyBNTU3U1tYCUFFRgc/vswIlQCFQDjimt3qBk0AX0GG32QMul2uWjrlEuNaH5uZmampqKCouShpFNsr3RsPRnLKKsrx0W7pceF1hNkBPb4+il/T+lv0tF2Wj3B0NR/dMq+lwd7oDSV0/GUBjYyN1dXVJ4w/mLMlZs/WRratMVpPV6XTiPuum7NYyPAMeAJyLnZz66BRFy4rweDyEAqFA/av1p4f6h44Cb7g73YGkzpmimwtAd0+31ZHpKF+Qt2D7fXX3bdm2fVvxdddfZ8hakMVA5wCKpFBcWIzP4wMga1EWvaO9iOMiJWUl5OXnGW5ff/vS9PT0m1ApiEVjl10uV8Dr9UZ+FMD0qTevXrP6oYcfebi67NYyvdliBiDoDzIyOsKK0hWkyCn4PX4AbFk2suxZDA8PY7FYMBgNxMZjSDpJnzkv8waz1Zzf4+6RHZkO90wQuquvvbun2wpsvu2O2+599oVny3KX5iLLsra5v78fYpC9OBudqNNuICMrA1Encnn4MoZUA109XTz7xFMcP3WY8+52ll2/PDcj0zGvv7dfdGQ63Dt37oy0tLQAICYDbto/JavXrL7r6e1PL7ekW2YEi4CaUDGZTUiSNMttkiRhMpvQp+nZ9vBjWG8+y7q/DlH90hBvN79Ebl7u8qrfVt0FlNTV1dHc3DwFoKmpSYv2BXkLttx9z92rZxqfQiri9/ixOq3XTClHtoM3X3kL/cJRNj1lwZKlw5wt8OBbaZzo+DcrVq1YXbyseEtRcZG1pqaGpqYmxNraWi3a77zrzg2LixZfI10EImMRzFbzNQFkZmQyOZkgrIQ5dyLM6SaFeFglPqGiTggsK11G5drKDcCDRcVF1tra2ikXACULlyxcs2HTBlMy4GYajxNHVEVMsglp+tGJOnSiTluLiNy4cjme3gm+PDSGIzcFW6qOT5tCqFEjJouJDZs2mPKvz1+TrC3SdIVj6yNbV11tXEBARNSMH3EdQVVVuvq6CIfCRMYjtO5rBaB6YzXGNCPxeJzG3X/H2x/nxD/H6Dk5wZGGELGh+bz8tyew2KZce/+W+1c999hzVFRUIPn8PqtslO81W81WVVUJ+oNcHLmImlDxe/xExiKIqoiqqjAJY74xUuQU7Jl2qmqqprJgXga7d+3mixNfcNp1mrV3rKXugQfoaD+LTtSxueE+iKpc8V3BYrOQZkkz6A363/v8vg4JKImGo0udTidnT54lPBFG1smYzCYKbyjEbDVjkk109XUx5hujdGUpCRIAJMYSSIJEZnYm/X39tH/RzvKVy9n2wjYqVlZwx8bbuXT5EufPnMdkNBGdjGJMMTJ/wfxELBJbBJRI01eic591M2mZpKK0AkOqYVaqhUNhUuQUEiRQUbX3kZQIT/7pST7Y9wGV1ZXc88d7MOgNJEgQJ44tw8Yta24hHo8TGY/ganfhPetN3fLQlryG+oZCCVg3PDL8q9r7azFZTKioCHO0iMh4BHumXVurqEzGJ9n+5Hba2tqoqa3h5V0v4/f6ufzt5TnrRJoljXW3riMUDOH6i2sBsEgCKMgvMHsGPIwyOmd66UQdrftaqaqpIjGWAHUKQOv7rbS1tVFZWcnjzzxO4EIA7xUvB5sPovgUchbmzKlPURQK8gvMhziExC8QSZQYDYyiQ8ejzzzKpt9tIkVIIZ6I/3xdyX6+vna99VoukJCo3liNPdNOQX4B/nE/J988SdnaMuzpdgqWFSAIAgICfb19VG+spvymcuJ8H1BSdygYovVAq5IEcDg3N7fm1EenrD8UhIZUA2ElzDdD3/D5fz+nanMVvl4f8UQcQfgOcHQ8iiHVMOukVwehLqgjOzd7GBiUABrqG3zv/uddvMNeznec19LQ6rRqaWhMMzLoHsTr8XLjb27ElmrjW/VbENBuTERkIjpBmj1tKnCjEZSAQsATIKSEiE5GceqdOJY52P70dh/QJQEdslHu9ng8q0vLS7VCFEvE6DrXpRWiOHFOfXyKmytvxn/JTyQSwa9M8YG+3j6i41EmohOMDo7CEAyeGyQhJDCkGbA5bchWmSXzl2CxWWj/rJ1p6tYh2W32gM/v2xMKhDYKgmBNt6eTbk+fKsU3fFeK9x3ZR9mvy1hUtIjwWBjfJR8Hmw9qpdiQapg6+RAIToHKikokJFTUWbVDCSiBaDi6x26zBySXy0VRcRH1r9afLi0vXZfsByoqk0xqfWHj2o18+P6HFOYXfqfIpwBQflO59m7w3CCVFZUa8FkpGFR47dXXTgO4XC6tG3YM9Q8dPfDegZASVGb9pKIiIZEQEoSiIeLTT87CHHIW5mjrUDREQkhoJ5/L+IH3DoSmyWqHRkjcne4A8Mb+vfsPDLgH5sxXFRVDmgEloFwzp5WAgiHNMKdxgAH3APv37j+QZMoaIWlubsbd6Q4Mfz3c8M7b7xwPXgnO+jlBApvTRsATuCaAgCeAzWnTmtXVErwSZM/be44Pfz3ckJwVNEJSU1NDY2MjQMfxo8f37nhxx5mZIFRUBFEgpISIx+Nz5nlICSGIwqwbCF4JsuPFHWdcR117gY7GxkZtUNFYcUtLC16vN+LIdLgHewfFwcFBkzPDmZtqTtWYsV7SM+oZxZ5hn0XLw6EwIyMjLFm6BIPRoPm868su6l+pP/7J4U/+Bbzp7nQHkox4zrkgCeJC/4XO9o52WVTFxXn5eXpZlpENMr4RH+6LbvLz8r9Hy4+dPIZVbyW3IBdBELSA2/X6rr1fnfnqJeDQdKz9+GS0c+fOyO7G3V/LKXLbZ59+Fjr24THV6XBm+Hw+w7z58/Bd8DFv/jxGvhkhFothtpoZ7h4mZ2mOt6+nL7X7q+7A8089/3HbwbZ/KAHlz+5O9/dmgV88nOqN+j/EwjHH+jvXl07GJ235+flmgK7urouSTlIOthw8Jxvl8f97OP0J4znAuhnbDyeN/pzx/H9hJ0Pb7MiyZAAAAABJRU5ErkJggg=="/>
                Welcome to Quirk
            </div>

            A drag-and-drop quantum circuit simulator.

            <div style="margin:20px;">
                <div id="loading-div" style="color:#D90; font-size:40px; display:block; height:120px; width:344px;">
                    Loading...
                </div>
                <button tabindex="50" id="close-menu-button" style="width:344px; height:120px; font-size:20px; display:none;">Edit Circuit</button>
            </div>

            <div style="display:inline-block; text-align:center; border:1px solid black; padding:4px; margin-right:64px;">
                <a tabindex="51" href="https://www.youtube.com/watch?v=aloFwlBUwsQ">
                    <div style="width:128px;">
                        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAACt0lEQVQoz+3SP09TYRQG8IOL4RsgSNvbv4C4uMAkLgbippEw6CKwqIuGwW/gZEI6kIiDo0MnEk1MmEBLRQFbCnJLa6WlFK6K2kKrBarH55p7TUWa1vgm8pqe5Jc0vbfneZ+8JWYmmUl9+FqBWoFagf+hwP5Jn/TUQw/cgmG4Dz54DH4IQQwSkIaMgf+Q+bu0sStm7PYbWT4je9g4i36meio3a+2eOrgBGeBDKmOcse63Aql29yiwJO79cvjVE+4+YMn0/SyQbHNPA0tm+sfhV9rcdmBJOehNq2sQWFKDFG91eYEl5aXXLS4fsKR8FPM4A8BCtLq3hO2qToCiHqcKLMJOKrW3NnTzZbTFlRO1swKVlt1ODViEr9ks65NPpQor/VeCyx5XQdTuMjSKuBw5YBHMAvoU9/Z4MxzejvdeDOJZUVTGPjlS8UGUYkkBc/JbW7weCGRi53rm8c43kXk6euV0sCgHFTBv46OmcXp8/F3kTNeCyExadDhYlHIFSm/jbTLJqbGx9aWOjoiITFpw2FmUSgXM2/iwscFaIsHRgf7I32ZS2G5nUaopoM+237+61Nm5JCKT5hU7i1LxLxQKaerprrDITAopCotSrsAXVX0f6e4OiswyUdCmsCj7C+wkk9no+QtzeFYUmVOK5qxKDlgEs8CupuWjly7P4LtdUbvLyNGsVdGARSisJArxq9dmZ232gqidFWg0Y7GpwEJYlbywXdVR6UWzbQpYUlP0vNnmA5aUj6aPW73AkvLSsybrALCkBijQZFWAJaWQPlONlgCwZAJkztNGSy+wZHqpdJ4cs4wAS2KEDprJBssgJIEPqU24DnVUbiYamo/AKeiH23AXHsAjmISQIQ4J0CBjyAJX4bPx/idjh27R2DsBD43MUbgDQ3AWjv52YGaWWq1ArUCtQK3Av/UdR/1BF+14cggAAAAASUVORK5CYII=">
                        <div>Tutorial Video</div>
                    </div>
                </a>
            </div>

            <div style="display:inline-block; text-align:center; border:1px solid black; padding:4px;">
                <a tabindex="52" href="https://github.com/Strilanc/Quirk">
                    <div style="width:128px;">
                        <svg version="1.1" viewBox="0 0 16 16" width="48" height="48">
                            <path fill-rule="evenodd"
                                  d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z">
                            </path>
                        </svg>
                        <div>Source Code</div>
                    </div>
                </a>
            </div>
        </div>
        <div style="display:inline-block; vertical-align:top; line-height:1.8; padding:15px 15px 15px 5px; background-color:#DDD; border:1px solid gray; margin:10px 0 0 -5px;">
            Example Circuits<br>
            <a id="example-anchor-grover">Grover Search</a><br>
            <a id="example-anchor-shor">Shor Period Finding</a><br>
            <a id="example-chsh-test">Bell Inequality Test (CHSH)</a><br>
            <a id="example-anchor-teleport">Quantum Teleportation</a><br>
            <a id="example-superdense-coding">Superdense Coding</a><br>
            <a id="example-anchor-delayed-eraser">Delayed Choice Eraser</a><br>
            <a id="example-symmetry-break">Symmetry Breaking</a><br>
            <a id="example-qft">Quantum Fourier Transform</a><br>
            <a id="example-addition">Reversible Addition</a><br>
        </div>
    </div>
</div>


        <div id="error-div" style="display:none; font-size:24px; font-family:monospace; color:red;">
    <div id="error-happened-div">An error happened. :(</div>
    <div id="error-message-div" style="font-size: 16px;"></div>
    <div id="error-known-div" style="font-size: 18px;">
        <br>
        <a id="error-known-issue-anchor">See more / complain about this issue on github</a>.
        <br>
        <br>
    </div>
    <div id="error-report-div">
        <br>
        Please report it:
        <ul style="font-size: 18px;">
            <li>
                <a id="error-github-anchor">Create an issue on github</a>
                (requires an account)
                (repository: <a href="https://github.com/Strilanc/Quirk">Strilanc/Quirk</a>)
            </li>
            <li>
                or <a id="error-mailto-anchor"></a>
            </li>
        </ul>
        <br>
        <br>
        Useful details to mention (auto-included if you use the create/email links above):
        <div style="font-size: 16px;">
            <br>
            <div id="error-description-div"></div>
            <br>
            PRE-DRAWN
            <br>
            <img id="error-image-pre" src="#" style="max-height: 250px; max-width: 600px"/>
            <br>
            POST-DRAWN
            <br>
            <img id="error-image-post" src="#" style="max-height: 250px; max-width: 600px"/>
        </div>
    </div>
</div>


        <!-- Javascript detection -->
        <div id="noscript-div" class="noscript-warning" style="
                        animation-duration: 3.0s;
                   -moz-animation-duration: 3.0s;
                -webkit-animation-duration: 3.0s;
                     -o-animation-duration: 3.0s;
                        animation-name: delay-showing-before-hide-script-can-run-but-then-jump-in;
                   -moz-animation-name: delay-showing-before-hide-script-can-run-but-then-jump-in;
                -webkit-animation-name: delay-showing-before-hide-script-can-run-but-then-jump-in;
                     -o-animation-name: delay-showing-before-hide-script-can-run-but-then-jump-in;
                      background-color: white;
                                border: 1px solid red;
                               padding: 10px;">
            <style scoped>
                @keyframes delay-showing-before-hide-script-can-run-but-then-jump-in {
                    from { opacity: 0; }
                    95% { opacity: 0; }
                    to { opacity: 1; }
                }
                @-webkit-keyframes delay-showing-before-hide-script-can-run-but-then-jump-in {
                    from { opacity: 0; }
                    95% { opacity: 0; }
                    to { opacity: 1; }
                }
                @-moz-keyframes delay-showing-before-hide-script-can-run-but-then-jump-in {
                    from { opacity: 0; }
                    95% { opacity: 0; }
                    to { opacity: 1; }
                }
                @-o-keyframes delay-showing-before-hide-script-can-run-but-then-jump-in {
                    from { opacity: 0; }
                    95% { opacity: 0; }
                    to { opacity: 1; }
                }

                .noscript-warning {
                    color: red;
                    font-size: 24px;
                    position: absolute;
                    top: 25%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                }
            </style>
            You appear to have JavaScript blocked. And Quirk is made out of JavaScript... :(
        </div>
        <script>
          document.getElementById('noscript-div').style.display = 'none';
        </script>
        <script type=text/javascript src="{{url_for('static', filename='jquery.js') }}">
        </script>
        <script>
          document.getElementById('noscript-div').style.display = 'block';
          //noinspection InnerHTMLJS
          document.QUIRK_QUINE_ALL_HTML_ORIGINAL = '<!'+'DOCTYPE html>\n<'+'html>\n    ' +
                  document.documentElement.innerHTML + '\n<' + '/html>';
          document.getElementById('noscript-div').style.display = 'none';
          //DEFAULT_CIRCUIT_START
        document.DEFAULT_CIRCUIT = undefined;
        //DEFAULT_CIRCUIT_END

        // UN-MINIFIED SOURCE IS AVAILABLE FROM github.com/Strilanc/Quirk

        (function(global) {
  'use strict';
  if (global.$traceurRuntime) {
    return;
  }
  function setupGlobals(global) {
    global.Reflect = global.Reflect || {};
    global.Reflect.global = global.Reflect.global || global;
  }
  setupGlobals(global);
  var typeOf = function(x) {
    return typeof x;
  };
  global.$traceurRuntime = {
    options: {},
    setupGlobals: setupGlobals,
    typeof: typeOf
  };
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
(function() {
  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
    var out = [];
    if (opt_scheme) {
      out.push(opt_scheme, ':');
    }
    if (opt_domain) {
      out.push('//');
      if (opt_userInfo) {
        out.push(opt_userInfo, '@');
      }
      out.push(opt_domain);
      if (opt_port) {
        out.push(':', opt_port);
      }
    }
    if (opt_path) {
      out.push(opt_path);
    }
    if (opt_queryData) {
      out.push('?', opt_queryData);
    }
    if (opt_fragment) {
      out.push('#', opt_fragment);
    }
    return out.join('');
  }
  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\w\\d\\-\\u0100-\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\?([^#]*))?' + '(?:#(.*))?' + '$');
  var ComponentIndex = {
    SCHEME: 1,
    USER_INFO: 2,
    DOMAIN: 3,
    PORT: 4,
    PATH: 5,
    QUERY_DATA: 6,
    FRAGMENT: 7
  };
  function split(uri) {
    return (uri.match(splitRe));
  }
  function removeDotSegments(path) {
    if (path === '/')
      return '/';
    var leadingSlash = path[0] === '/' ? '/' : '';
    var trailingSlash = path.slice(-1) === '/' ? '/' : '';
    var segments = path.split('/');
    var out = [];
    var up = 0;
    for (var pos = 0; pos < segments.length; pos++) {
      var segment = segments[pos];
      switch (segment) {
        case '':
        case '.':
          break;
        case '..':
          if (out.length)
            out.pop();
          else
            up++;
          break;
        default:
          out.push(segment);
      }
    }
    if (!leadingSlash) {
      while (up-- > 0) {
        out.unshift('..');
      }
      if (out.length === 0)
        out.push('.');
    }
    return leadingSlash + out.join('/') + trailingSlash;
  }
  function joinAndCanonicalizePath(parts) {
    var path = parts[ComponentIndex.PATH] || '';
    path = removeDotSegments(path);
    parts[ComponentIndex.PATH] = path;
    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);
  }
  function canonicalizeUrl(url) {
    var parts = split(url);
    return joinAndCanonicalizePath(parts);
  }
  function resolveUrl(base, url) {
    var parts = split(url);
    var baseParts = split(base);
    if (parts[ComponentIndex.SCHEME]) {
      return joinAndCanonicalizePath(parts);
    } else {
      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];
    }
    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {
      if (!parts[i]) {
        parts[i] = baseParts[i];
      }
    }
    if (parts[ComponentIndex.PATH][0] == '/') {
      return joinAndCanonicalizePath(parts);
    }
    var path = baseParts[ComponentIndex.PATH];
    var index = path.lastIndexOf('/');
    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];
    parts[ComponentIndex.PATH] = path;
    return joinAndCanonicalizePath(parts);
  }
  function isAbsolute(name) {
    if (!name)
      return false;
    if (name[0] === '/')
      return true;
    var parts = split(name);
    if (parts[ComponentIndex.SCHEME])
      return true;
    return false;
  }
  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;
  $traceurRuntime.isAbsolute = isAbsolute;
  $traceurRuntime.removeDotSegments = removeDotSegments;
  $traceurRuntime.resolveUrl = resolveUrl;
})();
(function(global) {
  'use strict';
  var $__3 = $traceurRuntime,
      canonicalizeUrl = $__3.canonicalizeUrl,
      resolveUrl = $__3.resolveUrl,
      isAbsolute = $__3.isAbsolute;
  var moduleInstantiators = Object.create(null);
  var baseURL;
  if (global.location && global.location.href)
    baseURL = resolveUrl(global.location.href, './');
  else
    baseURL = '';
  function UncoatedModuleEntry(url, uncoatedModule) {
    this.url = url;
    this.value_ = uncoatedModule;
  }
  function ModuleEvaluationError(erroneousModuleName, cause) {
    this.message = this.constructor.name + ': ' + this.stripCause(cause) + ' in ' + erroneousModuleName;
    if (!(cause instanceof ModuleEvaluationError) && cause.stack)
      this.stack = this.stripStack(cause.stack);
    else
      this.stack = '';
  }
  ModuleEvaluationError.prototype = Object.create(Error.prototype);
  ModuleEvaluationError.prototype.constructor = ModuleEvaluationError;
  ModuleEvaluationError.prototype.stripError = function(message) {
    return message.replace(/.*Error:/, this.constructor.name + ':');
  };
  ModuleEvaluationError.prototype.stripCause = function(cause) {
    if (!cause)
      return '';
    if (!cause.message)
      return cause + '';
    return this.stripError(cause.message);
  };
  ModuleEvaluationError.prototype.loadedBy = function(moduleName) {
    this.stack += '\n loaded by ' + moduleName;
  };
  ModuleEvaluationError.prototype.stripStack = function(causeStack) {
    var stack = [];
    causeStack.split('\n').some(function(frame) {
      if (/UncoatedModuleInstantiator/.test(frame))
        return true;
      stack.push(frame);
    });
    stack[0] = this.stripError(stack[0]);
    return stack.join('\n');
  };
  function beforeLines(lines, number) {
    var result = [];
    var first = number - 3;
    if (first < 0)
      first = 0;
    for (var i = first; i < number; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function afterLines(lines, number) {
    var last = number + 1;
    if (last > lines.length - 1)
      last = lines.length - 1;
    var result = [];
    for (var i = number; i <= last; i++) {
      result.push(lines[i]);
    }
    return result;
  }
  function columnSpacing(columns) {
    var result = '';
    for (var i = 0; i < columns - 1; i++) {
      result += '-';
    }
    return result;
  }
  function UncoatedModuleInstantiator(url, func) {
    UncoatedModuleEntry.call(this, url, null);
    this.func = func;
  }
  UncoatedModuleInstantiator.prototype = Object.create(UncoatedModuleEntry.prototype);
  UncoatedModuleInstantiator.prototype.getUncoatedModule = function() {
    var $__2 = this;
    if (this.value_)
      return this.value_;
    try {
      var relativeRequire;
      if (typeof $traceurRuntime !== undefined && $traceurRuntime.require) {
        relativeRequire = $traceurRuntime.require.bind(null, this.url);
      }
      return this.value_ = this.func.call(global, relativeRequire);
    } catch (ex) {
      if (ex instanceof ModuleEvaluationError) {
        ex.loadedBy(this.url);
        throw ex;
      }
      if (ex.stack) {
        var lines = this.func.toString().split('\n');
        var evaled = [];
        ex.stack.split('\n').some(function(frame, index) {
          if (frame.indexOf('UncoatedModuleInstantiator.getUncoatedModule') > 0)
            return true;
          var m = /(at\s[^\s]*\s).*>:(\d*):(\d*)\)/.exec(frame);
          if (m) {
            var line = parseInt(m[2], 10);
            evaled = evaled.concat(beforeLines(lines, line));
            if (index === 1) {
              evaled.push(columnSpacing(m[3]) + '^ ' + $__2.url);
            } else {
              evaled.push(columnSpacing(m[3]) + '^');
            }
            evaled = evaled.concat(afterLines(lines, line));
            evaled.push('= = = = = = = = =');
          } else {
            evaled.push(frame);
          }
        });
        ex.stack = evaled.join('\n');
      }
      throw new ModuleEvaluationError(this.url, ex);
    }
  };
  function getUncoatedModuleInstantiator(name) {
    if (!name)
      return;
    var url = ModuleStore.normalize(name);
    return moduleInstantiators[url];
  }
  ;
  var moduleInstances = Object.create(null);
  var liveModuleSentinel = {};
  function Module(uncoatedModule) {
    var isLive = arguments[1];
    var coatedModule = Object.create(null);
    Object.getOwnPropertyNames(uncoatedModule).forEach(function(name) {
      var getter,
          value;
      if (isLive === liveModuleSentinel) {
        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);
        if (descr.get)
          getter = descr.get;
      }
      if (!getter) {
        value = uncoatedModule[name];
        getter = function() {
          return value;
        };
      }
      Object.defineProperty(coatedModule, name, {
        get: getter,
        enumerable: true
      });
    });
    Object.preventExtensions(coatedModule);
    return coatedModule;
  }
  var ModuleStore = {
    normalize: function(name, refererName, refererAddress) {
      if (typeof name !== 'string')
        throw new TypeError('module name must be a string, not ' + typeof name);
      if (isAbsolute(name))
        return canonicalizeUrl(name);
      if (/[^\.]\/\.\.\//.test(name)) {
        throw new Error('module name embeds /../: ' + name);
      }
      if (name[0] === '.' && refererName)
        return resolveUrl(refererName, name);
      return canonicalizeUrl(name);
    },
    get: function(normalizedName) {
      var m = getUncoatedModuleInstantiator(normalizedName);
      if (!m)
        return undefined;
      var moduleInstance = moduleInstances[m.url];
      if (moduleInstance)
        return moduleInstance;
      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);
      return moduleInstances[m.url] = moduleInstance;
    },
    set: function(normalizedName, module) {
      normalizedName = String(normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, function() {
        return module;
      });
      moduleInstances[normalizedName] = module;
    },
    get baseURL() {
      return baseURL;
    },
    set baseURL(v) {
      baseURL = String(v);
    },
    registerModule: function(name, deps, func) {
      var normalizedName = ModuleStore.normalize(name);
      if (moduleInstantiators[normalizedName])
        throw new Error('duplicate module named ' + normalizedName);
      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);
    },
    bundleStore: Object.create(null),
    register: function(name, deps, func) {
      if (!deps || !deps.length && !func.length) {
        this.registerModule(name, deps, func);
      } else {
        this.bundleStore[name] = {
          deps: deps,
          execute: function() {
            var $__2 = arguments;
            var depMap = {};
            deps.forEach(function(dep, index) {
              return depMap[dep] = $__2[index];
            });
            var registryEntry = func.call(this, depMap);
            registryEntry.execute.call(this);
            return registryEntry.exports;
          }
        };
      }
    },
    getAnonymousModule: function(func) {
      return new Module(func(), liveModuleSentinel);
    }
  };
  var moduleStoreModule = new Module({ModuleStore: ModuleStore});
  ModuleStore.set('@traceur/src/runtime/ModuleStore.js', moduleStoreModule);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
  };
  $traceurRuntime.ModuleStore = ModuleStore;
  $traceurRuntime.registerModule = ModuleStore.registerModule.bind(ModuleStore);
  $traceurRuntime.getModule = ModuleStore.get;
  $traceurRuntime.setModule = ModuleStore.set;
  $traceurRuntime.normalizeModuleName = ModuleStore.normalize;
})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this);
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/new-unique-string.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/new-unique-string.js";
  var random = Math.random;
  var counter = Date.now() % 1e9;
  function newUniqueString() {
    return '__$' + (random() * 1e9 >>> 1) + '$' + ++counter + '$__';
  }
  return {get default() {
      return newUniqueString;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/has-native-symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/has-native-symbols.js";
  var v = !!Object.getOwnPropertySymbols && typeof Symbol === 'function';
  function hasNativeSymbol() {
    return v;
  }
  return {get default() {
      return hasNativeSymbol;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/symbols.js";
  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../new-unique-string.js", "traceur-runtime@0.0.111/src/runtime/modules/symbols.js")).default;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/modules/symbols.js")).default;
  var $create = Object.create;
  var $defineProperty = Object.defineProperty;
  var $freeze = Object.freeze;
  var $getOwnPropertyNames = Object.getOwnPropertyNames;
  var $keys = Object.keys;
  var $TypeError = TypeError;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var symbolInternalProperty = newUniqueString();
  var symbolDescriptionProperty = newUniqueString();
  var symbolDataProperty = newUniqueString();
  var symbolValues = $create(null);
  var SymbolImpl = function Symbol(description) {
    var value = new SymbolValue(description);
    if (!(this instanceof SymbolImpl))
      return value;
    throw new $TypeError('Symbol cannot be new\'ed');
  };
  $defineProperty(SymbolImpl.prototype, 'constructor', nonEnum(SymbolImpl));
  $defineProperty(SymbolImpl.prototype, 'toString', nonEnum(function() {
    var symbolValue = this[symbolDataProperty];
    return symbolValue[symbolInternalProperty];
  }));
  $defineProperty(SymbolImpl.prototype, 'valueOf', nonEnum(function() {
    var symbolValue = this[symbolDataProperty];
    if (!symbolValue)
      throw $TypeError('Conversion from symbol to string');
    return symbolValue[symbolInternalProperty];
  }));
  function SymbolValue(description) {
    var key = newUniqueString();
    $defineProperty(this, symbolDataProperty, {value: this});
    $defineProperty(this, symbolInternalProperty, {value: key});
    $defineProperty(this, symbolDescriptionProperty, {value: description});
    $freeze(this);
    symbolValues[key] = this;
  }
  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(SymbolImpl));
  $defineProperty(SymbolValue.prototype, 'toString', {
    value: SymbolImpl.prototype.toString,
    enumerable: false
  });
  $defineProperty(SymbolValue.prototype, 'valueOf', {
    value: SymbolImpl.prototype.valueOf,
    enumerable: false
  });
  $freeze(SymbolValue.prototype);
  function isSymbolString(s) {
    return symbolValues[s];
  }
  function removeSymbolKeys(array) {
    var rv = [];
    for (var i = 0; i < array.length; i++) {
      if (!isSymbolString(array[i])) {
        rv.push(array[i]);
      }
    }
    return rv;
  }
  function getOwnPropertyNames(object) {
    return removeSymbolKeys($getOwnPropertyNames(object));
  }
  function keys(object) {
    return removeSymbolKeys($keys(object));
  }
  function getOwnPropertySymbols(object) {
    var rv = [];
    var names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var symbol = symbolValues[names[i]];
      if (symbol) {
        rv.push(symbol);
      }
    }
    return rv;
  }
  function polyfillSymbol(global) {
    var Object = global.Object;
    if (!hasNativeSymbol()) {
      global.Symbol = SymbolImpl;
      Object.getOwnPropertyNames = getOwnPropertyNames;
      Object.keys = keys;
      $defineProperty(Object, 'getOwnPropertySymbols', nonEnum(getOwnPropertySymbols));
    }
    if (!global.Symbol.iterator) {
      global.Symbol.iterator = global.Symbol('Symbol.iterator');
    }
    if (!global.Symbol.observer) {
      global.Symbol.observer = global.Symbol('Symbol.observer');
    }
  }
  var g = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : (void 0);
  polyfillSymbol(g);
  var typeOf = hasNativeSymbol() ? function(x) {
    return typeof x;
  } : function(x) {
    return x instanceof SymbolValue ? 'symbol' : typeof x;
  };
  return {get typeof() {
      return typeOf;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/typeof.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/typeof.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./symbols.js", "traceur-runtime@0.0.111/src/runtime/modules/typeof.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_symbols_46_js__.typeof;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/symbols.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/symbols.js";
  var t = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/typeof.js", "traceur-runtime@0.0.111/src/runtime/symbols.js")).default;
  $traceurRuntime.typeof = t;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createClass.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createClass.js";
  var $Object = Object;
  var $TypeError = TypeError;
  var $__1 = Object,
      create = $__1.create,
      defineProperties = $__1.defineProperties,
      defineProperty = $__1.defineProperty,
      getOwnPropertyDescriptor = $__1.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      getOwnPropertySymbols = $__1.getOwnPropertySymbols;
  function forEachPropertyKey(object, f) {
    getOwnPropertyNames(object).forEach(f);
    if (getOwnPropertySymbols) {
      getOwnPropertySymbols(object).forEach(f);
    }
  }
  function getDescriptors(object) {
    var descriptors = {};
    forEachPropertyKey(object, function(key) {
      descriptors[key] = getOwnPropertyDescriptor(object, key);
      descriptors[key].enumerable = false;
    });
    return descriptors;
  }
  var nonEnum = {enumerable: false};
  function makePropertiesNonEnumerable(object) {
    forEachPropertyKey(object, function(key) {
      defineProperty(object, key, nonEnum);
    });
  }
  function createClass(ctor, object, staticObject, superClass) {
    defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function')
        ctor.__proto__ = superClass;
      ctor.prototype = create(getProtoParent(superClass), getDescriptors(object));
    } else {
      makePropertiesNonEnumerable(object);
      ctor.prototype = object;
    }
    defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null)
        return superClass.prototype;
      throw new $TypeError('super prototype must be an Object or null');
    }
    if (superClass === null)
      return null;
    throw new $TypeError(("Super expression must either be null or a function, not " + typeof superClass + "."));
  }
  return {get default() {
      return createClass;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superConstructor.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superConstructor.js";
  function superConstructor(ctor) {
    return ctor.__proto__;
  }
  return {get default() {
      return superConstructor;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superDescriptor.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superDescriptor.js";
  var $__0 = Object,
      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,
      getPrototypeOf = $__0.getPrototypeOf;
  function superDescriptor(homeObject, name) {
    var proto = getPrototypeOf(homeObject);
    do {
      var result = getOwnPropertyDescriptor(proto, name);
      if (result)
        return result;
      proto = getPrototypeOf(proto);
    } while (proto);
    return undefined;
  }
  return {get default() {
      return superDescriptor;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superGet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superGet.js";
  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./superDescriptor.js", "traceur-runtime@0.0.111/src/runtime/modules/superGet.js")).default;
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      var value = descriptor.value;
      if (value)
        return value;
      if (!descriptor.get)
        return value;
      return descriptor.get.call(self);
    }
    return undefined;
  }
  return {get default() {
      return superGet;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/superSet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/superSet.js";
  var superDescriptor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./superDescriptor.js", "traceur-runtime@0.0.111/src/runtime/modules/superSet.js")).default;
  var $TypeError = TypeError;
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return value;
    }
    throw $TypeError(("super has no setter '" + name + "'."));
  }
  return {get default() {
      return superSet;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/classes.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/classes.js";
  var createClass = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createClass.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superConstructor = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superConstructor.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superGet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superGet.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  var superSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/superSet.js", "traceur-runtime@0.0.111/src/runtime/classes.js")).default;
  $traceurRuntime.createClass = createClass;
  $traceurRuntime.superConstructor = superConstructor;
  $traceurRuntime.superGet = superGet;
  $traceurRuntime.superSet = superSet;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/exportStar.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/exportStar.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      getOwnPropertyNames = $__1.getOwnPropertyNames;
  function exportStar(object) {
    var $__2 = arguments,
        $__3 = function(i) {
          var mod = $__2[i];
          var names = getOwnPropertyNames(mod);
          var $__5 = function(j) {
            var name = names[j];
            if (name === '__esModule' || name === 'default') {
              return 0;
            }
            defineProperty(object, name, {
              get: function() {
                return mod[name];
              },
              enumerable: true
            });
          },
              $__6;
          $__4: for (var j = 0; j < names.length; j++) {
            $__6 = $__5(j);
            switch ($__6) {
              case 0:
                continue $__4;
            }
          }
        };
    for (var i = 1; i < arguments.length; i++) {
      $__3(i);
    }
    return object;
  }
  return {get default() {
      return exportStar;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/exportStar.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/exportStar.js";
  var exportStar = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/exportStar.js", "traceur-runtime@0.0.111/src/runtime/exportStar.js")).default;
  $traceurRuntime.exportStar = exportStar;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private-symbol.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private-symbol.js";
  var newUniqueString = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./new-unique-string.js", "traceur-runtime@0.0.111/src/runtime/private-symbol.js")).default;
  var $Symbol = typeof Symbol === 'function' ? Symbol : undefined;
  var $getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var $create = Object.create;
  var privateNames = $create(null);
  function isPrivateSymbol(s) {
    return privateNames[s];
  }
  ;
  function createPrivateSymbol() {
    var s = ($Symbol || newUniqueString)();
    privateNames[s] = true;
    return s;
  }
  ;
  function hasPrivate(obj, sym) {
    return hasOwnProperty.call(obj, sym);
  }
  ;
  function deletePrivate(obj, sym) {
    if (!hasPrivate(obj, sym)) {
      return false;
    }
    delete obj[sym];
    return true;
  }
  ;
  function setPrivate(obj, sym, val) {
    obj[sym] = val;
  }
  ;
  function getPrivate(obj, sym) {
    var val = obj[sym];
    if (val === undefined)
      return undefined;
    return hasOwnProperty.call(obj, sym) ? val : undefined;
  }
  ;
  function init() {
    if ($getOwnPropertySymbols) {
      Object.getOwnPropertySymbols = function getOwnPropertySymbols(object) {
        var rv = [];
        var symbols = $getOwnPropertySymbols(object);
        for (var i = 0; i < symbols.length; i++) {
          var symbol = symbols[i];
          if (!isPrivateSymbol(symbol)) {
            rv.push(symbol);
          }
        }
        return rv;
      };
    }
  }
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    },
    get init() {
      return init;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private-weak-map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private-weak-map.js";
  var $WeakMap = typeof WeakMap === 'function' ? WeakMap : undefined;
  function isPrivateSymbol(s) {
    return false;
  }
  function createPrivateSymbol() {
    return new $WeakMap();
  }
  function hasPrivate(obj, sym) {
    return sym.has(obj);
  }
  function deletePrivate(obj, sym) {
    return sym.delete(obj);
  }
  function setPrivate(obj, sym, val) {
    sym.set(obj, val);
  }
  function getPrivate(obj, sym) {
    return sym.get(obj);
  }
  function init() {}
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    },
    get init() {
      return init;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/private.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/private.js";
  var sym = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./private-symbol.js", "traceur-runtime@0.0.111/src/runtime/private.js"));
  var weak = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./private-weak-map.js", "traceur-runtime@0.0.111/src/runtime/private.js"));
  var hasWeakMap = typeof WeakMap === 'function';
  var m = hasWeakMap ? weak : sym;
  var isPrivateSymbol = m.isPrivateSymbol;
  var createPrivateSymbol = m.createPrivateSymbol;
  var hasPrivate = m.hasPrivate;
  var deletePrivate = m.deletePrivate;
  var setPrivate = m.setPrivate;
  var getPrivate = m.getPrivate;
  m.init();
  return {
    get isPrivateSymbol() {
      return isPrivateSymbol;
    },
    get createPrivateSymbol() {
      return createPrivateSymbol;
    },
    get hasPrivate() {
      return hasPrivate;
    },
    get deletePrivate() {
      return deletePrivate;
    },
    get setPrivate() {
      return setPrivate;
    },
    get getPrivate() {
      return getPrivate;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js";
  var $__0 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/properTailCalls.js")),
      getPrivate = $__0.getPrivate,
      setPrivate = $__0.setPrivate,
      createPrivateSymbol = $__0.createPrivateSymbol;
  var $apply = Function.prototype.call.bind(Function.prototype.apply);
  var CONTINUATION_TYPE = Object.create(null);
  var isTailRecursiveName = null;
  function createContinuation(operand, thisArg, argsArray) {
    return [CONTINUATION_TYPE, operand, thisArg, argsArray];
  }
  function isContinuation(object) {
    return object && object[0] === CONTINUATION_TYPE;
  }
  function $bind(operand, thisArg, args) {
    var argArray = [thisArg];
    for (var i = 0; i < args.length; i++) {
      argArray[i + 1] = args[i];
    }
    var func = $apply(Function.prototype.bind, operand, argArray);
    return func;
  }
  function $construct(func, argArray) {
    var object = new ($bind(func, null, argArray));
    return object;
  }
  function isTailRecursive(func) {
    return !!getPrivate(func, isTailRecursiveName);
  }
  function tailCall(func, thisArg, argArray) {
    var continuation = argArray[0];
    if (isContinuation(continuation)) {
      continuation = $apply(func, thisArg, continuation[3]);
      return continuation;
    }
    continuation = createContinuation(func, thisArg, argArray);
    while (true) {
      if (isTailRecursive(func)) {
        continuation = $apply(func, continuation[2], [continuation]);
      } else {
        continuation = $apply(func, continuation[2], continuation[3]);
      }
      if (!isContinuation(continuation)) {
        return continuation;
      }
      func = continuation[1];
    }
  }
  function construct() {
    var object;
    if (isTailRecursive(this)) {
      object = $construct(this, [createContinuation(null, null, arguments)]);
    } else {
      object = $construct(this, arguments);
    }
    return object;
  }
  function setupProperTailCalls() {
    isTailRecursiveName = createPrivateSymbol();
    Function.prototype.call = initTailRecursiveFunction(function call(thisArg) {
      var result = tailCall(function(thisArg) {
        var argArray = [];
        for (var i = 1; i < arguments.length; ++i) {
          argArray[i - 1] = arguments[i];
        }
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
    Function.prototype.apply = initTailRecursiveFunction(function apply(thisArg, argArray) {
      var result = tailCall(function(thisArg, argArray) {
        var continuation = createContinuation(this, thisArg, argArray);
        return continuation;
      }, this, arguments);
      return result;
    });
  }
  function initTailRecursiveFunction(func) {
    if (isTailRecursiveName === null) {
      setupProperTailCalls();
    }
    setPrivate(func, isTailRecursiveName, true);
    return func;
  }
  return {
    get createContinuation() {
      return createContinuation;
    },
    get tailCall() {
      return tailCall;
    },
    get construct() {
      return construct;
    },
    get initTailRecursiveFunction() {
      return initTailRecursiveFunction;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/initTailRecursiveFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.initTailRecursiveFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/call.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/call.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/call.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.tailCall;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/continuation.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/continuation.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/continuation.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.createContinuation;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/construct.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/construct.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/modules/construct.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_properTailCalls_46_js__.construct;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/properTailCalls.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/properTailCalls.js";
  var initTailRecursiveFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initTailRecursiveFunction.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var call = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/call.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var continuation = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/continuation.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  var construct = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/construct.js", "traceur-runtime@0.0.111/src/runtime/properTailCalls.js")).default;
  $traceurRuntime.initTailRecursiveFunction = initTailRecursiveFunction;
  $traceurRuntime.call = call;
  $traceurRuntime.continuation = continuation;
  $traceurRuntime.construct = construct;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/relativeRequire.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/relativeRequire.js";
  var path;
  function relativeRequire(callerPath, requiredPath) {
    path = path || typeof require !== 'undefined' && require('path');
    function isDirectory(path) {
      return path.slice(-1) === '/';
    }
    function isAbsolute(path) {
      return path[0] === '/';
    }
    function isRelative(path) {
      return path[0] === '.';
    }
    if (isDirectory(requiredPath) || isAbsolute(requiredPath))
      return;
    return isRelative(requiredPath) ? require(path.resolve(path.dirname(callerPath), requiredPath)) : require(requiredPath);
  }
  $traceurRuntime.require = relativeRequire;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/checkObjectCoercible.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/checkObjectCoercible.js";
  var $TypeError = TypeError;
  function checkObjectCoercible(v) {
    if (v === null || v === undefined) {
      throw new $TypeError('Value cannot be converted to an Object');
    }
    return v;
  }
  return {get default() {
      return checkObjectCoercible;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spread.js";
  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../checkObjectCoercible.js", "traceur-runtime@0.0.111/src/runtime/modules/spread.js")).default;
  function spread() {
    var rv = [],
        j = 0,
        iterResult;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = checkObjectCoercible(arguments[i]);
      if (typeof valueToSpread[Symbol.iterator] !== 'function') {
        throw new TypeError('Cannot spread non-iterable object.');
      }
      var iter = valueToSpread[Symbol.iterator]();
      while (!(iterResult = iter.next()).done) {
        rv[j++] = iterResult.value;
      }
    }
    return rv;
  }
  return {get default() {
      return spread;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/spread.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/spread.js";
  var spread = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spread.js", "traceur-runtime@0.0.111/src/runtime/spread.js")).default;
  $traceurRuntime.spread = spread;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/iteratorToArray.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/iteratorToArray.js";
  function iteratorToArray(iter) {
    var rv = [];
    var i = 0;
    var tmp;
    while (!(tmp = iter.next()).done) {
      rv[i++] = tmp.value;
    }
    return rv;
  }
  return {get default() {
      return iteratorToArray;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/destructuring.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/destructuring.js";
  var iteratorToArray = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/iteratorToArray.js", "traceur-runtime@0.0.111/src/runtime/destructuring.js")).default;
  $traceurRuntime.iteratorToArray = iteratorToArray;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/async.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/async.js";
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/async.js")),
      createPrivateSymbol = $__12.createPrivateSymbol,
      getPrivate = $__12.getPrivate,
      setPrivate = $__12.setPrivate;
  var $__11 = Object,
      create = $__11.create,
      defineProperty = $__11.defineProperty;
  var observeName = createPrivateSymbol();
  function AsyncGeneratorFunction() {}
  function AsyncGeneratorFunctionPrototype() {}
  AsyncGeneratorFunction.prototype = AsyncGeneratorFunctionPrototype;
  AsyncGeneratorFunctionPrototype.constructor = AsyncGeneratorFunction;
  defineProperty(AsyncGeneratorFunctionPrototype, 'constructor', {enumerable: false});
  var AsyncGeneratorContext = function() {
    function AsyncGeneratorContext(observer) {
      var $__2 = this;
      this.decoratedObserver = createDecoratedGenerator(observer, function() {
        $__2.done = true;
      });
      this.done = false;
      this.inReturn = false;
    }
    return ($traceurRuntime.createClass)(AsyncGeneratorContext, {
      throw: function(error) {
        if (!this.inReturn) {
          throw error;
        }
      },
      yield: function(value) {
        if (this.done) {
          this.inReturn = true;
          throw undefined;
        }
        var result;
        try {
          result = this.decoratedObserver.next(value);
        } catch (e) {
          this.done = true;
          throw e;
        }
        if (result === undefined) {
          return;
        }
        if (result.done) {
          this.done = true;
          this.inReturn = true;
          throw undefined;
        }
        return result.value;
      },
      yieldFor: function(observable) {
        var ctx = this;
        return observeForEach(observable[Symbol.observer].bind(observable), function(value) {
          if (ctx.done) {
            this.return();
            return;
          }
          var result;
          try {
            result = ctx.decoratedObserver.next(value);
          } catch (e) {
            ctx.done = true;
            throw e;
          }
          if (result === undefined) {
            return;
          }
          if (result.done) {
            ctx.done = true;
          }
          return result;
        });
      }
    }, {});
  }();
  AsyncGeneratorFunctionPrototype.prototype[Symbol.observer] = function(observer) {
    var observe = getPrivate(this, observeName);
    var ctx = new AsyncGeneratorContext(observer);
    schedule(function() {
      return observe(ctx);
    }).then(function(value) {
      if (!ctx.done) {
        ctx.decoratedObserver.return(value);
      }
    }).catch(function(error) {
      if (!ctx.done) {
        ctx.decoratedObserver.throw(error);
      }
    });
    return ctx.decoratedObserver;
  };
  defineProperty(AsyncGeneratorFunctionPrototype.prototype, Symbol.observer, {enumerable: false});
  function initAsyncGeneratorFunction(functionObject) {
    functionObject.prototype = create(AsyncGeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = AsyncGeneratorFunctionPrototype;
    return functionObject;
  }
  function createAsyncGeneratorInstance(observe, functionObject) {
    for (var args = [],
        $__10 = 2; $__10 < arguments.length; $__10++)
      args[$__10 - 2] = arguments[$__10];
    var object = create(functionObject.prototype);
    setPrivate(object, observeName, observe);
    return object;
  }
  function observeForEach(observe, next) {
    return new Promise(function(resolve, reject) {
      var generator = observe({
        next: function(value) {
          return next.call(generator, value);
        },
        throw: function(error) {
          reject(error);
        },
        return: function(value) {
          resolve(value);
        }
      });
    });
  }
  function schedule(asyncF) {
    return Promise.resolve().then(asyncF);
  }
  var generator = Symbol();
  var onDone = Symbol();
  var DecoratedGenerator = function() {
    function DecoratedGenerator(_generator, _onDone) {
      this[generator] = _generator;
      this[onDone] = _onDone;
    }
    return ($traceurRuntime.createClass)(DecoratedGenerator, {
      next: function(value) {
        var result = this[generator].next(value);
        if (result !== undefined && result.done) {
          this[onDone].call(this);
        }
        return result;
      },
      throw: function(error) {
        this[onDone].call(this);
        return this[generator].throw(error);
      },
      return: function(value) {
        this[onDone].call(this);
        return this[generator].return(value);
      }
    }, {});
  }();
  function createDecoratedGenerator(generator, onDone) {
    return new DecoratedGenerator(generator, onDone);
  }
  Array.prototype[Symbol.observer] = function(observer) {
    var done = false;
    var decoratedObserver = createDecoratedGenerator(observer, function() {
      return done = true;
    });
    var $__6 = true;
    var $__7 = false;
    var $__8 = undefined;
    try {
      for (var $__4 = void 0,
          $__3 = (this)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
        var value = $__4.value;
        {
          decoratedObserver.next(value);
          if (done) {
            return;
          }
        }
      }
    } catch ($__9) {
      $__7 = true;
      $__8 = $__9;
    } finally {
      try {
        if (!$__6 && $__3.return != null) {
          $__3.return();
        }
      } finally {
        if ($__7) {
          throw $__8;
        }
      }
    }
    decoratedObserver.return();
    return decoratedObserver;
  };
  defineProperty(Array.prototype, Symbol.observer, {enumerable: false});
  return {
    get initAsyncGeneratorFunction() {
      return initAsyncGeneratorFunction;
    },
    get createAsyncGeneratorInstance() {
      return createAsyncGeneratorInstance;
    },
    get observeForEach() {
      return observeForEach;
    },
    get schedule() {
      return schedule;
    },
    get createDecoratedGenerator() {
      return createDecoratedGenerator;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/initAsyncGeneratorFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.initAsyncGeneratorFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/createAsyncGeneratorInstance.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createAsyncGeneratorInstance;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/observeForEach.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.observeForEach;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/schedule.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/schedule.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/schedule.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.schedule;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/modules/createDecoratedGenerator.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_async_46_js__.createDecoratedGenerator;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/async.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/async.js";
  var initAsyncGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initAsyncGeneratorFunction.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var createAsyncGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createAsyncGeneratorInstance.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var observeForEach = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/observeForEach.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var schedule = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/schedule.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  var createDecoratedGenerator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createDecoratedGenerator.js", "traceur-runtime@0.0.111/src/runtime/async.js")).default;
  $traceurRuntime.initAsyncGeneratorFunction = initAsyncGeneratorFunction;
  $traceurRuntime.createAsyncGeneratorInstance = createAsyncGeneratorInstance;
  $traceurRuntime.observeForEach = observeForEach;
  $traceurRuntime.schedule = schedule;
  $traceurRuntime.createDecoratedGenerator = createDecoratedGenerator;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/generators.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/modules/generators.js")),
      createPrivateSymbol = $__2.createPrivateSymbol,
      getPrivate = $__2.getPrivate,
      setPrivate = $__2.setPrivate;
  var $TypeError = TypeError;
  var $__1 = Object,
      create = $__1.create,
      defineProperties = $__1.defineProperties,
      defineProperty = $__1.defineProperty;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var ST_NEWBORN = 0;
  var ST_EXECUTING = 1;
  var ST_SUSPENDED = 2;
  var ST_CLOSED = 3;
  var END_STATE = -2;
  var RETHROW_STATE = -3;
  function getInternalError(state) {
    return new Error('Traceur compiler bug: invalid state in state machine: ' + state);
  }
  var RETURN_SENTINEL = {};
  function GeneratorContext() {
    this.state = 0;
    this.GState = ST_NEWBORN;
    this.storedException = undefined;
    this.finallyFallThrough = undefined;
    this.sent_ = undefined;
    this.returnValue = undefined;
    this.oldReturnValue = undefined;
    this.tryStack_ = [];
  }
  GeneratorContext.prototype = {
    pushTry: function(catchState, finallyState) {
      if (finallyState !== null) {
        var finallyFallThrough = null;
        for (var i = this.tryStack_.length - 1; i >= 0; i--) {
          if (this.tryStack_[i].catch !== undefined) {
            finallyFallThrough = this.tryStack_[i].catch;
            break;
          }
        }
        if (finallyFallThrough === null)
          finallyFallThrough = RETHROW_STATE;
        this.tryStack_.push({
          finally: finallyState,
          finallyFallThrough: finallyFallThrough
        });
      }
      if (catchState !== null) {
        this.tryStack_.push({catch: catchState});
      }
    },
    popTry: function() {
      this.tryStack_.pop();
    },
    maybeUncatchable: function() {
      if (this.storedException === RETURN_SENTINEL) {
        throw RETURN_SENTINEL;
      }
    },
    get sent() {
      this.maybeThrow();
      return this.sent_;
    },
    set sent(v) {
      this.sent_ = v;
    },
    get sentIgnoreThrow() {
      return this.sent_;
    },
    maybeThrow: function() {
      if (this.action === 'throw') {
        this.action = 'next';
        throw this.sent_;
      }
    },
    end: function() {
      switch (this.state) {
        case END_STATE:
          return this;
        case RETHROW_STATE:
          throw this.storedException;
        default:
          throw getInternalError(this.state);
      }
    },
    handleException: function(ex) {
      this.GState = ST_CLOSED;
      this.state = END_STATE;
      throw ex;
    },
    wrapYieldStar: function(iterator) {
      var ctx = this;
      return {
        next: function(v) {
          return iterator.next(v);
        },
        throw: function(e) {
          var result;
          if (e === RETURN_SENTINEL) {
            if (iterator.return) {
              result = iterator.return(ctx.returnValue);
              if (!result.done) {
                ctx.returnValue = ctx.oldReturnValue;
                return result;
              }
              ctx.returnValue = result.value;
            }
            throw e;
          }
          if (iterator.throw) {
            return iterator.throw(e);
          }
          iterator.return && iterator.return();
          throw $TypeError('Inner iterator does not have a throw method');
        }
      };
    }
  };
  function nextOrThrow(ctx, moveNext, action, x) {
    switch (ctx.GState) {
      case ST_EXECUTING:
        throw new Error(("\"" + action + "\" on executing generator"));
      case ST_CLOSED:
        if (action == 'next') {
          return {
            value: undefined,
            done: true
          };
        }
        if (x === RETURN_SENTINEL) {
          return {
            value: ctx.returnValue,
            done: true
          };
        }
        throw x;
      case ST_NEWBORN:
        if (action === 'throw') {
          ctx.GState = ST_CLOSED;
          if (x === RETURN_SENTINEL) {
            return {
              value: ctx.returnValue,
              done: true
            };
          }
          throw x;
        }
        if (x !== undefined)
          throw $TypeError('Sent value to newborn generator');
      case ST_SUSPENDED:
        ctx.GState = ST_EXECUTING;
        ctx.action = action;
        ctx.sent = x;
        var value;
        try {
          value = moveNext(ctx);
        } catch (ex) {
          if (ex === RETURN_SENTINEL) {
            value = ctx;
          } else {
            throw ex;
          }
        }
        var done = value === ctx;
        if (done)
          value = ctx.returnValue;
        ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;
        return {
          value: value,
          done: done
        };
    }
  }
  var ctxName = createPrivateSymbol();
  var moveNextName = createPrivateSymbol();
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  defineProperty(GeneratorFunctionPrototype, 'constructor', nonEnum(GeneratorFunction));
  GeneratorFunctionPrototype.prototype = {
    constructor: GeneratorFunctionPrototype,
    next: function(v) {
      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), 'next', v);
    },
    throw: function(v) {
      return nextOrThrow(getPrivate(this, ctxName), getPrivate(this, moveNextName), 'throw', v);
    },
    return: function(v) {
      var ctx = getPrivate(this, ctxName);
      ctx.oldReturnValue = ctx.returnValue;
      ctx.returnValue = v;
      return nextOrThrow(ctx, getPrivate(this, moveNextName), 'throw', RETURN_SENTINEL);
    }
  };
  defineProperties(GeneratorFunctionPrototype.prototype, {
    constructor: {enumerable: false},
    next: {enumerable: false},
    throw: {enumerable: false},
    return: {enumerable: false}
  });
  Object.defineProperty(GeneratorFunctionPrototype.prototype, Symbol.iterator, nonEnum(function() {
    return this;
  }));
  function createGeneratorInstance(innerFunction, functionObject, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new GeneratorContext();
    var object = create(functionObject.prototype);
    setPrivate(object, ctxName, ctx);
    setPrivate(object, moveNextName, moveNext);
    return object;
  }
  function initGeneratorFunction(functionObject) {
    functionObject.prototype = create(GeneratorFunctionPrototype.prototype);
    functionObject.__proto__ = GeneratorFunctionPrototype;
    return functionObject;
  }
  function AsyncFunctionContext() {
    GeneratorContext.call(this);
    this.err = undefined;
    var ctx = this;
    ctx.result = new Promise(function(resolve, reject) {
      ctx.resolve = resolve;
      ctx.reject = reject;
    });
  }
  AsyncFunctionContext.prototype = create(GeneratorContext.prototype);
  AsyncFunctionContext.prototype.end = function() {
    switch (this.state) {
      case END_STATE:
        this.resolve(this.returnValue);
        break;
      case RETHROW_STATE:
        this.reject(this.storedException);
        break;
      default:
        this.reject(getInternalError(this.state));
    }
  };
  AsyncFunctionContext.prototype.handleException = function() {
    this.state = RETHROW_STATE;
  };
  function asyncWrap(innerFunction, self) {
    var moveNext = getMoveNext(innerFunction, self);
    var ctx = new AsyncFunctionContext();
    ctx.createCallback = function(newState) {
      return function(value) {
        ctx.state = newState;
        ctx.value = value;
        moveNext(ctx);
      };
    };
    ctx.errback = function(err) {
      handleCatch(ctx, err);
      moveNext(ctx);
    };
    moveNext(ctx);
    return ctx.result;
  }
  function getMoveNext(innerFunction, self) {
    return function(ctx) {
      while (true) {
        try {
          return innerFunction.call(self, ctx);
        } catch (ex) {
          handleCatch(ctx, ex);
        }
      }
    };
  }
  function handleCatch(ctx, ex) {
    ctx.storedException = ex;
    var last = ctx.tryStack_[ctx.tryStack_.length - 1];
    if (!last) {
      ctx.handleException(ex);
      return;
    }
    ctx.state = last.catch !== undefined ? last.catch : last.finally;
    if (last.finallyFallThrough !== undefined)
      ctx.finallyFallThrough = last.finallyFallThrough;
  }
  return {
    get createGeneratorInstance() {
      return createGeneratorInstance;
    },
    get initGeneratorFunction() {
      return initGeneratorFunction;
    },
    get asyncWrap() {
      return asyncWrap;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/asyncWrap.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.asyncWrap;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/initGeneratorFunction.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.initGeneratorFunction;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js";
  var $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__ = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/modules/createGeneratorInstance.js"));
  return {get default() {
      return $__traceur_45_runtime_64_0_46_0_46_111_47_src_47_runtime_47_modules_47_generators_46_js__.createGeneratorInstance;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/generators.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/generators.js";
  var asyncWrap = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/asyncWrap.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  var initGeneratorFunction = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/initGeneratorFunction.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  var createGeneratorInstance = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/createGeneratorInstance.js", "traceur-runtime@0.0.111/src/runtime/generators.js")).default;
  $traceurRuntime.asyncWrap = asyncWrap;
  $traceurRuntime.initGeneratorFunction = initGeneratorFunction;
  $traceurRuntime.createGeneratorInstance = createGeneratorInstance;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spawn.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spawn.js";
  function spawn(self, args, gen) {
    return new Promise(function(resolve, reject) {
      function fulfill(v) {
        try {
          step(gen.next(v));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(v) {
        try {
          step(gen.throw(v));
        } catch (e) {
          reject(e);
        }
      }
      function step(res) {
        if (res.done) {
          resolve(res.value);
        } else {
          Promise.resolve(res.value).then(fulfill, rejected);
        }
      }
      step((gen = gen.apply(self, args)).next());
    });
  }
  return {get default() {
      return spawn;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/spawn.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/spawn.js";
  var spawn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spawn.js", "traceur-runtime@0.0.111/src/runtime/spawn.js")).default;
  $traceurRuntime.spawn = spawn;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/getTemplateObject.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/getTemplateObject.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      freeze = $__1.freeze;
  var slice = Array.prototype.slice;
  var map = Object.create(null);
  function getTemplateObject(raw) {
    var cooked = arguments[1];
    var key = raw.join('${}');
    var templateObject = map[key];
    if (templateObject)
      return templateObject;
    if (!cooked) {
      cooked = slice.call(raw);
    }
    return map[key] = freeze(defineProperty(cooked, 'raw', {value: freeze(raw)}));
  }
  return {get default() {
      return getTemplateObject;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/template.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/template.js";
  var getTemplateObject = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/getTemplateObject.js", "traceur-runtime@0.0.111/src/runtime/template.js")).default;
  $traceurRuntime.getTemplateObject = getTemplateObject;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/modules/spreadProperties.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/modules/spreadProperties.js";
  var $__1 = Object,
      defineProperty = $__1.defineProperty,
      getOwnPropertyNames = $__1.getOwnPropertyNames,
      getOwnPropertySymbols = $__1.getOwnPropertySymbols,
      propertyIsEnumerable = $__1.propertyIsEnumerable;
  function createDataProperty(o, p, v) {
    defineProperty(o, p, {
      configurable: true,
      enumerable: true,
      value: v,
      writable: true
    });
  }
  function copyDataProperties(target, source) {
    if (source == null) {
      return;
    }
    var copy = function(keys) {
      for (var i = 0; i < keys.length; i++) {
        var nextKey = keys[i];
        if (propertyIsEnumerable.call(source, nextKey)) {
          var propValue = source[nextKey];
          createDataProperty(target, nextKey, propValue);
        }
      }
    };
    copy(getOwnPropertyNames(source));
    copy(getOwnPropertySymbols(source));
  }
  var $__default = function() {
    var target = arguments[0];
    for (var i = 1; i < arguments.length; i++) {
      copyDataProperties(target, arguments[i]);
    }
    return target;
  };
  return {get default() {
      return $__default;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/jsx.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/jsx.js";
  var spreadProperties = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./modules/spreadProperties.js", "traceur-runtime@0.0.111/src/runtime/jsx.js")).default;
  $traceurRuntime.spreadProperties = spreadProperties;
  return {};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/runtime-modules.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/runtime-modules.js";
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./symbols.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./classes.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./exportStar.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./properTailCalls.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./relativeRequire.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./spread.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./destructuring.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./async.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./generators.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./spawn.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./template.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./jsx.js", "traceur-runtime@0.0.111/src/runtime/runtime-modules.js"));
  return {};
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/runtime-modules.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/frozen-data.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/frozen-data.js";
  function findIndex(arr, key) {
    for (var i = 0; i < arr.length; i += 2) {
      if (arr[i] === key) {
        return i;
      }
    }
    return -1;
  }
  function setFrozen(arr, key, val) {
    var i = findIndex(arr, key);
    if (i === -1) {
      arr.push(key, val);
    }
  }
  function getFrozen(arr, key) {
    var i = findIndex(arr, key);
    if (i !== -1) {
      return arr[i + 1];
    }
    return undefined;
  }
  function hasFrozen(arr, key) {
    return findIndex(arr, key) !== -1;
  }
  function deleteFrozen(arr, key) {
    var i = findIndex(arr, key);
    if (i !== -1) {
      arr.splice(i, 2);
      return true;
    }
    return false;
  }
  return {
    get setFrozen() {
      return setFrozen;
    },
    get getFrozen() {
      return getFrozen;
    },
    get hasFrozen() {
      return hasFrozen;
    },
    get deleteFrozen() {
      return deleteFrozen;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/utils.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/utils.js";
  var $ceil = Math.ceil;
  var $floor = Math.floor;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $pow = Math.pow;
  var $min = Math.min;
  var $TypeError = TypeError;
  var $Object = Object;
  function toObject(x) {
    if (x == null) {
      throw $TypeError();
    }
    return $Object(x);
  }
  function toUint32(x) {
    return x >>> 0;
  }
  function isObject(x) {
    return x && (typeof x === 'object' || typeof x === 'function');
  }
  function isCallable(x) {
    return typeof x === 'function';
  }
  function isNumber(x) {
    return typeof x === 'number';
  }
  function toInteger(x) {
    x = +x;
    if ($isNaN(x))
      return 0;
    if (x === 0 || !$isFinite(x))
      return x;
    return x > 0 ? $floor(x) : $ceil(x);
  }
  var MAX_SAFE_LENGTH = $pow(2, 53) - 1;
  function toLength(x) {
    var len = toInteger(x);
    return len < 0 ? 0 : $min(len, MAX_SAFE_LENGTH);
  }
  function checkIterable(x) {
    return !isObject(x) ? undefined : x[Symbol.iterator];
  }
  function isConstructor(x) {
    return isCallable(x);
  }
  function createIteratorResultObject(value, done) {
    return {
      value: value,
      done: done
    };
  }
  function maybeDefine(object, name, descr) {
    if (!(name in object)) {
      Object.defineProperty(object, name, descr);
    }
  }
  function maybeDefineMethod(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  function maybeDefineConst(object, name, value) {
    maybeDefine(object, name, {
      value: value,
      configurable: false,
      enumerable: false,
      writable: false
    });
  }
  function maybeAddFunctions(object, functions) {
    for (var i = 0; i < functions.length; i += 2) {
      var name = functions[i];
      var value = functions[i + 1];
      maybeDefineMethod(object, name, value);
    }
  }
  function maybeAddConsts(object, consts) {
    for (var i = 0; i < consts.length; i += 2) {
      var name = consts[i];
      var value = consts[i + 1];
      maybeDefineConst(object, name, value);
    }
  }
  function maybeAddIterator(object, func, Symbol) {
    if (!Symbol || !Symbol.iterator || object[Symbol.iterator])
      return;
    if (object['@@iterator'])
      func = object['@@iterator'];
    Object.defineProperty(object, Symbol.iterator, {
      value: func,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  var polyfills = [];
  function registerPolyfill(func) {
    polyfills.push(func);
  }
  function polyfillAll(global) {
    polyfills.forEach(function(f) {
      return f(global);
    });
  }
  return {
    get toObject() {
      return toObject;
    },
    get toUint32() {
      return toUint32;
    },
    get isObject() {
      return isObject;
    },
    get isCallable() {
      return isCallable;
    },
    get isNumber() {
      return isNumber;
    },
    get toInteger() {
      return toInteger;
    },
    get toLength() {
      return toLength;
    },
    get checkIterable() {
      return checkIterable;
    },
    get isConstructor() {
      return isConstructor;
    },
    get createIteratorResultObject() {
      return createIteratorResultObject;
    },
    get maybeDefine() {
      return maybeDefine;
    },
    get maybeDefineMethod() {
      return maybeDefineMethod;
    },
    get maybeDefineConst() {
      return maybeDefineConst;
    },
    get maybeAddFunctions() {
      return maybeAddFunctions;
    },
    get maybeAddConsts() {
      return maybeAddConsts;
    },
    get maybeAddIterator() {
      return maybeAddIterator;
    },
    get registerPolyfill() {
      return registerPolyfill;
    },
    get polyfillAll() {
      return polyfillAll;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Map.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js";
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      createPrivateSymbol = $__16.createPrivateSymbol,
      getPrivate = $__16.getPrivate,
      setPrivate = $__16.setPrivate;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      deleteFrozen = $__17.deleteFrozen,
      getFrozen = $__17.getFrozen,
      setFrozen = $__17.setFrozen;
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")),
      isObject = $__18.isObject,
      registerPolyfill = $__18.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Map.js")).default;
  var $__9 = Object,
      defineProperty = $__9.defineProperty,
      getOwnPropertyDescriptor = $__9.getOwnPropertyDescriptor,
      hasOwnProperty = $__9.hasOwnProperty,
      isExtensible = $__9.isExtensible;
  var deletedSentinel = {};
  var counter = 1;
  var hashCodeName = createPrivateSymbol();
  function getHashCodeForObject(obj) {
    return getPrivate(obj, hashCodeName);
  }
  function getOrSetHashCodeForObject(obj) {
    var hash = getHashCodeForObject(obj);
    if (!hash) {
      hash = counter++;
      setPrivate(obj, hashCodeName, hash);
    }
    return hash;
  }
  function lookupIndex(map, key) {
    if (typeof key === 'string') {
      return map.stringIndex_[key];
    }
    if (isObject(key)) {
      if (!isExtensible(key)) {
        return getFrozen(map.frozenData_, key);
      }
      var hc = getHashCodeForObject(key);
      if (hc === undefined) {
        return undefined;
      }
      return map.objectIndex_[hc];
    }
    return map.primitiveIndex_[key];
  }
  function initMap(map) {
    map.entries_ = [];
    map.objectIndex_ = Object.create(null);
    map.stringIndex_ = Object.create(null);
    map.primitiveIndex_ = Object.create(null);
    map.frozenData_ = [];
    map.deletedCount_ = 0;
  }
  var Map = function() {
    function Map() {
      var $__11,
          $__12;
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Map called on incompatible type');
      if (hasOwnProperty.call(this, 'entries_')) {
        throw new TypeError('Map can not be reentrantly initialised');
      }
      initMap(this);
      if (iterable !== null && iterable !== undefined) {
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (iterable)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__10 = $__3.value,
                key = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
                value = ($__12 = $__11.next()).done ? void 0 : $__12.value;
            {
              this.set(key, value);
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Map, {
      get size() {
        return this.entries_.length / 2 - this.deletedCount_;
      },
      get: function(key) {
        var index = lookupIndex(this, key);
        if (index !== undefined) {
          return this.entries_[index + 1];
        }
      },
      set: function(key, value) {
        var index = lookupIndex(this, key);
        if (index !== undefined) {
          this.entries_[index + 1] = value;
        } else {
          index = this.entries_.length;
          this.entries_[index] = key;
          this.entries_[index + 1] = value;
          if (isObject(key)) {
            if (!isExtensible(key)) {
              setFrozen(this.frozenData_, key, index);
            } else {
              var hash = getOrSetHashCodeForObject(key);
              this.objectIndex_[hash] = index;
            }
          } else if (typeof key === 'string') {
            this.stringIndex_[key] = index;
          } else {
            this.primitiveIndex_[key] = index;
          }
        }
        return this;
      },
      has: function(key) {
        return lookupIndex(this, key) !== undefined;
      },
      delete: function(key) {
        var index = lookupIndex(this, key);
        if (index === undefined) {
          return false;
        }
        this.entries_[index] = deletedSentinel;
        this.entries_[index + 1] = undefined;
        this.deletedCount_++;
        if (isObject(key)) {
          if (!isExtensible(key)) {
            deleteFrozen(this.frozenData_, key);
          } else {
            var hash = getHashCodeForObject(key);
            delete this.objectIndex_[hash];
          }
        } else if (typeof key === 'string') {
          delete this.stringIndex_[key];
        } else {
          delete this.primitiveIndex_[key];
        }
        return true;
      },
      clear: function() {
        initMap(this);
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        for (var i = 0; i < this.entries_.length; i += 2) {
          var key = this.entries_[i];
          var value = this.entries_[i + 1];
          if (key === deletedSentinel)
            continue;
          callbackFn.call(thisArg, value, key, this);
        }
      },
      entries: $traceurRuntime.initGeneratorFunction(function $__13() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return [key, value];
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__13, this);
      }),
      keys: $traceurRuntime.initGeneratorFunction(function $__14() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return key;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__14, this);
      }),
      values: $traceurRuntime.initGeneratorFunction(function $__15() {
        var i,
            key,
            value;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                i = 0;
                $ctx.state = 12;
                break;
              case 12:
                $ctx.state = (i < this.entries_.length) ? 8 : -2;
                break;
              case 4:
                i += 2;
                $ctx.state = 12;
                break;
              case 8:
                key = this.entries_[i];
                value = this.entries_[i + 1];
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = (key === deletedSentinel) ? 4 : 6;
                break;
              case 6:
                $ctx.state = 2;
                return value;
              case 2:
                $ctx.maybeThrow();
                $ctx.state = 4;
                break;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      })
    }, {});
  }();
  defineProperty(Map.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Map.prototype.entries
  });
  function needsPolyfill(global) {
    var $__10 = global,
        Map = $__10.Map,
        Symbol = $__10.Symbol;
    if (!Map || !hasNativeSymbol() || !Map.prototype[Symbol.iterator] || !Map.prototype.entries) {
      return true;
    }
    try {
      return new Map([[]]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillMap(global) {
    if (needsPolyfill(global)) {
      global.Map = Map;
    }
  }
  registerPolyfill(polyfillMap);
  return {
    get Map() {
      return Map;
    },
    get polyfillMap() {
      return polyfillMap;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Map.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Set.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js";
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")),
      isObject = $__18.isObject,
      registerPolyfill = $__18.registerPolyfill;
  var Map = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./Map.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")).Map;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Set.js")).default;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var Set = function() {
    function Set() {
      var iterable = arguments[0];
      if (!isObject(this))
        throw new TypeError('Set called on incompatible type');
      if (hasOwnProperty.call(this, 'map_')) {
        throw new TypeError('Set can not be reentrantly initialised');
      }
      this.map_ = new Map();
      if (iterable !== null && iterable !== undefined) {
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (iterable)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var item = $__4.value;
            {
              this.add(item);
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
      }
    }
    return ($traceurRuntime.createClass)(Set, {
      get size() {
        return this.map_.size;
      },
      has: function(key) {
        return this.map_.has(key);
      },
      add: function(key) {
        this.map_.set(key, key);
        return this;
      },
      delete: function(key) {
        return this.map_.delete(key);
      },
      clear: function() {
        return this.map_.clear();
      },
      forEach: function(callbackFn) {
        var thisArg = arguments[1];
        var $__2 = this;
        return this.map_.forEach(function(value, key) {
          callbackFn.call(thisArg, key, key, $__2);
        });
      },
      values: $traceurRuntime.initGeneratorFunction(function $__12() {
        var $__13,
            $__14;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__13 = $ctx.wrapYieldStar(this.map_.keys()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__14 = $__13[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__14.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__14.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__14.value;
              default:
                return $ctx.end();
            }
        }, $__12, this);
      }),
      entries: $traceurRuntime.initGeneratorFunction(function $__15() {
        var $__16,
            $__17;
        return $traceurRuntime.createGeneratorInstance(function($ctx) {
          while (true)
            switch ($ctx.state) {
              case 0:
                $__16 = $ctx.wrapYieldStar(this.map_.entries()[Symbol.iterator]());
                $ctx.sent = void 0;
                $ctx.action = 'next';
                $ctx.state = 12;
                break;
              case 12:
                $__17 = $__16[$ctx.action]($ctx.sentIgnoreThrow);
                $ctx.state = 9;
                break;
              case 9:
                $ctx.state = ($__17.done) ? 3 : 2;
                break;
              case 3:
                $ctx.sent = $__17.value;
                $ctx.state = -2;
                break;
              case 2:
                $ctx.state = 12;
                return $__17.value;
              default:
                return $ctx.end();
            }
        }, $__15, this);
      })
    }, {});
  }();
  Object.defineProperty(Set.prototype, Symbol.iterator, {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  Object.defineProperty(Set.prototype, 'keys', {
    configurable: true,
    writable: true,
    value: Set.prototype.values
  });
  function needsPolyfill(global) {
    var $__11 = global,
        Set = $__11.Set,
        Symbol = $__11.Symbol;
    if (!Set || !hasNativeSymbol() || !Set.prototype[Symbol.iterator] || !Set.prototype.values) {
      return true;
    }
    try {
      return new Set([1]).size !== 1;
    } catch (e) {
      return false;
    }
  }
  function polyfillSet(global) {
    if (needsPolyfill(global)) {
      global.Set = Set;
    }
  }
  registerPolyfill(polyfillSet);
  return {
    get Set() {
      return Set;
    },
    get polyfillSet() {
      return polyfillSet;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Set.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/node_modules/rsvp/lib/rsvp/asap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/node_modules/rsvp/lib/rsvp/asap.js";
  var len = 0;
  var toString = {}.toString;
  var vertxNext;
  function asap(callback, arg) {
    queue[len] = callback;
    queue[len + 1] = arg;
    len += 2;
    if (len === 2) {
      scheduleFlush();
    }
  }
  var browserWindow = (typeof window !== 'undefined') ? window : undefined;
  var browserGlobal = browserWindow || {};
  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';
  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
  function useNextTick() {
    var nextTick = process.nextTick;
    var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
    if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
      nextTick = setImmediate;
    }
    return function() {
      nextTick(flush);
    };
  }
  function useVertxTimer() {
    return function() {
      vertxNext(flush);
    };
  }
  function useMutationObserver() {
    var iterations = 0;
    var observer = new BrowserMutationObserver(flush);
    var node = document.createTextNode('');
    observer.observe(node, {characterData: true});
    return function() {
      node.data = (iterations = ++iterations % 2);
    };
  }
  function useMessageChannel() {
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    return function() {
      channel.port2.postMessage(0);
    };
  }
  function useSetTimeout() {
    return function() {
      setTimeout(flush, 1);
    };
  }
  var queue = new Array(1000);
  function flush() {
    for (var i = 0; i < len; i += 2) {
      var callback = queue[i];
      var arg = queue[i + 1];
      callback(arg);
      queue[i] = undefined;
      queue[i + 1] = undefined;
    }
    len = 0;
  }
  function attemptVertex() {
    try {
      var r = require;
      var vertx = r('vertx');
      vertxNext = vertx.runOnLoop || vertx.runOnContext;
      return useVertxTimer();
    } catch (e) {
      return useSetTimeout();
    }
  }
  var scheduleFlush;
  if (isNode) {
    scheduleFlush = useNextTick();
  } else if (BrowserMutationObserver) {
    scheduleFlush = useMutationObserver();
  } else if (isWorker) {
    scheduleFlush = useMessageChannel();
  } else if (browserWindow === undefined && typeof require === 'function') {
    scheduleFlush = attemptVertex();
  } else {
    scheduleFlush = useSetTimeout();
  }
  return {get default() {
      return asap;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js";
  var async = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../../../node_modules/rsvp/lib/rsvp/asap.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")).default;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")),
      isObject = $__9.isObject,
      registerPolyfill = $__9.registerPolyfill;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js")),
      createPrivateSymbol = $__10.createPrivateSymbol,
      getPrivate = $__10.getPrivate,
      setPrivate = $__10.setPrivate;
  var promiseRaw = {};
  function isPromise(x) {
    return x && typeof x === 'object' && x.status_ !== undefined;
  }
  function idResolveHandler(x) {
    return x;
  }
  function idRejectHandler(x) {
    throw x;
  }
  function chain(promise) {
    var onResolve = arguments[1] !== (void 0) ? arguments[1] : idResolveHandler;
    var onReject = arguments[2] !== (void 0) ? arguments[2] : idRejectHandler;
    var deferred = getDeferred(promise.constructor);
    switch (promise.status_) {
      case undefined:
        throw TypeError;
      case 0:
        promise.onResolve_.push(onResolve, deferred);
        promise.onReject_.push(onReject, deferred);
        break;
      case +1:
        promiseEnqueue(promise.value_, [onResolve, deferred]);
        break;
      case -1:
        promiseEnqueue(promise.value_, [onReject, deferred]);
        break;
    }
    return deferred.promise;
  }
  function getDeferred(C) {
    if (this === $Promise) {
      var promise = promiseInit(new $Promise(promiseRaw));
      return {
        promise: promise,
        resolve: function(x) {
          promiseResolve(promise, x);
        },
        reject: function(r) {
          promiseReject(promise, r);
        }
      };
    } else {
      var result = {};
      result.promise = new C(function(resolve, reject) {
        result.resolve = resolve;
        result.reject = reject;
      });
      return result;
    }
  }
  function promiseSet(promise, status, value, onResolve, onReject) {
    promise.status_ = status;
    promise.value_ = value;
    promise.onResolve_ = onResolve;
    promise.onReject_ = onReject;
    return promise;
  }
  function promiseInit(promise) {
    return promiseSet(promise, 0, undefined, [], []);
  }
  var Promise = function() {
    function Promise(resolver) {
      if (resolver === promiseRaw)
        return;
      if (typeof resolver !== 'function')
        throw new TypeError;
      var promise = promiseInit(this);
      try {
        resolver(function(x) {
          promiseResolve(promise, x);
        }, function(r) {
          promiseReject(promise, r);
        });
      } catch (e) {
        promiseReject(promise, e);
      }
    }
    return ($traceurRuntime.createClass)(Promise, {
      catch: function(onReject) {
        return this.then(undefined, onReject);
      },
      then: function(onResolve, onReject) {
        if (typeof onResolve !== 'function')
          onResolve = idResolveHandler;
        if (typeof onReject !== 'function')
          onReject = idRejectHandler;
        var that = this;
        var constructor = this.constructor;
        return chain(this, function(x) {
          x = promiseCoerce(constructor, x);
          return x === that ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);
        }, onReject);
      }
    }, {
      resolve: function(x) {
        if (this === $Promise) {
          if (isPromise(x)) {
            return x;
          }
          return promiseSet(new $Promise(promiseRaw), +1, x);
        } else {
          return new this(function(resolve, reject) {
            resolve(x);
          });
        }
      },
      reject: function(r) {
        if (this === $Promise) {
          return promiseSet(new $Promise(promiseRaw), -1, r);
        } else {
          return new this(function(resolve, reject) {
            reject(r);
          });
        }
      },
      all: function(values) {
        var deferred = getDeferred(this);
        var resolutions = [];
        try {
          var makeCountdownFunction = function(i) {
            return function(x) {
              resolutions[i] = x;
              if (--count === 0)
                deferred.resolve(resolutions);
            };
          };
          var count = 0;
          var i = 0;
          var $__4 = true;
          var $__5 = false;
          var $__6 = undefined;
          try {
            for (var $__2 = void 0,
                $__1 = (values)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
              var value = $__2.value;
              {
                var countdownFunction = makeCountdownFunction(i);
                this.resolve(value).then(countdownFunction, function(r) {
                  deferred.reject(r);
                });
                ++i;
                ++count;
              }
            }
          } catch ($__7) {
            $__5 = true;
            $__6 = $__7;
          } finally {
            try {
              if (!$__4 && $__1.return != null) {
                $__1.return();
              }
            } finally {
              if ($__5) {
                throw $__6;
              }
            }
          }
          if (count === 0) {
            deferred.resolve(resolutions);
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      },
      race: function(values) {
        var deferred = getDeferred(this);
        try {
          for (var i = 0; i < values.length; i++) {
            this.resolve(values[i]).then(function(x) {
              deferred.resolve(x);
            }, function(r) {
              deferred.reject(r);
            });
          }
        } catch (e) {
          deferred.reject(e);
        }
        return deferred.promise;
      }
    });
  }();
  var $Promise = Promise;
  var $PromiseReject = $Promise.reject;
  function promiseResolve(promise, x) {
    promiseDone(promise, +1, x, promise.onResolve_);
  }
  function promiseReject(promise, r) {
    promiseDone(promise, -1, r, promise.onReject_);
  }
  function promiseDone(promise, status, value, reactions) {
    if (promise.status_ !== 0)
      return;
    promiseEnqueue(value, reactions);
    promiseSet(promise, status, value);
  }
  function promiseEnqueue(value, tasks) {
    async(function() {
      for (var i = 0; i < tasks.length; i += 2) {
        promiseHandle(value, tasks[i], tasks[i + 1]);
      }
    });
  }
  function promiseHandle(value, handler, deferred) {
    try {
      var result = handler(value);
      if (result === deferred.promise)
        throw new TypeError;
      else if (isPromise(result))
        chain(result, deferred.resolve, deferred.reject);
      else
        deferred.resolve(result);
    } catch (e) {
      try {
        deferred.reject(e);
      } catch (e) {}
    }
  }
  var thenableSymbol = createPrivateSymbol();
  function promiseCoerce(constructor, x) {
    if (!isPromise(x) && isObject(x)) {
      var then;
      try {
        then = x.then;
      } catch (r) {
        var promise = $PromiseReject.call(constructor, r);
        setPrivate(x, thenableSymbol, promise);
        return promise;
      }
      if (typeof then === 'function') {
        var p = getPrivate(x, thenableSymbol);
        if (p) {
          return p;
        } else {
          var deferred = getDeferred(constructor);
          setPrivate(x, thenableSymbol, deferred.promise);
          try {
            then.call(x, deferred.resolve, deferred.reject);
          } catch (r) {
            deferred.reject(r);
          }
          return deferred.promise;
        }
      }
    }
    return x;
  }
  function polyfillPromise(global) {
    if (!global.Promise)
      global.Promise = Promise;
  }
  registerPolyfill(polyfillPromise);
  return {
    get Promise() {
      return Promise;
    },
    get polyfillPromise() {
      return polyfillPromise;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Promise.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js";
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/StringIterator.js")),
      createIteratorResultObject = $__3.createIteratorResultObject,
      isObject = $__3.isObject;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var iteratedString = Symbol('iteratedString');
  var stringIteratorNextIndex = Symbol('stringIteratorNextIndex');
  var StringIterator = function() {
    var $__1;
    function StringIterator() {}
    return ($traceurRuntime.createClass)(StringIterator, ($__1 = {}, Object.defineProperty($__1, "next", {
      value: function() {
        var o = this;
        if (!isObject(o) || !hasOwnProperty.call(o, iteratedString)) {
          throw new TypeError('this must be a StringIterator object');
        }
        var s = o[iteratedString];
        if (s === undefined) {
          return createIteratorResultObject(undefined, true);
        }
        var position = o[stringIteratorNextIndex];
        var len = s.length;
        if (position >= len) {
          o[iteratedString] = undefined;
          return createIteratorResultObject(undefined, true);
        }
        var first = s.charCodeAt(position);
        var resultString;
        if (first < 0xD800 || first > 0xDBFF || position + 1 === len) {
          resultString = String.fromCharCode(first);
        } else {
          var second = s.charCodeAt(position + 1);
          if (second < 0xDC00 || second > 0xDFFF) {
            resultString = String.fromCharCode(first);
          } else {
            resultString = String.fromCharCode(first) + String.fromCharCode(second);
          }
        }
        o[stringIteratorNextIndex] = position + resultString.length;
        return createIteratorResultObject(resultString, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1), {});
  }();
  function createStringIterator(string) {
    var s = String(string);
    var iterator = Object.create(StringIterator.prototype);
    iterator[iteratedString] = s;
    iterator[stringIteratorNextIndex] = 0;
    return iterator;
  }
  return {get createStringIterator() {
      return createStringIterator;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/String.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/String.js";
  var checkObjectCoercible = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../checkObjectCoercible.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")).default;
  var createStringIterator = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./StringIterator.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")).createStringIterator;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/String.js")),
      maybeAddFunctions = $__3.maybeAddFunctions,
      maybeAddIterator = $__3.maybeAddIterator,
      registerPolyfill = $__3.registerPolyfill;
  var $toString = Object.prototype.toString;
  var $indexOf = String.prototype.indexOf;
  var $lastIndexOf = String.prototype.lastIndexOf;
  function startsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (isNaN(pos)) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    return $indexOf.call(string, searchString, pos) == start;
  }
  function endsWith(search) {
    var string = String(this);
    if (this == null || $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var pos = stringLength;
    if (arguments.length > 1) {
      var position = arguments[1];
      if (position !== undefined) {
        pos = position ? Number(position) : 0;
        if (isNaN(pos)) {
          pos = 0;
        }
      }
    }
    var end = Math.min(Math.max(pos, 0), stringLength);
    var start = end - searchLength;
    if (start < 0) {
      return false;
    }
    return $lastIndexOf.call(string, searchString, start) == start;
  }
  function includes(search) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    if (search && $toString.call(search) == '[object RegExp]') {
      throw TypeError();
    }
    var stringLength = string.length;
    var searchString = String(search);
    var searchLength = searchString.length;
    var position = arguments.length > 1 ? arguments[1] : undefined;
    var pos = position ? Number(position) : 0;
    if (pos != pos) {
      pos = 0;
    }
    var start = Math.min(Math.max(pos, 0), stringLength);
    if (searchLength + start > stringLength) {
      return false;
    }
    return $indexOf.call(string, searchString, pos) != -1;
  }
  function repeat(count) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var n = count ? Number(count) : 0;
    if (isNaN(n)) {
      n = 0;
    }
    if (n < 0 || n == Infinity) {
      throw RangeError();
    }
    if (n == 0) {
      return '';
    }
    var result = '';
    while (n--) {
      result += string;
    }
    return result;
  }
  function codePointAt(position) {
    if (this == null) {
      throw TypeError();
    }
    var string = String(this);
    var size = string.length;
    var index = position ? Number(position) : 0;
    if (isNaN(index)) {
      index = 0;
    }
    if (index < 0 || index >= size) {
      return undefined;
    }
    var first = string.charCodeAt(index);
    var second;
    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {
      second = string.charCodeAt(index + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }
  function raw(callsite) {
    var raw = callsite.raw;
    var len = raw.length >>> 0;
    if (len === 0)
      return '';
    var s = '';
    var i = 0;
    while (true) {
      s += raw[i];
      if (i + 1 === len)
        return s;
      s += arguments[++i];
    }
  }
  function fromCodePoint(_) {
    var codeUnits = [];
    var floor = Math.floor;
    var highSurrogate;
    var lowSurrogate;
    var index = -1;
    var length = arguments.length;
    if (!length) {
      return '';
    }
    while (++index < length) {
      var codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
        throw RangeError('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 0xFFFF) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 0x10000;
        highSurrogate = (codePoint >> 10) + 0xD800;
        lowSurrogate = (codePoint % 0x400) + 0xDC00;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
    }
    return String.fromCharCode.apply(null, codeUnits);
  }
  function stringPrototypeIterator() {
    var o = checkObjectCoercible(this);
    var s = String(o);
    return createStringIterator(s);
  }
  function polyfillString(global) {
    var String = global.String;
    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'endsWith', endsWith, 'includes', includes, 'repeat', repeat, 'startsWith', startsWith]);
    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);
    maybeAddIterator(String.prototype, stringPrototypeIterator, Symbol);
  }
  registerPolyfill(polyfillString);
  return {
    get startsWith() {
      return startsWith;
    },
    get endsWith() {
      return endsWith;
    },
    get includes() {
      return includes;
    },
    get repeat() {
      return repeat;
    },
    get codePointAt() {
      return codePointAt;
    },
    get raw() {
      return raw;
    },
    get fromCodePoint() {
      return fromCodePoint;
    },
    get stringPrototypeIterator() {
      return stringPrototypeIterator;
    },
    get polyfillString() {
      return polyfillString;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/String.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/ArrayIterator.js")),
      toObject = $__2.toObject,
      toUint32 = $__2.toUint32,
      createIteratorResultObject = $__2.createIteratorResultObject;
  var ARRAY_ITERATOR_KIND_KEYS = 1;
  var ARRAY_ITERATOR_KIND_VALUES = 2;
  var ARRAY_ITERATOR_KIND_ENTRIES = 3;
  var ArrayIterator = function() {
    var $__1;
    function ArrayIterator() {}
    return ($traceurRuntime.createClass)(ArrayIterator, ($__1 = {}, Object.defineProperty($__1, "next", {
      value: function() {
        var iterator = toObject(this);
        var array = iterator.iteratorObject_;
        if (!array) {
          throw new TypeError('Object is not an ArrayIterator');
        }
        var index = iterator.arrayIteratorNextIndex_;
        var itemKind = iterator.arrayIterationKind_;
        var length = toUint32(array.length);
        if (index >= length) {
          iterator.arrayIteratorNextIndex_ = Infinity;
          return createIteratorResultObject(undefined, true);
        }
        iterator.arrayIteratorNextIndex_ = index + 1;
        if (itemKind == ARRAY_ITERATOR_KIND_VALUES)
          return createIteratorResultObject(array[index], false);
        if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)
          return createIteratorResultObject([index, array[index]], false);
        return createIteratorResultObject(index, false);
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, Symbol.iterator, {
      value: function() {
        return this;
      },
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1), {});
  }();
  function createArrayIterator(array, kind) {
    var object = toObject(array);
    var iterator = new ArrayIterator;
    iterator.iteratorObject_ = object;
    iterator.arrayIteratorNextIndex_ = 0;
    iterator.arrayIterationKind_ = kind;
    return iterator;
  }
  function entries() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);
  }
  function keys() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);
  }
  function values() {
    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);
  }
  return {
    get entries() {
      return entries;
    },
    get keys() {
      return keys;
    },
    get values() {
      return values;
    }
  };
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Array.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js";
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./ArrayIterator.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js")),
      entries = $__9.entries,
      keys = $__9.keys,
      jsValues = $__9.values;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Array.js")),
      checkIterable = $__10.checkIterable,
      isCallable = $__10.isCallable,
      isConstructor = $__10.isConstructor,
      maybeAddFunctions = $__10.maybeAddFunctions,
      maybeAddIterator = $__10.maybeAddIterator,
      registerPolyfill = $__10.registerPolyfill,
      toInteger = $__10.toInteger,
      toLength = $__10.toLength,
      toObject = $__10.toObject;
  function from(arrLike) {
    var mapFn = arguments[1];
    var thisArg = arguments[2];
    var C = this;
    var items = toObject(arrLike);
    var mapping = mapFn !== undefined;
    var k = 0;
    var arr,
        len;
    if (mapping && !isCallable(mapFn)) {
      throw TypeError();
    }
    if (checkIterable(items)) {
      arr = isConstructor(C) ? new C() : [];
      var $__3 = true;
      var $__4 = false;
      var $__5 = undefined;
      try {
        for (var $__1 = void 0,
            $__0 = (items)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
          var item = $__1.value;
          {
            if (mapping) {
              arr[k] = mapFn.call(thisArg, item, k);
            } else {
              arr[k] = item;
            }
            k++;
          }
        }
      } catch ($__6) {
        $__4 = true;
        $__5 = $__6;
      } finally {
        try {
          if (!$__3 && $__0.return != null) {
            $__0.return();
          }
        } finally {
          if ($__4) {
            throw $__5;
          }
        }
      }
      arr.length = k;
      return arr;
    }
    len = toLength(items.length);
    arr = isConstructor(C) ? new C(len) : new Array(len);
    for (; k < len; k++) {
      if (mapping) {
        arr[k] = typeof thisArg === 'undefined' ? mapFn(items[k], k) : mapFn.call(thisArg, items[k], k);
      } else {
        arr[k] = items[k];
      }
    }
    arr.length = len;
    return arr;
  }
  function of() {
    for (var items = [],
        $__7 = 0; $__7 < arguments.length; $__7++)
      items[$__7] = arguments[$__7];
    var C = this;
    var len = items.length;
    var arr = isConstructor(C) ? new C(len) : new Array(len);
    for (var k = 0; k < len; k++) {
      arr[k] = items[k];
    }
    arr.length = len;
    return arr;
  }
  function fill(value) {
    var start = arguments[1] !== (void 0) ? arguments[1] : 0;
    var end = arguments[2];
    var object = toObject(this);
    var len = toLength(object.length);
    var fillStart = toInteger(start);
    var fillEnd = end !== undefined ? toInteger(end) : len;
    fillStart = fillStart < 0 ? Math.max(len + fillStart, 0) : Math.min(fillStart, len);
    fillEnd = fillEnd < 0 ? Math.max(len + fillEnd, 0) : Math.min(fillEnd, len);
    while (fillStart < fillEnd) {
      object[fillStart] = value;
      fillStart++;
    }
    return object;
  }
  function find(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg);
  }
  function findIndex(predicate) {
    var thisArg = arguments[1];
    return findHelper(this, predicate, thisArg, true);
  }
  function findHelper(self, predicate) {
    var thisArg = arguments[2];
    var returnIndex = arguments[3] !== (void 0) ? arguments[3] : false;
    var object = toObject(self);
    var len = toLength(object.length);
    if (!isCallable(predicate)) {
      throw TypeError();
    }
    for (var i = 0; i < len; i++) {
      var value = object[i];
      if (predicate.call(thisArg, value, i, object)) {
        return returnIndex ? i : value;
      }
    }
    return returnIndex ? -1 : undefined;
  }
  function polyfillArray(global) {
    var $__8 = global,
        Array = $__8.Array,
        Object = $__8.Object,
        Symbol = $__8.Symbol;
    var values = jsValues;
    if (Symbol && Symbol.iterator && Array.prototype[Symbol.iterator]) {
      values = Array.prototype[Symbol.iterator];
    }
    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values, 'fill', fill, 'find', find, 'findIndex', findIndex]);
    maybeAddFunctions(Array, ['from', from, 'of', of]);
    maybeAddIterator(Array.prototype, values, Symbol);
    maybeAddIterator(Object.getPrototypeOf([].values()), function() {
      return this;
    }, Symbol);
  }
  registerPolyfill(polyfillArray);
  return {
    get from() {
      return from;
    },
    get of() {
      return of;
    },
    get fill() {
      return fill;
    },
    get find() {
      return find;
    },
    get findIndex() {
      return findIndex;
    },
    get polyfillArray() {
      return polyfillArray;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Array.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/assign.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/assign.js";
  var keys = Object.keys;
  function assign(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      var props = source == null ? [] : keys(source);
      var p = void 0,
          length = props.length;
      for (p = 0; p < length; p++) {
        var name = props[p];
        target[name] = source[name];
      }
    }
    return target;
  }
  return {get default() {
      return assign;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Object.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js")),
      maybeAddFunctions = $__2.maybeAddFunctions,
      registerPolyfill = $__2.registerPolyfill;
  var assign = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./assign.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Object.js")).default;
  var $__0 = Object,
      defineProperty = $__0.defineProperty,
      getOwnPropertyDescriptor = $__0.getOwnPropertyDescriptor,
      getOwnPropertyNames = $__0.getOwnPropertyNames;
  function is(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    return left !== left && right !== right;
  }
  function mixin(target, source) {
    var props = getOwnPropertyNames(source);
    var p,
        descriptor,
        length = props.length;
    for (p = 0; p < length; p++) {
      var name = props[p];
      descriptor = getOwnPropertyDescriptor(source, props[p]);
      defineProperty(target, props[p], descriptor);
    }
    return target;
  }
  function polyfillObject(global) {
    var Object = global.Object;
    maybeAddFunctions(Object, ['assign', assign, 'is', is, 'mixin', mixin]);
  }
  registerPolyfill(polyfillObject);
  return {
    get assign() {
      return assign;
    },
    get is() {
      return is;
    },
    get mixin() {
      return mixin;
    },
    get polyfillObject() {
      return polyfillObject;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Object.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Number.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Number.js";
  var $__1 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Number.js")),
      isNumber = $__1.isNumber,
      maybeAddConsts = $__1.maybeAddConsts,
      maybeAddFunctions = $__1.maybeAddFunctions,
      registerPolyfill = $__1.registerPolyfill,
      toInteger = $__1.toInteger;
  var $abs = Math.abs;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
  var MIN_SAFE_INTEGER = -Math.pow(2, 53) + 1;
  var EPSILON = Math.pow(2, -52);
  function NumberIsFinite(number) {
    return isNumber(number) && $isFinite(number);
  }
  function isInteger(number) {
    return NumberIsFinite(number) && toInteger(number) === number;
  }
  function NumberIsNaN(number) {
    return isNumber(number) && $isNaN(number);
  }
  function isSafeInteger(number) {
    if (NumberIsFinite(number)) {
      var integral = toInteger(number);
      if (integral === number)
        return $abs(integral) <= MAX_SAFE_INTEGER;
    }
    return false;
  }
  function polyfillNumber(global) {
    var Number = global.Number;
    maybeAddConsts(Number, ['MAX_SAFE_INTEGER', MAX_SAFE_INTEGER, 'MIN_SAFE_INTEGER', MIN_SAFE_INTEGER, 'EPSILON', EPSILON]);
    maybeAddFunctions(Number, ['isFinite', NumberIsFinite, 'isInteger', isInteger, 'isNaN', NumberIsNaN, 'isSafeInteger', isSafeInteger]);
  }
  registerPolyfill(polyfillNumber);
  return {
    get MAX_SAFE_INTEGER() {
      return MAX_SAFE_INTEGER;
    },
    get MIN_SAFE_INTEGER() {
      return MIN_SAFE_INTEGER;
    },
    get EPSILON() {
      return EPSILON;
    },
    get isFinite() {
      return NumberIsFinite;
    },
    get isInteger() {
      return isInteger;
    },
    get isNaN() {
      return NumberIsNaN;
    },
    get isSafeInteger() {
      return isSafeInteger;
    },
    get polyfillNumber() {
      return polyfillNumber;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Number.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/fround.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/fround.js";
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__0 = Math,
      LN2 = $__0.LN2,
      abs = $__0.abs,
      floor = $__0.floor,
      log = $__0.log,
      min = $__0.min,
      pow = $__0.pow;
  function packIEEE754(v, ebits, fbits) {
    var bias = (1 << (ebits - 1)) - 1,
        s,
        e,
        f,
        ln,
        i,
        bits,
        str,
        bytes;
    function roundToEven(n) {
      var w = floor(n),
          f = n - w;
      if (f < 0.5)
        return w;
      if (f > 0.5)
        return w + 1;
      return w % 2 ? w + 1 : w;
    }
    if (v !== v) {
      e = (1 << ebits) - 1;
      f = pow(2, fbits - 1);
      s = 0;
    } else if (v === Infinity || v === -Infinity) {
      e = (1 << ebits) - 1;
      f = 0;
      s = (v < 0) ? 1 : 0;
    } else if (v === 0) {
      e = 0;
      f = 0;
      s = (1 / v === -Infinity) ? 1 : 0;
    } else {
      s = v < 0;
      v = abs(v);
      if (v >= pow(2, 1 - bias)) {
        e = min(floor(log(v) / LN2), 1023);
        f = roundToEven(v / pow(2, e) * pow(2, fbits));
        if (f / pow(2, fbits) >= 2) {
          e = e + 1;
          f = 1;
        }
        if (e > bias) {
          e = (1 << ebits) - 1;
          f = 0;
        } else {
          e = e + bias;
          f = f - pow(2, fbits);
        }
      } else {
        e = 0;
        f = roundToEven(v / pow(2, 1 - bias - fbits));
      }
    }
    bits = [];
    for (i = fbits; i; i -= 1) {
      bits.push(f % 2 ? 1 : 0);
      f = floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
      bits.push(e % 2 ? 1 : 0);
      e = floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    bytes = [];
    while (str.length) {
      bytes.push(parseInt(str.substring(0, 8), 2));
      str = str.substring(8);
    }
    return bytes;
  }
  function unpackIEEE754(bytes, ebits, fbits) {
    var bits = [],
        i,
        j,
        b,
        str,
        bias,
        s,
        e,
        f;
    for (i = bytes.length; i; i -= 1) {
      b = bytes[i - 1];
      for (j = 8; j; j -= 1) {
        bits.push(b % 2 ? 1 : 0);
        b = b >> 1;
      }
    }
    bits.reverse();
    str = bits.join('');
    bias = (1 << (ebits - 1)) - 1;
    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
    e = parseInt(str.substring(1, 1 + ebits), 2);
    f = parseInt(str.substring(1 + ebits), 2);
    if (e === (1 << ebits) - 1) {
      return f !== 0 ? NaN : s * Infinity;
    } else if (e > 0) {
      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
    } else if (f !== 0) {
      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
    } else {
      return s < 0 ? -0 : 0;
    }
  }
  function unpackF32(b) {
    return unpackIEEE754(b, 8, 23);
  }
  function packF32(v) {
    return packIEEE754(v, 8, 23);
  }
  function fround(x) {
    if (x === 0 || !$isFinite(x) || $isNaN(x)) {
      return x;
    }
    return unpackF32(packF32(Number(x)));
  }
  return {get fround() {
      return fround;
    }};
});
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/Math.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js";
  var jsFround = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./fround.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js")).fround;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/Math.js")),
      maybeAddFunctions = $__3.maybeAddFunctions,
      registerPolyfill = $__3.registerPolyfill,
      toUint32 = $__3.toUint32;
  var $isFinite = isFinite;
  var $isNaN = isNaN;
  var $__0 = Math,
      abs = $__0.abs,
      ceil = $__0.ceil,
      exp = $__0.exp,
      floor = $__0.floor,
      log = $__0.log,
      pow = $__0.pow,
      sqrt = $__0.sqrt;
  function clz32(x) {
    x = toUint32(+x);
    if (x == 0)
      return 32;
    var result = 0;
    if ((x & 0xFFFF0000) === 0) {
      x <<= 16;
      result += 16;
    }
    ;
    if ((x & 0xFF000000) === 0) {
      x <<= 8;
      result += 8;
    }
    ;
    if ((x & 0xF0000000) === 0) {
      x <<= 4;
      result += 4;
    }
    ;
    if ((x & 0xC0000000) === 0) {
      x <<= 2;
      result += 2;
    }
    ;
    if ((x & 0x80000000) === 0) {
      x <<= 1;
      result += 1;
    }
    ;
    return result;
  }
  function imul(x, y) {
    x = toUint32(+x);
    y = toUint32(+y);
    var xh = (x >>> 16) & 0xffff;
    var xl = x & 0xffff;
    var yh = (y >>> 16) & 0xffff;
    var yl = y & 0xffff;
    return xl * yl + (((xh * yl + xl * yh) << 16) >>> 0) | 0;
  }
  function sign(x) {
    x = +x;
    if (x > 0)
      return 1;
    if (x < 0)
      return -1;
    return x;
  }
  function log10(x) {
    return log(x) * 0.434294481903251828;
  }
  function log2(x) {
    return log(x) * 1.442695040888963407;
  }
  function log1p(x) {
    x = +x;
    if (x < -1 || $isNaN(x)) {
      return NaN;
    }
    if (x === 0 || x === Infinity) {
      return x;
    }
    if (x === -1) {
      return -Infinity;
    }
    var result = 0;
    var n = 50;
    if (x < 0 || x > 1) {
      return log(1 + x);
    }
    for (var i = 1; i < n; i++) {
      if ((i % 2) === 0) {
        result -= pow(x, i) / i;
      } else {
        result += pow(x, i) / i;
      }
    }
    return result;
  }
  function expm1(x) {
    x = +x;
    if (x === -Infinity) {
      return -1;
    }
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return exp(x) - 1;
  }
  function cosh(x) {
    x = +x;
    if (x === 0) {
      return 1;
    }
    if ($isNaN(x)) {
      return NaN;
    }
    if (!$isFinite(x)) {
      return Infinity;
    }
    if (x < 0) {
      x = -x;
    }
    if (x > 21) {
      return exp(x) / 2;
    }
    return (exp(x) + exp(-x)) / 2;
  }
  function sinh(x) {
    x = +x;
    if (!$isFinite(x) || x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  }
  function tanh(x) {
    x = +x;
    if (x === 0)
      return x;
    if (!$isFinite(x))
      return sign(x);
    var exp1 = exp(x);
    var exp2 = exp(-x);
    return (exp1 - exp2) / (exp1 + exp2);
  }
  function acosh(x) {
    x = +x;
    if (x < 1)
      return NaN;
    if (!$isFinite(x))
      return x;
    return log(x + sqrt(x + 1) * sqrt(x - 1));
  }
  function asinh(x) {
    x = +x;
    if (x === 0 || !$isFinite(x))
      return x;
    if (x > 0)
      return log(x + sqrt(x * x + 1));
    return -log(-x + sqrt(x * x + 1));
  }
  function atanh(x) {
    x = +x;
    if (x === -1) {
      return -Infinity;
    }
    if (x === 1) {
      return Infinity;
    }
    if (x === 0) {
      return x;
    }
    if ($isNaN(x) || x < -1 || x > 1) {
      return NaN;
    }
    return 0.5 * log((1 + x) / (1 - x));
  }
  function hypot(x, y) {
    var length = arguments.length;
    var args = new Array(length);
    var max = 0;
    for (var i = 0; i < length; i++) {
      var n = arguments[i];
      n = +n;
      if (n === Infinity || n === -Infinity)
        return Infinity;
      n = abs(n);
      if (n > max)
        max = n;
      args[i] = n;
    }
    if (max === 0)
      max = 1;
    var sum = 0;
    var compensation = 0;
    for (var i = 0; i < length; i++) {
      var n = args[i] / max;
      var summand = n * n - compensation;
      var preliminary = sum + summand;
      compensation = (preliminary - sum) - summand;
      sum = preliminary;
    }
    return sqrt(sum) * max;
  }
  function trunc(x) {
    x = +x;
    if (x > 0)
      return floor(x);
    if (x < 0)
      return ceil(x);
    return x;
  }
  var fround,
      f32;
  if (typeof Float32Array === 'function') {
    f32 = new Float32Array(1);
    fround = function(x) {
      f32[0] = Number(x);
      return f32[0];
    };
  } else {
    fround = jsFround;
  }
  function cbrt(x) {
    x = +x;
    if (x === 0)
      return x;
    var negate = x < 0;
    if (negate)
      x = -x;
    var result = pow(x, 1 / 3);
    return negate ? -result : result;
  }
  function polyfillMath(global) {
    var Math = global.Math;
    maybeAddFunctions(Math, ['acosh', acosh, 'asinh', asinh, 'atanh', atanh, 'cbrt', cbrt, 'clz32', clz32, 'cosh', cosh, 'expm1', expm1, 'fround', fround, 'hypot', hypot, 'imul', imul, 'log10', log10, 'log1p', log1p, 'log2', log2, 'sign', sign, 'sinh', sinh, 'tanh', tanh, 'trunc', trunc]);
  }
  registerPolyfill(polyfillMath);
  return {
    get clz32() {
      return clz32;
    },
    get imul() {
      return imul;
    },
    get sign() {
      return sign;
    },
    get log10() {
      return log10;
    },
    get log2() {
      return log2;
    },
    get log1p() {
      return log1p;
    },
    get expm1() {
      return expm1;
    },
    get cosh() {
      return cosh;
    },
    get sinh() {
      return sinh;
    },
    get tanh() {
      return tanh;
    },
    get acosh() {
      return acosh;
    },
    get asinh() {
      return asinh;
    },
    get atanh() {
      return atanh;
    },
    get hypot() {
      return hypot;
    },
    get trunc() {
      return trunc;
    },
    get fround() {
      return fround;
    },
    get cbrt() {
      return cbrt;
    },
    get polyfillMath() {
      return polyfillMath;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/Math.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js";
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      createPrivateSymbol = $__5.createPrivateSymbol,
      deletePrivate = $__5.deletePrivate,
      getPrivate = $__5.getPrivate,
      hasPrivate = $__5.hasPrivate,
      setPrivate = $__5.setPrivate;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      deleteFrozen = $__6.deleteFrozen,
      getFrozen = $__6.getFrozen,
      hasFrozen = $__6.hasFrozen,
      setFrozen = $__6.setFrozen;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")),
      isObject = $__7.isObject,
      registerPolyfill = $__7.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js")).default;
  var $__2 = Object,
      defineProperty = $__2.defineProperty,
      getOwnPropertyDescriptor = $__2.getOwnPropertyDescriptor,
      isExtensible = $__2.isExtensible;
  var $TypeError = TypeError;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var sentinel = {};
  var WeakMap = function() {
    function WeakMap() {
      this.name_ = createPrivateSymbol();
      this.frozenData_ = [];
    }
    return ($traceurRuntime.createClass)(WeakMap, {
      set: function(key, value) {
        if (!isObject(key))
          throw new $TypeError('key must be an object');
        if (!isExtensible(key)) {
          setFrozen(this.frozenData_, key, value);
        } else {
          setPrivate(key, this.name_, value);
        }
        return this;
      },
      get: function(key) {
        if (!isObject(key))
          return undefined;
        if (!isExtensible(key)) {
          return getFrozen(this.frozenData_, key);
        }
        return getPrivate(key, this.name_);
      },
      delete: function(key) {
        if (!isObject(key))
          return false;
        if (!isExtensible(key)) {
          return deleteFrozen(this.frozenData_, key);
        }
        return deletePrivate(key, this.name_);
      },
      has: function(key) {
        if (!isObject(key))
          return false;
        if (!isExtensible(key)) {
          return hasFrozen(this.frozenData_, key);
        }
        return hasPrivate(key, this.name_);
      }
    }, {});
  }();
  function needsPolyfill(global) {
    var $__4 = global,
        WeakMap = $__4.WeakMap,
        Symbol = $__4.Symbol;
    if (!WeakMap || !hasNativeSymbol()) {
      return true;
    }
    try {
      var o = {};
      var wm = new WeakMap([[o, false]]);
      return wm.get(o);
    } catch (e) {
      return false;
    }
  }
  function polyfillWeakMap(global) {
    if (needsPolyfill(global)) {
      global.WeakMap = WeakMap;
    }
  }
  registerPolyfill(polyfillWeakMap);
  return {
    get WeakMap() {
      return WeakMap;
    },
    get polyfillWeakMap() {
      return polyfillWeakMap;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakMap.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js";
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../private.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      createPrivateSymbol = $__5.createPrivateSymbol,
      deletePrivate = $__5.deletePrivate,
      getPrivate = $__5.getPrivate,
      hasPrivate = $__5.hasPrivate,
      setPrivate = $__5.setPrivate;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../frozen-data.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      deleteFrozen = $__6.deleteFrozen,
      getFrozen = $__6.getFrozen,
      setFrozen = $__6.setFrozen;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")),
      isObject = $__7.isObject,
      registerPolyfill = $__7.registerPolyfill;
  var hasNativeSymbol = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("../has-native-symbols.js", "traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js")).default;
  var $__2 = Object,
      defineProperty = $__2.defineProperty,
      isExtensible = $__2.isExtensible;
  var $TypeError = TypeError;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var WeakSet = function() {
    function WeakSet() {
      this.name_ = createPrivateSymbol();
      this.frozenData_ = [];
    }
    return ($traceurRuntime.createClass)(WeakSet, {
      add: function(value) {
        if (!isObject(value))
          throw new $TypeError('value must be an object');
        if (!isExtensible(value)) {
          setFrozen(this.frozenData_, value, value);
        } else {
          setPrivate(value, this.name_, true);
        }
        return this;
      },
      delete: function(value) {
        if (!isObject(value))
          return false;
        if (!isExtensible(value)) {
          return deleteFrozen(this.frozenData_, value);
        }
        return deletePrivate(value, this.name_);
      },
      has: function(value) {
        if (!isObject(value))
          return false;
        if (!isExtensible(value)) {
          return getFrozen(this.frozenData_, value) === value;
        }
        return hasPrivate(value, this.name_);
      }
    }, {});
  }();
  function needsPolyfill(global) {
    var $__4 = global,
        WeakSet = $__4.WeakSet,
        Symbol = $__4.Symbol;
    if (!WeakSet || !hasNativeSymbol()) {
      return true;
    }
    try {
      var o = {};
      var wm = new WeakSet([[o]]);
      return !wm.has(o);
    } catch (e) {
      return false;
    }
  }
  function polyfillWeakSet(global) {
    if (needsPolyfill(global)) {
      global.WeakSet = WeakSet;
    }
  }
  registerPolyfill(polyfillWeakSet);
  return {
    get WeakSet() {
      return WeakSet;
    },
    get polyfillWeakSet() {
      return polyfillWeakSet;
    }
  };
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/WeakSet.js" + '');
$traceurRuntime.registerModule("traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js", [], function() {
  "use strict";
  var __moduleName = "traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js";
  var polyfillAll = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("./utils.js", "traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js")).polyfillAll;
  polyfillAll(Reflect.global);
  var setupGlobals = $traceurRuntime.setupGlobals;
  $traceurRuntime.setupGlobals = function(global) {
    setupGlobals(global);
    polyfillAll(global);
  };
  return {};
});
$traceurRuntime.getModule("traceur-runtime@0.0.111/src/runtime/polyfills/polyfills.js" + '');
;$traceurRuntime.registerModule("src/base/CooldownThrottle.js", [], function() {
  "use strict";
  var __moduleName = "src/base/CooldownThrottle.js";
  var CooldownThrottle = function() {
    function CooldownThrottle(action, cooldownMs) {
      var slowActionCooldownPumpUpFactor = arguments[2] !== (void 0) ? arguments[2] : 0;
      var waitWithRequestAnimationFrame = arguments[3] !== (void 0) ? arguments[3] : false;
      this.action = action;
      this.cooldownDuration = cooldownMs;
      this.slowActionCooldownPumpupFactor = slowActionCooldownPumpUpFactor;
      this._waitWithRequestAnimationFrame = waitWithRequestAnimationFrame;
      this._state = 'idle';
      this._cooldownStartTime = -Infinity;
    }
    return ($traceurRuntime.createClass)(CooldownThrottle, {
      _triggerIdle: function() {
        var remainingCooldownDuration = this.cooldownDuration - (performance.now() - this._cooldownStartTime);
        if (remainingCooldownDuration > 0) {
          this._forceIdleTriggerAfter(remainingCooldownDuration);
          return;
        }
        this._state = 'running';
        var t0 = performance.now();
        try {
          this.action();
        } finally {
          var dt = performance.now() - t0;
          this._cooldownStartTime = performance.now() + (dt * this.slowActionCooldownPumpupFactor);
          if (this._state === 'running-and-triggered') {
            this._forceIdleTriggerAfter(this.cooldownDuration);
          } else {
            this._state = 'idle';
          }
        }
      },
      trigger: function() {
        switch (this._state) {
          case 'idle':
            this._triggerIdle();
            break;
          case 'waiting':
            break;
          case 'running':
            this._state = 'running-and-triggered';
            break;
          case 'running-and-triggered':
            break;
          default:
            throw new Error('Unrecognized throttle state: ' + this._state);
        }
      },
      _forceIdleTriggerAfter: function(duration) {
        var $__1 = this;
        this._state = 'waiting';
        if (this._waitWithRequestAnimationFrame) {
          var iter;
          var start = performance.now();
          iter = function() {
            if (performance.now() < start + duration) {
              requestAnimationFrame(iter);
              return;
            }
            $__1._state = 'idle';
            $__1._cooldownStartTime = -Infinity;
            $__1.trigger();
          };
          iter();
        } else {
          setTimeout(function() {
            $__1._state = 'idle';
            $__1._cooldownStartTime = -Infinity;
            $__1.trigger();
          }, duration);
        }
      }
    }, {});
  }();
  return {get CooldownThrottle() {
      return CooldownThrottle;
    }};
});
//# sourceURL=src/base/CooldownThrottle.js
;$traceurRuntime.registerModule("src/base/Describe.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Describe.js";
  var COLLECTION_CUTOFF = 1000;
  var BAD_TO_STRING_RESULT = new (function() {})().toString();
  var RECURSE_LIMIT_DESCRIPTION = "!recursion-limit!";
  var DEFAULT_RECURSION_LIMIT = 10;
  function try_describe_atomic(value) {
    if (value === null) {
      return "null";
    }
    if (value === undefined) {
      return "undefined";
    }
    if (typeof value === "string") {
      return ("\"" + value + "\"");
    }
    if (typeof value === "number") {
      return "" + value;
    }
    return undefined;
  }
  function try_describe_collection(value, recursionLimit) {
    if (recursionLimit === 0) {
      return RECURSE_LIMIT_DESCRIPTION;
    }
    if (value instanceof Map) {
      return describe_Map(value, recursionLimit);
    }
    if (value instanceof Set) {
      return describe_Set(value, recursionLimit);
    }
    if (value[Symbol.iterator] !== undefined) {
      return describe_Iterable(value, recursionLimit);
    }
    return undefined;
  }
  function describe_fallback(value, recursionLimit) {
    var defaultString = String(value);
    if (defaultString !== BAD_TO_STRING_RESULT) {
      return defaultString;
    }
    return describe_Object(value, recursionLimit);
  }
  function describe(value) {
    var recursionLimit = arguments[1] !== (void 0) ? arguments[1] : DEFAULT_RECURSION_LIMIT;
    return try_describe_atomic(value) || try_describe_collection(value, recursionLimit) || describe_fallback(value, recursionLimit);
  }
  function describe_Map(map, limit) {
    var $__9,
        $__10;
    var entries = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (map.entries())[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var $__8 = $__2.value,
            k = ($__9 = $__8[Symbol.iterator](), ($__10 = $__9.next()).done ? void 0 : $__10.value),
            v = ($__10 = $__9.next()).done ? void 0 : $__10.value;
        {
          if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
          }
          var keyDesc = describe(k, limit - 1);
          var valDesc = describe(v, limit - 1);
          entries.push((keyDesc + ": " + valDesc));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    return ("Map{" + entries.join(", ") + "}");
  }
  function describe_Set(set, limit) {
    var entries = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (set)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var e = $__2.value;
        {
          if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
          }
          entries.push(describe(e, limit - 1));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    return ("Set{" + entries.join(", ") + "}");
  }
  function describe_Iterable(seq, limit) {
    var entries = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (seq)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var e = $__2.value;
        {
          if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
          }
          entries.push(describe(e, limit - 1));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var prefix = Array.isArray(seq) ? "" : seq.constructor.name;
    return (prefix + "[" + entries.join(", ") + "]");
  }
  function describe_Object(value, limit) {
    var entries = [];
    for (var k in value) {
      if (!value.hasOwnProperty(k)) {
        continue;
      }
      if (entries.length > COLLECTION_CUTOFF) {
        entries.push("[...]");
        break;
      }
      var v = value[k];
      var keyDesc = describe(k, limit - 1);
      var valDesc = describe(v, limit - 1);
      entries.push((keyDesc + ": " + valDesc));
    }
    var typeName = value.constructor.name;
    var prefix = typeName === {}.constructor.name ? "" : ("(Type: " + typeName + ")");
    return (prefix + "{" + entries.join(", ") + "}");
  }
  return {get describe() {
      return describe;
    }};
});
//# sourceURL=src/base/Describe.js
;$traceurRuntime.registerModule("src/base/DetailedError.js", [], function() {
  "use strict";
  var __moduleName = "src/base/DetailedError.js";
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Describe.js", "src/base/DetailedError.js")).describe;
  var CONSTRUCTOR_CALLS_NESTING = 0;
  var DetailedError = function($__super) {
    function DetailedError(message, detailsObj) {
      $traceurRuntime.superConstructor(DetailedError).call(this, message);
      this.detailsObj = detailsObj;
      this.name = 'Error';
      this.message = message;
      this.stack = new Error().stack;
      if (this.stack !== undefined) {
        this.stack = this.stack.replace(/^Error\n\s+at new DetailedError (\S+)\s?\n\s+at /, '\n    ');
      }
      CONSTRUCTOR_CALLS_NESTING++;
      try {
        this.details = CONSTRUCTOR_CALLS_NESTING === 1 ? describe(this.detailsObj) : "(failed to describe detailsObj due to possibly re-entrancy)";
      } catch (ex) {
        console.error(ex);
        this.details = "(failed to describe detailsObj, see the console for details)";
      } finally {
        CONSTRUCTOR_CALLS_NESTING--;
      }
    }
    return ($traceurRuntime.createClass)(DetailedError, {toString: function() {
        return ($traceurRuntime.superGet(this, DetailedError.prototype, "toString").call(this) + "\nDetails: " + this.details);
      }}, {}, $__super);
  }(Error);
  return {get DetailedError() {
      return DetailedError;
    }};
});
//# sourceURL=src/base/DetailedError.js
;$traceurRuntime.registerModule("src/base/Equate.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Equate.js";
  function equate(subject, other) {
    if (subject === other || (isExactlyNaN(subject) && isExactlyNaN(other))) {
      return true;
    }
    var customEquality = tryEquate_custom(subject, other);
    if (customEquality !== undefined) {
      return customEquality;
    }
    if (isAtomic(subject) || isAtomic(other) || !eqType(subject, other)) {
      return false;
    }
    if (subject instanceof Map) {
      return equate_Maps(subject, other);
    }
    if (subject instanceof Set) {
      return equate_Sets(subject, other);
    }
    if (isIndexable(subject)) {
      return equate_Indexables(subject, other);
    }
    return equate_Objects(subject, other);
  }
  var GENERIC_ARRAY_TYPES = [Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray];
  function isExactlyNaN(v) {
    return typeof v === "number" && isNaN(v);
  }
  function tryEquate_custom(subject, other) {
    if (!isAtomic(subject) && subject.constructor.prototype.hasOwnProperty("isEqualTo")) {
      return subject.isEqualTo(other);
    }
    if (!isAtomic(other) && other.constructor.prototype.hasOwnProperty("isEqualTo")) {
      return other.isEqualTo(subject);
    }
    return undefined;
  }
  function isAtomic(value) {
    return value === null || value === undefined || typeof value === "string" || typeof value === "number" || typeof value === "boolean";
  }
  function isIndexable(value) {
    return Array.isArray(value) || !GENERIC_ARRAY_TYPES.every(function(t) {
      return !(value instanceof t);
    });
  }
  function eqType(subject, other) {
    return subject.constructor.name === other.constructor.name;
  }
  function equate_Indexables(subject, other) {
    if (subject.length !== other.length) {
      return false;
    }
    for (var i = 0; i < subject.length; i++) {
      if (!equate(subject[i], other[i])) {
        return false;
      }
    }
    return true;
  }
  function equate_Iterables(subject, other) {
    var otherIter = other[Symbol.iterator]();
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (subject)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var subjectItem = $__1.value;
        {
          var otherItemDone = otherIter.next();
          if (otherItemDone.done || !equate(subjectItem, otherItemDone.value)) {
            return false;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    return otherIter.next().done;
  }
  function equate_Maps(subject, other) {
    var $__8,
        $__9;
    if (subject.size !== other.size) {
      return false;
    }
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (subject)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var $__7 = $__1.value,
            k = ($__8 = $__7[Symbol.iterator](), ($__9 = $__8.next()).done ? void 0 : $__9.value),
            v = ($__9 = $__8.next()).done ? void 0 : $__9.value;
        {
          if (!other.has(k)) {
            return false;
          }
          var otherV = other.get(k);
          if (!equate(v, otherV)) {
            return false;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    return true;
  }
  function equate_Sets(subject, other) {
    if (subject.size !== other.size) {
      return false;
    }
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (subject)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var k = $__1.value;
        {
          if (!other.has(k)) {
            return false;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    return true;
  }
  function objectKeys(obj) {
    var result = new Set();
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        result.add(k);
      }
    }
    return result;
  }
  function equate_Objects(subject, other) {
    var keys = objectKeys(subject);
    if (!equate_Sets(keys, objectKeys(other))) {
      return false;
    }
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (keys)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var k = $__1.value;
        {
          if (k === Symbol.iterator) {
            continue;
          }
          if (!equate(subject[k], other[k])) {
            return false;
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    var hasSubjectIter = subject[Symbol.iterator] !== undefined;
    var hasOtherIter = other[Symbol.iterator] !== undefined;
    if (hasSubjectIter !== hasOtherIter) {
      return false;
    }
    if (hasSubjectIter && hasOtherIter) {
      if (!equate_Iterables(subject, other)) {
        return false;
      }
    }
    return true;
  }
  return {get equate() {
      return equate;
    }};
});
//# sourceURL=src/base/Equate.js
;$traceurRuntime.registerModule("src/base/Format.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Format.js";
  var Format = function() {
    function Format(allowAbbreviation, maxAbbreviationError, fixedDigits, itemSeparator) {
      this.allowAbbreviation = allowAbbreviation;
      this.maxAbbreviationError = maxAbbreviationError;
      this.fixedDigits = fixedDigits;
      this.itemSeparator = itemSeparator;
    }
    return ($traceurRuntime.createClass)(Format, {formatFloat: function(f) {
        if (this.allowAbbreviation) {
          return abbreviateFloat(f, this.maxAbbreviationError, this.fixedDigits);
        }
        if (this.fixedDigits !== undefined) {
          return f.toFixed(this.fixedDigits);
        }
        return f + "";
      }}, {
      parseFloat: function(text) {
        if (text.length === 0) {
          throw new Error("Not a number: '" + text + "'");
        }
        if (text[0] === "-") {
          return -Format.parseFloat(text.substr(1));
        }
        if (text[0] === "\u221A") {
          return Math.sqrt(Format.parseFloat(text.substr(1)));
        }
        var fraction = match(UNICODE_FRACTIONS, function(e) {
          return e.character === text;
        });
        if (fraction !== undefined) {
          return fraction.value;
        }
        var result = parseFloat(text);
        if (isNaN(result)) {
          throw new Error("Not a number: '" + text + "'");
        }
        return result;
      },
      simplifyByRounding: function(value, epsilon) {
        if (value < 0) {
          return -Format.simplifyByRounding(-value, epsilon);
        }
        var r = value % 1;
        if (r <= epsilon || 1 - r <= epsilon) {
          return Math.round(value);
        }
        var fraction = match(UNICODE_FRACTIONS, function(e) {
          return Math.abs(e.value - value) <= epsilon;
        });
        if (fraction !== undefined) {
          return fraction.value;
        }
        var rootFraction = match(UNICODE_FRACTIONS, function(e) {
          return Math.abs(Math.sqrt(e.value) - value) <= epsilon;
        });
        if (rootFraction !== undefined) {
          return Math.sqrt(rootFraction.value);
        }
        return value;
      }
    });
  }();
  var UNICODE_FRACTIONS = [{
    character: "\u00BD",
    ref: "½",
    expanded: "1/2",
    value: 1 / 2
  }, {
    character: "\u00BC",
    ref: "¼",
    expanded: "1/4",
    value: 1 / 4
  }, {
    character: "\u00BE",
    ref: "¾",
    expanded: "3/4",
    value: 3 / 4
  }, {
    character: "\u2153",
    ref: "⅓",
    expanded: "1/3",
    value: 1 / 3
  }, {
    character: "\u2154",
    ref: "⅔",
    expanded: "2/3",
    value: 2 / 3
  }, {
    character: "\u2155",
    ref: "⅕",
    expanded: "1/5",
    value: 1 / 5
  }, {
    character: "\u2156",
    ref: "⅖",
    expanded: "2/5",
    value: 2 / 5
  }, {
    character: "\u2157",
    ref: "⅗",
    expanded: "3/5",
    value: 3 / 5
  }, {
    character: "\u2158",
    ref: "⅘",
    expanded: "4/5",
    value: 4 / 5
  }, {
    character: "\u2159",
    ref: "⅙",
    expanded: "1/6",
    value: 1 / 6
  }, {
    character: "\u215A",
    ref: "⅚",
    expanded: "5/6",
    value: 5 / 6
  }, {
    character: "\u2150",
    ref: "⅐",
    expanded: "1/7",
    value: 1 / 7
  }, {
    character: "\u215B",
    ref: "⅛",
    expanded: "1/8",
    value: 1 / 8
  }, {
    character: "\u215C",
    ref: "⅜",
    expanded: "3/8",
    value: 3 / 8
  }, {
    character: "\u215D",
    ref: "⅝",
    expanded: "5/8",
    value: 5 / 8
  }, {
    character: "\u215E",
    ref: "⅞",
    expanded: "7/8",
    value: 7 / 8
  }, {
    character: "\u2151",
    ref: "⅑",
    expanded: "1/9",
    value: 1 / 9
  }, {
    character: "\u2152",
    ref: "⅒",
    expanded: "1/10",
    value: 1 / 10
  }];
  var match = function(array, predicate) {
    var $__5 = true;
    var $__6 = false;
    var $__7 = undefined;
    try {
      for (var $__3 = void 0,
          $__2 = (array)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
        var item = $__3.value;
        {
          if (predicate(item)) {
            return item;
          }
        }
      }
    } catch ($__8) {
      $__6 = true;
      $__7 = $__8;
    } finally {
      try {
        if (!$__5 && $__2.return != null) {
          $__2.return();
        }
      } finally {
        if ($__6) {
          throw $__7;
        }
      }
    }
    return undefined;
  };
  function abbreviateFloat(value) {
    var epsilon = arguments[1] !== (void 0) ? arguments[1] : 0;
    var digits = arguments[2];
    if (Math.abs(value) < epsilon) {
      return "0";
    }
    if (value < 0) {
      return "-" + abbreviateFloat(-value, epsilon, digits);
    }
    var fraction = match(UNICODE_FRACTIONS, function(e) {
      return Math.abs(e.value - value) <= epsilon;
    });
    if (fraction !== undefined) {
      return fraction.character;
    }
    var rootFraction = match(UNICODE_FRACTIONS, function(e) {
      return Math.abs(Math.sqrt(e.value) - value) <= epsilon;
    });
    if (rootFraction !== undefined) {
      return "\u221A" + rootFraction.character;
    }
    if (value % 1 !== 0 && digits !== undefined) {
      return value.toFixed(digits);
    }
    return value.toString();
  }
  Format.EXACT = new Format(true, 0, undefined, ", ");
  Format.MINIFIED = new Format(true, 0, undefined, ",");
  Format.SIMPLIFIED = new Format(true, 0.0005, 3, ", ");
  Format.CONSISTENT = new Format(false, 0, 2, ", ");
  return {
    get Format() {
      return Format;
    },
    get UNICODE_FRACTIONS() {
      return UNICODE_FRACTIONS;
    }
  };
});
//# sourceURL=src/base/Format.js
;$traceurRuntime.registerModule("src/base/Obs.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Obs.js";
  var CooldownThrottle = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/CooldownThrottle.js", "src/base/Obs.js")).CooldownThrottle;
  var Observable = function() {
    function Observable(subscribe) {
      this._subscribe = subscribe;
    }
    return ($traceurRuntime.createClass)(Observable, {
      subscribe: function(observer) {
        return this._subscribe(observer);
      },
      snapshot: function() {
        var result = [];
        var unsub = this.subscribe(function(e) {
          return result.push(e);
        });
        unsub();
        return result;
      },
      map: function(transformFunc) {
        var $__3 = this;
        return new Observable(function(observer) {
          return $__3.subscribe(function(item) {
            return observer(transformFunc(item));
          });
        });
      },
      filter: function(predicate) {
        var $__3 = this;
        return new Observable(function(observer) {
          return $__3.subscribe(function(item) {
            if (predicate(item)) {
              observer(item);
            }
          });
        });
      },
      zipLatest: function(other, mergeFunc) {
        var $__3 = this;
        return new Observable(function(observer) {
          var has1 = false;
          var has2 = false;
          var last1;
          var last2;
          var unreg1 = $__3.subscribe(function(e1) {
            last1 = e1;
            has1 = true;
            if (has2) {
              observer(mergeFunc(last1, last2));
            }
          });
          var unreg2 = other.subscribe(function(e2) {
            last2 = e2;
            has2 = true;
            if (has1) {
              observer(mergeFunc(last1, last2));
            }
          });
          return function() {
            unreg1();
            unreg2();
          };
        });
      },
      flattenLatest: function() {
        var $__3 = this;
        return new Observable(function(observer) {
          var unregLatest = function() {};
          var isDone = false;
          var unregAll = $__3.subscribe(function(subObservable) {
            if (isDone) {
              return;
            }
            var prevUnreg = unregLatest;
            unregLatest = subObservable.subscribe(observer);
            prevUnreg();
          });
          return function() {
            isDone = true;
            unregLatest();
            unregAll();
          };
        });
      },
      peek: function(action) {
        return this.map(function(e) {
          action(e);
          return e;
        });
      },
      flatten: function() {
        var $__3 = this;
        return new Observable(function(observer) {
          var unsubs = [];
          unsubs.push($__3.subscribe(function(observable) {
            return unsubs.push(observable.subscribe(observer));
          }));
          return function() {
            var $__7 = true;
            var $__8 = false;
            var $__9 = undefined;
            try {
              for (var $__5 = void 0,
                  $__4 = (unsubs)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
                var unsub = $__5.value;
                {
                  unsub();
                }
              }
            } catch ($__10) {
              $__8 = true;
              $__9 = $__10;
            } finally {
              try {
                if (!$__7 && $__4.return != null) {
                  $__4.return();
                }
              } finally {
                if ($__8) {
                  throw $__9;
                }
              }
            }
          };
        });
      },
      throttleLatest: function(cooldownMillis) {
        var $__3 = this;
        return new Observable(function(observer) {
          var latest = undefined;
          var isKilled = false;
          var throttle = new CooldownThrottle(function() {
            if (!isKilled) {
              observer(latest);
            }
          }, cooldownMillis);
          var unsub = $__3.subscribe(function(e) {
            latest = e;
            throttle.trigger();
          });
          return function() {
            isKilled = true;
            unsub();
          };
        });
      },
      skip: function(count) {
        var $__3 = this;
        return new Observable(function(observer) {
          var remaining = count;
          return $__3.subscribe(function(item) {
            if (remaining > 0) {
              remaining -= 1;
            } else {
              observer(item);
            }
          });
        });
      },
      whenDifferent: function() {
        var equater = arguments[0];
        var $__3 = this;
        var eq = equater || (function(e1, e2) {
          return e1 === e2;
        });
        return new Observable(function(observer) {
          var hasLast = false;
          var last = undefined;
          return $__3.subscribe(function(item) {
            if (!hasLast || !eq(last, item)) {
              last = item;
              hasLast = true;
              observer(item);
            }
          });
        });
      }
    }, {
      of: function() {
        for (var items = [],
            $__11 = 0; $__11 < arguments.length; $__11++)
          items[$__11] = arguments[$__11];
        return new Observable(function(observer) {
          var $__7 = true;
          var $__8 = false;
          var $__9 = undefined;
          try {
            for (var $__5 = void 0,
                $__4 = (items)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
              var item = $__5.value;
              {
                observer(item);
              }
            }
          } catch ($__10) {
            $__8 = true;
            $__9 = $__10;
          } finally {
            try {
              if (!$__7 && $__4.return != null) {
                $__4.return();
              }
            } finally {
              if ($__8) {
                throw $__9;
              }
            }
          }
          return function() {};
        });
      },
      requestAnimationTicker: function() {
        return new Observable(function(observer) {
          var iter;
          var isDone = false;
          iter = function() {
            if (!isDone) {
              observer(undefined);
              window.requestAnimationFrame(iter);
            }
          };
          iter();
          return function() {
            isDone = true;
          };
        });
      },
      elementEvent: function(element, eventKey) {
        return new Observable(function(observer) {
          element.addEventListener(eventKey, observer);
          return function() {
            return element.removeEventListener(eventKey, observer);
          };
        });
      }
    });
  }();
  var ObservableSource = function() {
    function ObservableSource() {
      var $__3 = this;
      this._observers = [];
      this._observable = new Observable(function(observer) {
        $__3._observers.push(observer);
        var didRun = false;
        return function() {
          if (!didRun) {
            didRun = true;
            $__3._observers.splice($__3._observers.indexOf(observer), 1);
          }
        };
      });
    }
    return ($traceurRuntime.createClass)(ObservableSource, {
      observable: function() {
        return this._observable;
      },
      send: function(eventValue) {
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._observers)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var obs = $__5.value;
            {
              obs(eventValue);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
      }
    }, {});
  }();
  var ObservableValue = function() {
    function ObservableValue() {
      var initialValue = arguments[0];
      var $__3 = this;
      this._value = initialValue;
      this._source = new ObservableSource();
      this._observable = new Observable(function(observer) {
        observer($__3._value);
        return $__3._source.observable().subscribe(observer);
      });
    }
    return ($traceurRuntime.createClass)(ObservableValue, {
      observable: function() {
        return this._observable;
      },
      set: function(newValue) {
        this._value = newValue;
        this._source.send(newValue);
      },
      get: function() {
        return this._value;
      }
    }, {});
  }();
  return {
    get Observable() {
      return Observable;
    },
    get ObservableSource() {
      return ObservableSource;
    },
    get ObservableValue() {
      return ObservableValue;
    }
  };
});
//# sourceURL=src/base/Obs.js
;$traceurRuntime.registerModule("src/base/RestartableRng.js", [], function() {
  "use strict";
  var __moduleName = "src/base/RestartableRng.js";
  var RestartableRng = function() {
    function RestartableRng() {
      this._cache = [];
      this._next = 0;
    }
    return ($traceurRuntime.createClass)(RestartableRng, {
      restarted: function() {
        var result = new RestartableRng();
        result._cache = this._cache;
        return result;
      },
      random: function() {
        var p = this._next++;
        if (p >= this._cache.length) {
          this._cache.push(Math.random());
        }
        return this._cache[p];
      }
    }, {});
  }();
  return {get RestartableRng() {
      return RestartableRng;
    }};
});
//# sourceURL=src/base/RestartableRng.js
;$traceurRuntime.registerModule("src/base/Revision.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Revision.js";
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Describe.js", "src/base/Revision.js")).describe;
  var equate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Equate.js", "src/base/Revision.js")).equate;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/base/Revision.js")).DetailedError;
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Obs.js", "src/base/Revision.js")),
      ObservableSource = $__5.ObservableSource,
      ObservableValue = $__5.ObservableValue;
  var Revision = function() {
    function Revision(history, index, isWorkingOnCommit) {
      if (index < 0 || index >= history.length) {
        throw new DetailedError("Bad index", {
          history: history,
          index: index,
          isWorkingOnCommit: isWorkingOnCommit
        });
      }
      if (!Array.isArray(history)) {
        throw new DetailedError("Bad history", {
          history: history,
          index: index,
          isWorkingOnCommit: isWorkingOnCommit
        });
      }
      this.history = history;
      this.index = index;
      this.isWorkingOnCommit = isWorkingOnCommit;
      this._changes = new ObservableSource();
      this._latestActiveCommit = new ObservableValue(this.history[this.index]);
    }
    return ($traceurRuntime.createClass)(Revision, {
      changes: function() {
        return this._changes.observable();
      },
      latestActiveCommit: function() {
        return this._latestActiveCommit.observable();
      },
      peekActiveCommit: function() {
        return this._latestActiveCommit.get();
      },
      isAtBeginningOfHistory: function() {
        return this.index === 0 && !this.isWorkingOnCommit;
      },
      isAtEndOfHistory: function() {
        return this.index === this.history.length - 1;
      },
      clear: function(state) {
        this.history = [state];
        this.index = 0;
        this.isWorkingOnCommit = false;
        this._changes.send(state);
        this._latestActiveCommit.set(state);
      },
      startedWorkingOnCommit: function() {
        this.isWorkingOnCommit = true;
        this._changes.send(undefined);
      },
      cancelCommitBeingWorkedOn: function() {
        this.isWorkingOnCommit = false;
        var result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
      },
      commit: function(newCheckpoint) {
        if (newCheckpoint === this.history[this.index]) {
          this.cancelCommitBeingWorkedOn();
          return;
        }
        this.isWorkingOnCommit = false;
        this.index += 1;
        this.history.splice(this.index, this.history.length - this.index);
        this.history.push(newCheckpoint);
        this._changes.send(newCheckpoint);
        this._latestActiveCommit.set(newCheckpoint);
      },
      undo: function() {
        if (!this.isWorkingOnCommit) {
          if (this.index === 0) {
            return undefined;
          }
          this.index -= 1;
        }
        this.isWorkingOnCommit = false;
        var result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
      },
      redo: function() {
        if (this.index + 1 === this.history.length) {
          return undefined;
        }
        this.index += 1;
        this.isWorkingOnCommit = false;
        var result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
      },
      toString: function() {
        return 'Revision(' + describe({
          index: this.index,
          count: this.history.length,
          workingOnCommit: this.isWorkingOnCommit,
          head: this.history[this.index]
        }) + ')';
      },
      isEqualTo: function(other) {
        return other instanceof Revision && this.index === other.index && this.isWorkingOnCommit === other.isWorkingOnCommit && equate(this.history, other.history);
      }
    }, {startingAt: function(state) {
        return new Revision([state], 0, false);
      }});
  }();
  return {get Revision() {
      return Revision;
    }};
});
//# sourceURL=src/base/Revision.js
;$traceurRuntime.registerModule("src/base/Seq.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Seq.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/base/Seq.js")).DetailedError;
  var THROW_IF_EMPTY = {if_same_instance_as_this_then_throw: true};
  var EMPTY_SYGIL = {not_a_normal_value: true};
  var GENERIC_ARRAY_TYPES = [Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray];
  var isIterable = function(obj) {
    return typeof Object(obj)[Symbol.iterator] === 'function';
  };
  var emptyFallback = function(result, alternative, errorMessage) {
    if (result !== EMPTY_SYGIL) {
      return result;
    }
    if (alternative === THROW_IF_EMPTY) {
      throw new Error(errorMessage);
    }
    return alternative;
  };
  var Seq = function() {
    function Seq(obj) {
      var isIteratorFunction = arguments[1] !== (void 0) ? arguments[1] : false;
      var $__3;
      var iterable;
      var iterator;
      if (obj instanceof Seq) {
        iterable = obj._iterable;
        iterator = obj[Symbol.iterator];
      } else if (isIteratorFunction) {
        iterable = ($__3 = {}, Object.defineProperty($__3, Symbol.iterator, {
          value: obj,
          configurable: true,
          enumerable: true,
          writable: true
        }), $__3);
        iterator = obj;
      } else {
        if (!isIterable(obj)) {
          throw new Error(("Not iterable: " + obj));
        }
        iterable = obj;
        iterator = obj[Symbol.iterator].bind(obj);
      }
      this._iterable = iterable;
      this[Symbol.iterator] = iterator;
    }
    return ($traceurRuntime.createClass)(Seq, {
      isEqualTo: function(other) {
        var comparator = arguments[1] !== (void 0) ? arguments[1] : function(e1, e2) {
          return e1 === e2;
        };
        if (!isIterable(other)) {
          return false;
        }
        if (other === this) {
          return true;
        }
        var iter2 = other[Symbol.iterator]();
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e1 = $__5.value;
            {
              var e2 = iter2.next();
              if (e2.done || !comparator(e1, e2.value)) {
                return false;
              }
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return iter2.next().done;
      },
      toArray: function() {
        return Array.from(this._iterable);
      },
      toFloat32Array: function() {
        var n = this.tryPeekCount();
        if (n === undefined) {
          return new Float32Array(this.toArray());
        }
        var buf = new Float32Array(n);
        var i = 0;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              buf[i++] = item;
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return buf;
      },
      toSet: function() {
        return new Set(this._iterable);
      },
      join: function(joiner) {
        return this.toArray().join(joiner);
      },
      toString: function() {
        return ("Seq[" + this.join(", ") + "]");
      },
      solidify: function() {
        var knownSolidTypes = [Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array];
        if (Array.isArray(this._iterable)) {
          return this;
        }
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (knownSolidTypes)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var t = $__5.value;
            {
              if (this._iterable instanceof t) {
                return this;
              }
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return new Seq(this.toArray());
      },
      map: function(projection) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 24;
                  break;
                case 24:
                  $ctx.pushTry(10, 11);
                  $ctx.state = 13;
                  break;
                case 13:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 5 : 7;
                  break;
                case 4:
                  $__7 = true;
                  $ctx.state = 9;
                  break;
                case 5:
                  e = $__5.value;
                  $ctx.state = 6;
                  break;
                case 6:
                  $ctx.state = 2;
                  return projection(e);
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 7:
                  $ctx.popTry();
                  $ctx.state = 11;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 16;
                  break;
                case 16:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 11;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 11:
                  $ctx.popTry();
                  $ctx.state = 22;
                  break;
                case 22:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 20;
                  break;
                case 20:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      mapWithIndex: function(projection) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.pushTry(12, 13);
                  $ctx.state = 15;
                  break;
                case 15:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 7 : 9;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 11;
                  break;
                case 7:
                  e = $__5.value;
                  $ctx.state = 8;
                  break;
                case 8:
                  $ctx.state = 2;
                  return projection(e, i);
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i += 1;
                  $ctx.state = 6;
                  break;
                case 9:
                  $ctx.popTry();
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 24;
                  break;
                case 24:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 22;
                  break;
                case 22:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      flatMap: function(sequenceProjection) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__13,
              $__14,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.pushTry(18, 19);
                  $ctx.state = 21;
                  break;
                case 21:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 17;
                  break;
                case 17:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 13 : 15;
                  break;
                case 10:
                  $__7 = true;
                  $ctx.state = 17;
                  break;
                case 13:
                  e = $__5.value;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__13 = $ctx.wrapYieldStar(sequenceProjection(e)[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__14 = $__13[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__14.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__14.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__14.value;
                case 15:
                  $ctx.popTry();
                  $ctx.state = 19;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 18:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 24;
                  break;
                case 24:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 19;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 19:
                  $ctx.popTry();
                  $ctx.state = 30;
                  break;
                case 30:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      filter: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.pushTry(11, 12);
                  $ctx.state = 14;
                  break;
                case 14:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 10;
                  break;
                case 10:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 6 : 8;
                  break;
                case 4:
                  $__7 = true;
                  $ctx.state = 10;
                  break;
                case 6:
                  e = $__5.value;
                  $ctx.state = 7;
                  break;
                case 7:
                  $ctx.state = (predicate(e)) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 8:
                  $ctx.popTry();
                  $ctx.state = 12;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 11:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 17;
                  break;
                case 17:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 12;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 23;
                  break;
                case 23:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 21;
                  break;
                case 21:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      filterWithIndex: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.pushTry(13, 14);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 8 : 10;
                  break;
                case 7:
                  $__7 = true;
                  $ctx.state = 12;
                  break;
                case 8:
                  e = $__5.value;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (predicate(e, i)) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 7;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 19;
                  break;
                case 19:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 25;
                  break;
                case 25:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      fold: function(combiner) {
        var emptyErrorAlternative = arguments[1] !== (void 0) ? arguments[1] : THROW_IF_EMPTY;
        var accumulator = EMPTY_SYGIL;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              accumulator = accumulator === EMPTY_SYGIL ? e : combiner(accumulator, e);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return emptyFallback(accumulator, emptyErrorAlternative, "Folded empty sequence without providing an alternative result.");
      },
      aggregate: function(seed, aggregator) {
        var accumulator = seed;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              accumulator = aggregator(accumulator, e);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return accumulator;
      },
      zip: function(other, combiner) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var iter2,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              item1,
              item2,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  iter2 = other[Symbol.iterator]();
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 29;
                  break;
                case 29:
                  $ctx.pushTry(15, 16);
                  $ctx.state = 18;
                  break;
                case 18:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 10 : 12;
                  break;
                case 7:
                  $__7 = true;
                  $ctx.state = 14;
                  break;
                case 10:
                  item1 = $__5.value;
                  $ctx.state = 11;
                  break;
                case 11:
                  item2 = iter2.next();
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (item2.done) ? 12 : 2;
                  break;
                case 2:
                  $ctx.state = 5;
                  return combiner(item1, item2.value);
                case 5:
                  $ctx.maybeThrow();
                  $ctx.state = 7;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 15:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 21;
                  break;
                case 21:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 16:
                  $ctx.popTry();
                  $ctx.state = 27;
                  break;
                case 27:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      max: function() {
        var emptyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        return this.fold(function(e1, e2) {
          return e1 < e2 ? e2 : e1;
        }, emptyErrorAlternative);
      },
      min: function() {
        var emptyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        return this.fold(function(e1, e2) {
          return e1 < e2 ? e1 : e2;
        }, emptyErrorAlternative);
      },
      maxBy: function(projection) {
        var emptyErrorAlternative = arguments[1] !== (void 0) ? arguments[1] : THROW_IF_EMPTY;
        var isALessThanBComparator = arguments[2] !== (void 0) ? arguments[2] : function(e1, e2) {
          return e1 < e2;
        };
        var curMaxItem = EMPTY_SYGIL;
        var curMaxScore = EMPTY_SYGIL;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              if (curMaxItem === EMPTY_SYGIL) {
                curMaxItem = item;
                continue;
              }
              if (curMaxScore === EMPTY_SYGIL) {
                curMaxScore = projection(curMaxItem);
              }
              var score = projection(item);
              if (isALessThanBComparator(curMaxScore, score)) {
                curMaxItem = item;
                curMaxScore = score;
              }
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return emptyFallback(curMaxItem, emptyErrorAlternative, "Can't maxBy an empty sequence.");
      },
      minBy: function(projection) {
        var emptyErrorAlternative = arguments[1] !== (void 0) ? arguments[1] : THROW_IF_EMPTY;
        var isALessThanBComparator = arguments[2] !== (void 0) ? arguments[2] : function(e1, e2) {
          return e1 < e2;
        };
        return this.maxBy(projection, emptyErrorAlternative, function(e1, e2) {
          return isALessThanBComparator(e2, e1);
        });
      },
      any: function(predicate) {
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              if (predicate(e)) {
                return true;
              }
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return false;
      },
      every: function(predicate) {
        return !this.any(function(e) {
          return !predicate(e);
        });
      },
      contains: function(value) {
        return this.any(function(e) {
          return e === value;
        });
      },
      sum: function() {
        var total = 0;
        var first = true;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              total = first ? e : total + e;
              first = false;
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return total;
      },
      product: function() {
        return this.fold(function(a, e) {
          return a * e;
        }, 1);
      },
      scan: function(seed, aggregator) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var accumulator,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  accumulator = seed;
                  $ctx.state = 30;
                  break;
                case 30:
                  $ctx.state = 2;
                  return accumulator;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.pushTry(16, 17);
                  $ctx.state = 19;
                  break;
                case 19:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 15;
                  break;
                case 15:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 11 : 13;
                  break;
                case 8:
                  $__7 = true;
                  $ctx.state = 15;
                  break;
                case 11:
                  e = $__5.value;
                  $ctx.state = 12;
                  break;
                case 12:
                  accumulator = aggregator(accumulator, e);
                  $ctx.state = 10;
                  break;
                case 10:
                  $ctx.state = 6;
                  return accumulator;
                case 6:
                  $ctx.maybeThrow();
                  $ctx.state = 8;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 17;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 16:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 22;
                  break;
                case 22:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 17;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 17:
                  $ctx.popTry();
                  $ctx.state = 28;
                  break;
                case 28:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      reverse: function() {
        return new Seq(this.toArray().reverse());
      },
      flatten: function() {
        var seqSeq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              seq$__11,
              $__15,
              $__16,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 32;
                  break;
                case 32:
                  $ctx.pushTry(18, 19);
                  $ctx.state = 21;
                  break;
                case 21:
                  $__5 = void 0, $__4 = (seqSeq)[Symbol.iterator]();
                  $ctx.state = 17;
                  break;
                case 17:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 13 : 15;
                  break;
                case 10:
                  $__7 = true;
                  $ctx.state = 17;
                  break;
                case 13:
                  seq$__11 = $__5.value;
                  $ctx.state = 14;
                  break;
                case 14:
                  $__15 = $ctx.wrapYieldStar(seq$__11[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__16 = $__15[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__16.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__16.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__16.value;
                case 15:
                  $ctx.popTry();
                  $ctx.state = 19;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 18:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 24;
                  break;
                case 24:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 19;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 19:
                  $ctx.popTry();
                  $ctx.state = 30;
                  break;
                case 30:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 28;
                  break;
                case 28:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      concat: function(other) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__17,
              $__18,
              $__19,
              $__20;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__17 = $ctx.wrapYieldStar(seq[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__18 = $__17[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__18.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__18.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__18.value;
                case 10:
                  $__19 = $ctx.wrapYieldStar(other[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 24;
                  break;
                case 24:
                  $__20 = $__19[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 21;
                  break;
                case 21:
                  $ctx.state = ($__20.done) ? 15 : 14;
                  break;
                case 15:
                  $ctx.sent = $__20.value;
                  $ctx.state = -2;
                  break;
                case 14:
                  $ctx.state = 24;
                  return $__20.value;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      withOverlayedItem: function(index, overlayedItem) {
        if (index < 0) {
          throw new Error("needed index >= 0");
        }
        var self = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  if (self.tryPeekCount() !== undefined && index >= self.tryPeekCount()) {
                    throw new Error("needed index <= count");
                  }
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.pushTry(12, 13);
                  $ctx.state = 15;
                  break;
                case 15:
                  $__5 = void 0, $__4 = (self._iterable)[Symbol.iterator]();
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 7 : 9;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 11;
                  break;
                case 7:
                  e = $__5.value;
                  $ctx.state = 8;
                  break;
                case 8:
                  $ctx.state = 2;
                  return i === index ? overlayedItem : e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 6;
                  break;
                case 9:
                  $ctx.popTry();
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 24;
                  break;
                case 24:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 22;
                  break;
                case 17:
                  if (i <= index) {
                    throw new Error("sequence ended before overlay " + "[withOverlayedItem(${index}, ${overlayedItem})]");
                  }
                  $ctx.state = -2;
                  break;
                case 22:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      withTransformedItem: function(index, itemTransformation) {
        if (index < 0) {
          throw new Error("needed index >= 0");
        }
        var self = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  if (self.tryPeekCount() !== undefined && index >= self.tryPeekCount()) {
                    throw new Error("needed index <= count");
                  }
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.pushTry(12, 13);
                  $ctx.state = 15;
                  break;
                case 15:
                  $__5 = void 0, $__4 = (self._iterable)[Symbol.iterator]();
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 7 : 9;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 11;
                  break;
                case 7:
                  e = $__5.value;
                  $ctx.state = 8;
                  break;
                case 8:
                  $ctx.state = 2;
                  return i === index ? itemTransformation(e) : e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 6;
                  break;
                case 9:
                  $ctx.popTry();
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 24;
                  break;
                case 24:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 22;
                  break;
                case 17:
                  if (i <= index) {
                    throw new Error("sequence ended before transformation " + "[withTransformedItem(${index}, ${itemTransformation})]");
                  }
                  $ctx.state = -2;
                  break;
                case 22:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      withInsertedItem: function(index, item) {
        if (index < 0) {
          throw new Error("needed index >= 0");
        }
        var self = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  if (self.tryPeekCount() !== undefined && index > self.tryPeekCount()) {
                    throw new Error("needed index <= count");
                  }
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 36;
                  break;
                case 36:
                  $ctx.pushTry(17, 18);
                  $ctx.state = 20;
                  break;
                case 20:
                  $__5 = void 0, $__4 = (self._iterable)[Symbol.iterator]();
                  $ctx.state = 16;
                  break;
                case 16:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 12 : 14;
                  break;
                case 9:
                  $__7 = true;
                  $ctx.state = 16;
                  break;
                case 12:
                  e = $__5.value;
                  $ctx.state = 13;
                  break;
                case 13:
                  $ctx.state = (i === index) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return item;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = 7;
                  return e;
                case 7:
                  $ctx.maybeThrow();
                  $ctx.state = 9;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 18;
                  $ctx.finallyFallThrough = 22;
                  break;
                case 17:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 23;
                  break;
                case 23:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 18;
                  $ctx.finallyFallThrough = 22;
                  break;
                case 18:
                  $ctx.popTry();
                  $ctx.state = 29;
                  break;
                case 29:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 27;
                  break;
                case 22:
                  $ctx.state = (i === index) ? 30 : 33;
                  break;
                case 30:
                  $ctx.state = 31;
                  return item;
                case 31:
                  $ctx.maybeThrow();
                  $ctx.state = 33;
                  break;
                case 33:
                  if (i < index) {
                    throw new Error("sequence ended before insertion [withInsertedItem(${index}, ${item})]");
                  }
                  $ctx.state = -2;
                  break;
                case 27:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      takeWhile: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.pushTry(13, 14);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 8 : 10;
                  break;
                case 7:
                  $__7 = true;
                  $ctx.state = 12;
                  break;
                case 8:
                  e = $__5.value;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (!predicate(e)) ? 10 : 2;
                  break;
                case 2:
                  $ctx.state = 5;
                  return e;
                case 5:
                  $ctx.maybeThrow();
                  $ctx.state = 7;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 19;
                  break;
                case 19:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 25;
                  break;
                case 25:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      skipTailWhile: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var tail,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__21,
              $__22,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  tail = [];
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 41;
                  break;
                case 41:
                  $ctx.pushTry(27, 28);
                  $ctx.state = 30;
                  break;
                case 30:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 26;
                  break;
                case 26:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 22 : 24;
                  break;
                case 20:
                  $__7 = true;
                  $ctx.state = 26;
                  break;
                case 22:
                  e = $__5.value;
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = (predicate(e)) ? 19 : 11;
                  break;
                case 19:
                  tail.push(e);
                  $ctx.state = 20;
                  break;
                case 11:
                  $__21 = $ctx.wrapYieldStar(tail[Symbol.iterator]());
                  $ctx.sent = void 0;
                  $ctx.action = 'next';
                  $ctx.state = 12;
                  break;
                case 12:
                  $__22 = $__21[$ctx.action]($ctx.sentIgnoreThrow);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = ($__22.done) ? 3 : 2;
                  break;
                case 3:
                  $ctx.sent = $__22.value;
                  $ctx.state = 10;
                  break;
                case 2:
                  $ctx.state = 12;
                  return $__22.value;
                case 10:
                  tail = [];
                  $ctx.state = 18;
                  break;
                case 18:
                  $ctx.state = 14;
                  return e;
                case 14:
                  $ctx.maybeThrow();
                  $ctx.state = 20;
                  break;
                case 24:
                  $ctx.popTry();
                  $ctx.state = 28;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 27:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 33;
                  break;
                case 33:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 28;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 28:
                  $ctx.popTry();
                  $ctx.state = 39;
                  break;
                case 39:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 37;
                  break;
                case 37:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      skipWhile: function(predicate) {
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var matched,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  matched = true;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.pushTry(13, 14);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 8 : 10;
                  break;
                case 4:
                  $__7 = true;
                  $ctx.state = 12;
                  break;
                case 8:
                  e = $__5.value;
                  $ctx.state = 9;
                  break;
                case 9:
                  matched = matched && predicate(e);
                  $ctx.state = 7;
                  break;
                case 7:
                  $ctx.state = (!matched) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 19;
                  break;
                case 19:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 25;
                  break;
                case 25:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      take: function(maxTakeCount) {
        if (maxTakeCount < 0) {
          throw new Error("needed maxTakeCount >= 0");
        }
        if (maxTakeCount === 0) {
          return new Seq([]);
        }
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 29;
                  break;
                case 29:
                  $ctx.pushTry(15, 16);
                  $ctx.state = 18;
                  break;
                case 18:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 10 : 12;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 14;
                  break;
                case 10:
                  e = $__5.value;
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (i >= maxTakeCount) ? 12 : 6;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 15:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 21;
                  break;
                case 21:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 16:
                  $ctx.popTry();
                  $ctx.state = 27;
                  break;
                case 27:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 25;
                  break;
                case 25:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      skip: function(maxSkipCount) {
        if (maxSkipCount < 0) {
          throw new Error("needed maxSkipCount >= 0");
        }
        if (maxSkipCount === 0) {
          return this;
        }
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 27;
                  break;
                case 27:
                  $ctx.pushTry(13, 14);
                  $ctx.state = 16;
                  break;
                case 16:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 12;
                  break;
                case 12:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 8 : 10;
                  break;
                case 7:
                  $__7 = true;
                  $ctx.state = 12;
                  break;
                case 8:
                  e = $__5.value;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (i >= maxSkipCount) ? 1 : 4;
                  break;
                case 1:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 7;
                  break;
                case 10:
                  $ctx.popTry();
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 19;
                  break;
                case 19:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 14;
                  $ctx.finallyFallThrough = -2;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 25;
                  break;
                case 25:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 23;
                  break;
                case 23:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      distinctBy: function(keySelector) {
        var seq = this;
        return Seq.fromGenerator(function() {
          var keySet = new Set();
          return seq.filter(function(e) {
            var key = keySelector(e);
            if (keySet.has(key)) {
              return false;
            }
            keySet.add(key);
            return true;
          })[Symbol.iterator]();
        });
      },
      distinct: function() {
        return this.distinctBy(function(e) {
          return e;
        });
      },
      segmentBy: function(keySelector) {
        var seq = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var group,
              lastKey,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              item,
              itemKey,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  group = [];
                  lastKey = undefined;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 36;
                  break;
                case 36:
                  $ctx.pushTry(17, 18);
                  $ctx.state = 20;
                  break;
                case 20:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 16;
                  break;
                case 16:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 12 : 14;
                  break;
                case 11:
                  $__7 = true;
                  $ctx.state = 16;
                  break;
                case 12:
                  item = $__5.value;
                  $ctx.state = 13;
                  break;
                case 13:
                  itemKey = keySelector(item);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (group.length > 0 && itemKey !== lastKey) ? 1 : 6;
                  break;
                case 1:
                  $ctx.state = 2;
                  return group;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  group = [];
                  $ctx.state = 6;
                  break;
                case 6:
                  group.push(item);
                  lastKey = itemKey;
                  $ctx.state = 11;
                  break;
                case 14:
                  $ctx.popTry();
                  $ctx.state = 18;
                  $ctx.finallyFallThrough = 22;
                  break;
                case 17:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 23;
                  break;
                case 23:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 18;
                  $ctx.finallyFallThrough = 22;
                  break;
                case 18:
                  $ctx.popTry();
                  $ctx.state = 29;
                  break;
                case 29:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 27;
                  break;
                case 22:
                  $ctx.state = (group.length > 0) ? 30 : -2;
                  break;
                case 30:
                  $ctx.state = 31;
                  return group;
                case 31:
                  $ctx.maybeThrow();
                  $ctx.state = -2;
                  break;
                case 27:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      single: function() {
        var emptyManyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        var iter = this[Symbol.iterator]();
        var first = iter.next();
        if (!first.done && iter.next().done) {
          return first.value;
        }
        if (emptyManyErrorAlternative === THROW_IF_EMPTY) {
          if (first.done) {
            throw new Error("Empty sequence doesn't contain a single item.");
          } else {
            throw new Error("Sequence contains more than a single item.");
          }
        }
        return emptyManyErrorAlternative;
      },
      first: function() {
        var emptyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        var iter = this[Symbol.iterator]();
        var first = iter.next();
        if (!first.done) {
          return first.value;
        }
        if (emptyErrorAlternative === THROW_IF_EMPTY) {
          throw new Error("Empty sequence has no first item.");
        }
        return emptyErrorAlternative;
      },
      last: function() {
        var emptyErrorAlternative = arguments[0] !== (void 0) ? arguments[0] : THROW_IF_EMPTY;
        var result = EMPTY_SYGIL;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              result = e;
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return emptyFallback(result, emptyErrorAlternative, "Empty sequence has no last item.");
      },
      tryPeekCount: function() {
        var $__2 = this;
        if (Array.isArray(this._iterable) || !GENERIC_ARRAY_TYPES.every(function(t) {
          return !($__2._iterable instanceof t);
        })) {
          return this._iterable.length;
        }
        if (this._iterable instanceof Map || this._iterable instanceof Set) {
          return this._iterable.size;
        }
        return undefined;
      },
      count: function() {
        var known = this.tryPeekCount();
        if (known !== undefined) {
          return known;
        }
        var n = 0;
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var _ = $__5.value;
            {
              n++;
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return n;
      },
      padded: function(minCount) {
        var paddingItem = arguments[1];
        if (minCount < 0) {
          throw new Error("needed minCount >= 0");
        }
        var seq = this._iterable;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var remaining,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              e,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  remaining = minCount;
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 33;
                  break;
                case 33:
                  $ctx.pushTry(12, 13);
                  $ctx.state = 15;
                  break;
                case 15:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 7 : 9;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 11;
                  break;
                case 7:
                  e = $__5.value;
                  $ctx.state = 8;
                  break;
                case 8:
                  $ctx.state = 2;
                  return e;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  remaining -= 1;
                  $ctx.state = 6;
                  break;
                case 9:
                  $ctx.popTry();
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 18;
                  break;
                case 18:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 13;
                  $ctx.finallyFallThrough = 17;
                  break;
                case 13:
                  $ctx.popTry();
                  $ctx.state = 24;
                  break;
                case 24:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 22;
                  break;
                case 17:
                  $ctx.state = (remaining > 0) ? 25 : -2;
                  break;
                case 25:
                  $ctx.state = 26;
                  return paddingItem;
                case 26:
                  $ctx.maybeThrow();
                  $ctx.state = 28;
                  break;
                case 28:
                  remaining -= 1;
                  $ctx.state = 17;
                  break;
                case 22:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      sorted: function() {
        return seq(this.toArray().sort());
      },
      sortedBy: function(keySelector) {
        return seq(this.toArray().sort(function(e1, e2) {
          var out1 = keySelector(e1);
          var out2 = keySelector(e2);
          return out1 < out2 ? -1 : out1 > out2 ? +1 : 0;
        }));
      },
      ifThen: function(condition, sequenceTransformation) {
        return condition ? new Seq(sequenceTransformation(this)) : this;
      },
      toMap: function(keySelector, valueSelector) {
        var map = new Map();
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              var key = keySelector(item);
              var val = valueSelector(item);
              if (map.has(key)) {
                throw new Error(("Duplicate key <" + key + ">. Came from item <" + item + ">."));
              }
              map.set(key, val);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return map;
      },
      keyedBy: function(keySelector) {
        return this.toMap(keySelector, function(e) {
          return e;
        });
      },
      groupBy: function(keySelector) {
        var map = new Map();
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._iterable)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var item = $__5.value;
            {
              var key = keySelector(item);
              if (!map.has(key)) {
                map.set(key, []);
              }
              map.get(key).push(item);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        return map;
      },
      partitioned: function(partitionSize) {
        if (partitionSize <= 0) {
          throw new Error("need partitionSize > 0");
        }
        var seq = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var buffer,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              item,
              $__10;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  buffer = [];
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  $ctx.state = 34;
                  break;
                case 34:
                  $ctx.pushTry(15, 16);
                  $ctx.state = 18;
                  break;
                case 18:
                  $__5 = void 0, $__4 = (seq)[Symbol.iterator]();
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (!($__7 = ($__5 = $__4.next()).done)) ? 10 : 12;
                  break;
                case 6:
                  $__7 = true;
                  $ctx.state = 14;
                  break;
                case 10:
                  item = $__5.value;
                  $ctx.state = 11;
                  break;
                case 11:
                  buffer.push(item);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (buffer.length >= partitionSize) ? 1 : 6;
                  break;
                case 1:
                  $ctx.state = 2;
                  return buffer;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  buffer = [];
                  $ctx.state = 6;
                  break;
                case 12:
                  $ctx.popTry();
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = 20;
                  break;
                case 15:
                  $ctx.popTry();
                  $ctx.maybeUncatchable();
                  $__10 = $ctx.storedException;
                  $ctx.state = 21;
                  break;
                case 21:
                  $__8 = true;
                  $__9 = $__10;
                  $ctx.state = 16;
                  $ctx.finallyFallThrough = 20;
                  break;
                case 16:
                  $ctx.popTry();
                  $ctx.state = 27;
                  break;
                case 27:
                  try {
                    if (!$__7 && $__4.return != null) {
                      $__4.return();
                    }
                  } finally {
                    if ($__8) {
                      throw $__9;
                    }
                  }
                  $ctx.state = 25;
                  break;
                case 20:
                  $ctx.state = (buffer.length > 0) ? 28 : -2;
                  break;
                case 28:
                  $ctx.state = 29;
                  return buffer;
                case 29:
                  $ctx.maybeThrow();
                  $ctx.state = -2;
                  break;
                case 25:
                  $ctx.state = $ctx.finallyFallThrough;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      stride: function(stepSize) {
        return this.filterWithIndex(function(e, i) {
          return i % stepSize === 0;
        });
      },
      breadthFirstSearch: function(neighborSelector) {
        var keySelector = arguments[1] !== (void 0) ? arguments[1] : function(e) {
          return e;
        };
        var seq = this;
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var visited,
              schedule,
              i,
              e,
              k,
              $__7,
              $__8,
              $__9,
              $__5,
              $__4,
              neighbor;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  visited = new Set();
                  schedule = seq.toArray();
                  $ctx.state = 16;
                  break;
                case 16:
                  i = 0;
                  $ctx.state = 14;
                  break;
                case 14:
                  $ctx.state = (i < schedule.length) ? 8 : -2;
                  break;
                case 7:
                  i++;
                  $ctx.state = 14;
                  break;
                case 8:
                  e = schedule[i];
                  k = keySelector(e);
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (visited.has(k)) ? 7 : 2;
                  break;
                case 2:
                  visited.add(k);
                  $__7 = true;
                  $__8 = false;
                  $__9 = undefined;
                  try {
                    for ($__5 = void 0, $__4 = (neighborSelector(e))[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
                      neighbor = $__5.value;
                      {
                        schedule.push(neighbor);
                      }
                    }
                  } catch ($__10) {
                    $__8 = true;
                    $__9 = $__10;
                  } finally {
                    try {
                      if (!$__7 && $__4.return != null) {
                        $__4.return();
                      }
                    } finally {
                      if ($__8) {
                        throw $__9;
                      }
                    }
                  }
                  $ctx.state = 11;
                  break;
                case 11:
                  $ctx.state = 5;
                  return e;
                case 5:
                  $ctx.maybeThrow();
                  $ctx.state = 7;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      }
    }, {
      fromGenerator: function(generatorFunction) {
        return new Seq(generatorFunction, true);
      },
      range: function(count) {
        if (!Number.isInteger(count) || count < 0) {
          throw new DetailedError("bad count", {count: count});
        }
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $ctx.state = 7;
                  break;
                case 7:
                  $ctx.state = (i < count) ? 1 : -2;
                  break;
                case 4:
                  i++;
                  $ctx.state = 7;
                  break;
                case 1:
                  $ctx.state = 2;
                  return i;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      naturals: function() {
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $ctx.state = 9;
                  break;
                case 9:
                  $ctx.state = (true) ? 1 : -2;
                  break;
                case 1:
                  $ctx.state = 2;
                  return i;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                case 4:
                  i++;
                  $ctx.state = 9;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      },
      repeat: function(item, repeatCount) {
        if (repeatCount < 0) {
          throw new Error("needed repeatCount >= 0");
        }
        return Seq.fromGenerator($traceurRuntime.initGeneratorFunction(function $__12() {
          var i;
          return $traceurRuntime.createGeneratorInstance(function($ctx) {
            while (true)
              switch ($ctx.state) {
                case 0:
                  i = 0;
                  $ctx.state = 7;
                  break;
                case 7:
                  $ctx.state = (i < repeatCount) ? 1 : -2;
                  break;
                case 4:
                  i++;
                  $ctx.state = 7;
                  break;
                case 1:
                  $ctx.state = 2;
                  return item;
                case 2:
                  $ctx.maybeThrow();
                  $ctx.state = 4;
                  break;
                default:
                  return $ctx.end();
              }
          }, $__12, this);
        }));
      }
    });
  }();
  var seq = function(iterable) {
    return new Seq(iterable);
  };
  return {
    get THROW_IF_EMPTY() {
      return THROW_IF_EMPTY;
    },
    get seq() {
      return seq;
    },
    get Seq() {
      return Seq;
    }
  };
});
//# sourceURL=src/base/Seq.js
;$traceurRuntime.registerModule("src/base/Util.js", [], function() {
  "use strict";
  var __moduleName = "src/base/Util.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/base/Util.js")).DetailedError;
  var Util = function() {
    function Util() {}
    return ($traceurRuntime.createClass)(Util, {}, {
      need: function(expression, message, args) {
        if (expression !== true) {
          var argDesc = args === undefined ? "(not provided)" : ("[" + Array.prototype.slice.call(args).join(", ") + "]");
          var msgDesc = message === undefined ? "(not provided)" : message;
          var msg = "Precondition failed" + "\n\nMessage: " + msgDesc + "\n\nArgs: " + argDesc;
          throw new Error(msg);
        }
      },
      numberOfSetBits: function(i) {
        if (i < 0) {
          throw new Error("i < 0");
        }
        if (!Number.isInteger(i)) {
          throw new Error("!Number.isInteger(i)");
        }
        if (i > 0xFFFFFFFF) {
          throw new Error("i > 0xFFFFFFFF");
        }
        i = (i & 0x55555555) + ((i >> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
        i = (i + (i >> 4)) & 0x0F0F0F0F;
        i += i >> 8;
        i += i >> 16;
        return i & 0xFF;
      },
      bin: function(number, fixedLen) {
        return ("0".repeat(fixedLen) + number.toString(2)).slice(-fixedLen).split("").join("");
      },
      notNull: function(v) {
        Util.need(v !== null, "notNull");
        return v;
      },
      isPowerOf2: function(i) {
        return i > 0 && ((i - 1) & i) === 0;
      },
      bitSize: function(n) {
        Util.need(n >= 0, "bitSize: n >= 0");
        if (n === 0) {
          return 0;
        }
        return Util.floorLg2(n) + 1;
      },
      ceilingPowerOf2: function(n) {
        if (n <= 1) {
          return 1;
        }
        return 1 << Util.ceilLg2(n);
      },
      ceilLg2: function(n) {
        if (n <= 1) {
          return 0;
        }
        var p = Math.ceil(Math.log2(n));
        if (1 << p < n) {
          return p + 1;
        }
        if (n <= 1 << (p - 1)) {
          return p - 1;
        }
        return p;
      },
      floorLg2: function(n) {
        if (n <= 1) {
          return 0;
        }
        var p = Math.floor(Math.log2(n));
        if (1 << (p + 1) <= n) {
          return p + 1;
        }
        if (n < 1 << p) {
          return p - 1;
        }
        return p;
      },
      powerOfTwoness: function(i) {
        if (i === 0) {
          return Math.POSITIVE_INFINITY;
        }
        if (i < 0) {
          return Util.powerOfTwoness(-i);
        }
        var lowMask = i ^ (i - 1);
        var lowBit = i & lowMask;
        return Math.round(Math.log2(lowBit));
      },
      reverseGroupMap: function(groupMap) {
        var $__25,
            $__26;
        var includeGroupsForOriginalKeysEvenIfEmpty = arguments[1] !== (void 0) ? arguments[1] : false;
        var result = new Map();
        if (includeGroupsForOriginalKeysEvenIfEmpty) {
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (groupMap.keys())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var e = $__3.value;
              {
                result.set(e, []);
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        }
        var $__19 = true;
        var $__20 = false;
        var $__21 = undefined;
        try {
          for (var $__17 = void 0,
              $__16 = (groupMap)[Symbol.iterator](); !($__19 = ($__17 = $__16.next()).done); $__19 = true) {
            var $__24 = $__17.value,
                k = ($__25 = $__24[Symbol.iterator](), ($__26 = $__25.next()).done ? void 0 : $__26.value),
                g = ($__26 = $__25.next()).done ? void 0 : $__26.value;
            {
              var $__12 = true;
              var $__13 = false;
              var $__14 = undefined;
              try {
                for (var $__10 = void 0,
                    $__9 = (g)[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
                  var e$__33 = $__10.value;
                  {
                    if (!result.has(e$__33)) {
                      result.set(e$__33, []);
                    }
                    result.get(e$__33).push(k);
                  }
                }
              } catch ($__15) {
                $__13 = true;
                $__14 = $__15;
              } finally {
                try {
                  if (!$__12 && $__9.return != null) {
                    $__9.return();
                  }
                } finally {
                  if ($__13) {
                    throw $__14;
                  }
                }
              }
            }
          }
        } catch ($__22) {
          $__20 = true;
          $__21 = $__22;
        } finally {
          try {
            if (!$__19 && $__16.return != null) {
              $__16.return();
            }
          } finally {
            if ($__20) {
              throw $__21;
            }
          }
        }
        return result;
      },
      binarySearchForTransitionFromTrueToFalse: function(max, argIsBeforeTransitionFunc) {
        var min = 0;
        while (max > min) {
          var med = min + Math.floor((max - min) / 2);
          if (argIsBeforeTransitionFunc(med)) {
            min = med + 1;
          } else {
            max = med;
          }
        }
        return min;
      },
      breakLine: function(text, maxWidth, measureWidth) {
        if (text === "") {
          return [""];
        }
        var lines = [];
        var p = 0;
        while (p < text.length) {
          var maxKeepLength = Util.binarySearchForTransitionFromTrueToFalse(text.length - p + 1, function(i) {
            return measureWidth(text.substr(p, i)) <= maxWidth;
          }) - 1;
          maxKeepLength = Math.max(1, maxKeepLength);
          var maxChunk = text.substr(p, maxKeepLength);
          var hitBoundary = p + maxKeepLength === text.length || text.substr(p + maxKeepLength, 1).match(/\s/) !== null;
          if (!hitBoundary) {
            var niceRegex = /^(.*\S)(\s+)\S*$/;
            var niceChunkMatch = niceRegex.exec(maxChunk);
            if (niceChunkMatch !== null) {
              var keepChunk = niceChunkMatch[1];
              var skipChunk = niceChunkMatch[2];
              lines.push(keepChunk.trim());
              p += keepChunk.length + skipChunk.length;
              continue;
            }
          }
          lines.push(maxChunk.trim());
          p += maxChunk.length;
          p += text.substr(p).match(/^\s*/)[0].length;
        }
        return lines;
      },
      decomposeObjectValues: function(object) {
        var result = [];
        var decomposeValueOrArray;
        decomposeValueOrArray = function(val) {
          if (Array.isArray(val)) {
            var $__5 = true;
            var $__6 = false;
            var $__7 = undefined;
            try {
              for (var $__3 = void 0,
                  $__2 = (val)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                var item = $__3.value;
                {
                  decomposeValueOrArray(item);
                }
              }
            } catch ($__8) {
              $__6 = true;
              $__7 = $__8;
            } finally {
              try {
                if (!$__5 && $__2.return != null) {
                  $__2.return();
                }
              } finally {
                if ($__6) {
                  throw $__7;
                }
              }
            }
          } else {
            result.push(val);
          }
        };
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (Object.keys(object).sort())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              decomposeValueOrArray(object[key], result);
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return result;
      },
      recomposedObjectValues: function(originalObject, newFieldValues) {
        var result = {};
        var i = 0;
        var recomposeValueOrArray;
        recomposeValueOrArray = function(originalVal) {
          if (Array.isArray(originalVal)) {
            var arr = [];
            var $__5 = true;
            var $__6 = false;
            var $__7 = undefined;
            try {
              for (var $__3 = void 0,
                  $__2 = (originalVal)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                var item = $__3.value;
                {
                  arr.push(recomposeValueOrArray(item));
                }
              }
            } catch ($__8) {
              $__6 = true;
              $__7 = $__8;
            } finally {
              try {
                if (!$__5 && $__2.return != null) {
                  $__2.return();
                }
              } finally {
                if ($__6) {
                  throw $__7;
                }
              }
            }
            return arr;
          }
          return newFieldValues[i++];
        };
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (Object.keys(originalObject).sort())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              result[key] = recomposeValueOrArray(originalObject[key]);
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        Util.need(i === newFieldValues.length, "Mismatched field value count.");
        return result;
      },
      objectifyArrayFunc: function(func) {
        return function(arg) {
          return Util.recomposedObjectValues(arg, func(Util.decomposeObjectValues(arg)));
        };
      },
      snappedCosSin: function(radians) {
        var unit = Math.PI / 4;
        var i = Math.round(radians / unit);
        if (i * unit === radians) {
          var s = Math.sqrt(0.5);
          var snaps = [[1, 0], [s, s], [0, 1], [-s, s], [-1, 0], [-s, -s], [0, -1], [s, -s]];
          return snaps[i & 7];
        }
        return [Math.cos(radians), Math.sin(radians)];
      },
      properMod: function(numerator, denominator) {
        if (denominator <= 0) {
          throw new DetailedError("denominator <= 0", {
            numerator: numerator,
            denominator: denominator
          });
        }
        var result = numerator % denominator;
        return result + (result < 0 ? denominator : 0);
      },
      mergeMaps: function() {
        var $__25,
            $__26;
        for (var maps = [],
            $__23 = 0; $__23 < arguments.length; $__23++)
          maps[$__23] = arguments[$__23];
        var result = new Map();
        var $__12 = true;
        var $__13 = false;
        var $__14 = undefined;
        try {
          for (var $__10 = void 0,
              $__9 = (maps)[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
            var map = $__10.value;
            {
              var $__5 = true;
              var $__6 = false;
              var $__7 = undefined;
              try {
                for (var $__3 = void 0,
                    $__2 = (map.entries())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                  var $__24 = $__3.value,
                      key = ($__25 = $__24[Symbol.iterator](), ($__26 = $__25.next()).done ? void 0 : $__26.value),
                      val = ($__26 = $__25.next()).done ? void 0 : $__26.value;
                  {
                    result.set(key, val);
                  }
                }
              } catch ($__8) {
                $__6 = true;
                $__7 = $__8;
              } finally {
                try {
                  if (!$__5 && $__2.return != null) {
                    $__2.return();
                  }
                } finally {
                  if ($__6) {
                    throw $__7;
                  }
                }
              }
            }
          }
        } catch ($__15) {
          $__13 = true;
          $__14 = $__15;
        } finally {
          try {
            if (!$__12 && $__9.return != null) {
              $__9.return();
            }
          } finally {
            if ($__13) {
              throw $__14;
            }
          }
        }
        return result;
      },
      modular_multiplicative_inverse: function(value, modulus) {
        var $__24 = Util.extended_gcd(value, modulus),
            x = $__24.x,
            gcd = $__24.gcd;
        if (gcd !== 1) {
          return undefined;
        }
        x %= modulus;
        if (x < 0) {
          x += modulus;
        }
        return x;
      },
      extended_gcd: function(a, b) {
        var $__24,
            $__25,
            $__26,
            $__27,
            $__28,
            $__29,
            $__30,
            $__31,
            $__32;
        var s = 0;
        var t = 1;
        var r = b;
        var old_s = 1;
        var old_t = 0;
        var old_r = a;
        while (r !== 0) {
          var q = Math.floor(old_r / r);
          ($__24 = [r, old_r - q * r], old_r = ($__25 = $__24[Symbol.iterator](), ($__26 = $__25.next()).done ? void 0 : $__26.value), r = ($__26 = $__25.next()).done ? void 0 : $__26.value, $__24);
          ($__27 = [s, old_s - q * s], old_s = ($__28 = $__27[Symbol.iterator](), ($__29 = $__28.next()).done ? void 0 : $__29.value), s = ($__29 = $__28.next()).done ? void 0 : $__29.value, $__27);
          ($__30 = [t, old_t - q * t], old_t = ($__31 = $__30[Symbol.iterator](), ($__32 = $__31.next()).done ? void 0 : $__32.value), t = ($__32 = $__31.next()).done ? void 0 : $__32.value, $__30);
        }
        return {
          x: old_s,
          y: old_t,
          gcd: old_r
        };
      },
      digits_to_superscript_digits: function(text) {
        var digits = "0123456789";
        var superscript_digits = "⁰¹²³⁴⁵⁶⁷⁸⁹";
        for (var i = 0; i < 10; i++) {
          text = text.split(digits[i]).join(superscript_digits[i]);
        }
        return text;
      }
    });
  }();
  Util.STRICT_EQUALITY = function(e1, e2) {
    return e1 === e2;
  };
  Util.CUSTOM_IS_EQUAL_TO_EQUALITY = function(e1, e2) {
    return e1 === null ? e2 === null : e1 === undefined ? e2 === undefined : e1.isEqualTo(e2);
  };
  return {get Util() {
      return Util;
    }};
});
//# sourceURL=src/base/Util.js
;$traceurRuntime.registerModule("src/browser/Clipboard.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/Clipboard.js";
  function selectAndCopyToClipboard(element) {
    if (document.selection) {
      var range = document.body.createTextRange();
      range.moveToElementText(element);
      range.select();
    } else if (window.getSelection) {
      var range$__0 = document.createRange();
      range$__0.selectNodeContents(element);
      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range$__0);
    }
    if (!document.execCommand('copy')) {
      throw new Error("execCommand failed");
    }
  }
  return {get selectAndCopyToClipboard() {
      return selectAndCopyToClipboard;
    }};
});
//# sourceURL=src/browser/Clipboard.js
;$traceurRuntime.registerModule("src/browser/EventUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/EventUtil.js";
  var Observable = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Obs.js", "src/browser/EventUtil.js")).Observable;
  function textEditObservable(textBox) {
    return Observable.of(Observable.elementEvent(textBox, 'change'), Observable.elementEvent(textBox, 'keyup'), Observable.elementEvent(textBox, 'click'), Observable.elementEvent(textBox, 'paste'), Observable.elementEvent(textBox, 'input')).flatten().map(function(e) {
      return textBox.value;
    }).whenDifferent();
  }
  return {get textEditObservable() {
      return textEditObservable;
    }};
});
//# sourceURL=src/browser/EventUtil.js
;$traceurRuntime.registerModule("src/browser/HistoryPusher.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/HistoryPusher.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/browser/HistoryPusher.js")).DetailedError;
  var HistoryPusher = function() {
    function HistoryPusher() {
      this._historyActionsNotWorking = false;
      this._currentMemorableStateObj = undefined;
    }
    return ($traceurRuntime.createClass)(HistoryPusher, {
      currentStateIsMemorableButUnknown: function() {
        this._currentMemorableStateObj = {wont_equal_this: true};
      },
      currentStateIsMemorableAndEqualTo: function(stateObj) {
        this._currentMemorableStateObj = stateObj;
      },
      currentStateIsNotMemorable: function() {
        this._currentMemorableStateObj = undefined;
      },
      stateChange: function(stateObj, stateUrlHash) {
        if (!stateUrlHash.startsWith('#')) {
          throw new DetailedError("Expected a hash URL.", {
            stateObj: stateObj,
            stateUrlHash: stateUrlHash
          });
        }
        if (this._currentMemorableStateObj === stateObj) {
          return;
        }
        if (this._historyActionsNotWorking) {
          document.location.hash = stateUrlHash;
          return;
        }
        try {
          if (this._currentMemorableStateObj === undefined) {
            history.replaceState(stateObj, "", stateUrlHash);
          } else {
            history.pushState(stateObj, "", stateUrlHash);
            this._currentMemorableStateObj = undefined;
          }
        } catch (ex) {
          console.warn("Calling 'history.replaceState/pushState' failed. Falling back to setting location.hash.", ex);
          this._historyActionsNotWorking = true;
          document.location.hash = stateUrlHash;
        }
      }
    }, {});
  }();
  return {get HistoryPusher() {
      return HistoryPusher;
    }};
});
//# sourceURL=src/browser/HistoryPusher.js
;$traceurRuntime.registerModule("src/browser/MouseWatcher.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/MouseWatcher.js";
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/browser/MouseWatcher.js")).Point;
  var ALLOW_REGRAB_WATCHDOG_TIME_MS = 5000;
  var MOUSE_ID = "mouse!";
  var isLeftClicking = function(ev) {
    return (window.TouchEvent !== undefined && ev instanceof TouchEvent) || ev.which === 1;
  };
  var isMiddleClicking = function(ev) {
    return ev.which === 2;
  };
  function eventPosRelativeTo(ev, element) {
    var b = element.getBoundingClientRect();
    return new Point(ev.clientX - b.left, ev.clientY - b.top);
  }
  function watchDrags(element, grabHandler, cancelHandler, dragHandler, dropHandler) {
    return new DragWatcher(element, grabHandler, cancelHandler, dragHandler, dropHandler).addListenersUntilResultInvoked();
  }
  var addListenerUntilResultInvoked = function(target, type, listener) {
    target.addEventListener(type, listener);
    return function() {
      return target.removeEventListener(type, listener);
    };
  };
  var DragWatcher = function() {
    function DragWatcher(element, grabHandler, cancelHandler, dragHandler, dropHandler) {
      this._element = element;
      this._grabHandler = grabHandler;
      this._cancelHandler = cancelHandler;
      this._dragHandler = dragHandler;
      this._dropHandler = dropHandler;
      this._grabPointerId = undefined;
      this._grabActivityTime = window.performance.now();
      this._lastPos = undefined;
      this._lastEv = undefined;
    }
    return ($traceurRuntime.createClass)(DragWatcher, {
      addListenersUntilResultInvoked: function() {
        var $__1 = this;
        var e = this._element;
        var unregCalls = [addListenerUntilResultInvoked(e, 'mousedown', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onDown);
        }), addListenerUntilResultInvoked(document, 'mousemove', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onMove);
        }), addListenerUntilResultInvoked(document, 'mouseup', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onUp);
        }), addListenerUntilResultInvoked(document, 'mouseleave', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onLeave);
        }), addListenerUntilResultInvoked(document, 'mouseenter', function(ev) {
          return $__1.handleMouseEventWith(ev, $__1.onEnter);
        }), addListenerUntilResultInvoked(e, 'touchstart', function(ev) {
          return $__1.handleTouchEventWith(ev, $__1.onDown);
        }), addListenerUntilResultInvoked(e, 'touchmove', function(ev) {
          return $__1.handleTouchEventWith(ev, $__1.onMove);
        }), addListenerUntilResultInvoked(e, 'touchend', function(ev) {
          return $__1.handleTouchEventWith(ev, $__1.onUp);
        }), addListenerUntilResultInvoked(e, 'touchcancel', function(ev) {
          return $__1.handleTouchEventWith(ev, $__1.onCancel);
        })];
        return function() {
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (unregCalls)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var unregCall = $__3.value;
              {
                unregCall();
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        };
      },
      canRegrab: function() {
        return window.performance.now() >= this._grabActivityTime + ALLOW_REGRAB_WATCHDOG_TIME_MS;
      },
      onDown: function(pt, id, ev) {
        if (!isLeftClicking(ev)) {
          return;
        }
        if (this._grabPointerId !== undefined) {
          if (!this.canRegrab()) {
            return;
          }
          this._dropHandler(this._lastPos, this._lastEv);
        }
        this._grabPointerId = id;
        this._grabActivityTime = window.performance.now();
        this._lastPos = pt;
        this._lastEv = ev;
        this._grabHandler(pt, ev);
      },
      onMove: function(pt, id, ev) {
        if (this._grabPointerId !== id) {
          return;
        }
        if (!isLeftClicking(ev)) {
          this._lastPos = undefined;
          this._lastEv = undefined;
          this._grabPointerId = undefined;
          this._dropHandler(undefined, ev);
          return;
        }
        this._grabActivityTime = window.performance.now();
        this._lastPos = pt;
        this._lastEv = ev;
        this._dragHandler(pt, ev);
      },
      onCancel: function(pt, id, ev) {
        if (this._grabPointerId !== id) {
          return;
        }
        this._lastPos = undefined;
        this._lastEv = undefined;
        this._grabPointerId = undefined;
        this._cancelHandler(ev);
      },
      onUp: function(pt, id, ev) {
        if (!isLeftClicking(ev) || this._grabPointerId !== id) {
          return;
        }
        this._lastPos = undefined;
        this._lastEv = undefined;
        this._grabPointerId = undefined;
        this._dropHandler(pt, ev);
      },
      onLeave: function(pt, id, ev) {
        if (!isLeftClicking(ev) || this._grabPointerId !== id) {
          return;
        }
        this._grabActivityTime = window.performance.now();
        this._lastPos = undefined;
        this._lastEv = ev;
        this._dragHandler(undefined, ev);
      },
      onEnter: function(pt, id, ev) {
        if (isLeftClicking(ev) || this._grabPointerId !== id) {
          return;
        }
        this._lastPos = undefined;
        this._lastEv = undefined;
        this._grabPointerId = undefined;
        this._dropHandler(undefined, ev);
      },
      relativeEventPos: function(ev) {
        return eventPosRelativeTo(ev, this._element);
      },
      handleTouchEventWith: function(ev, handler) {
        for (var i = 0; i < ev.changedTouches.length; i++) {
          var touch = ev.changedTouches[i];
          handler.call(this, this.relativeEventPos(touch), touch.identifier, ev);
        }
      },
      handleMouseEventWith: function(ev, handler) {
        handler.call(this, this.relativeEventPos(ev), MOUSE_ID, ev);
      }
    }, {});
  }();
  return {
    get watchDrags() {
      return watchDrags;
    },
    get isLeftClicking() {
      return isLeftClicking;
    },
    get isMiddleClicking() {
      return isMiddleClicking;
    },
    get eventPosRelativeTo() {
      return eventPosRelativeTo;
    }
  };
});
//# sourceURL=src/browser/MouseWatcher.js
;$traceurRuntime.registerModule("src/browser/Polyfills.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/Polyfills.js";
  Float32Array.prototype.slice = Float32Array.prototype.slice || function(a, b) {
    return new Float32Array(Array.from(this).slice(a, b));
  };
  Float64Array.prototype.slice = Float64Array.prototype.slice || function(a, b) {
    return new Float64Array(Array.from(this).slice(a, b));
  };
  Uint32Array.prototype.slice = Uint32Array.prototype.slice || function(a, b) {
    return new Uint32Array(Array.from(this).slice(a, b));
  };
  Int32Array.prototype.slice = Int32Array.prototype.slice || function(a, b) {
    return new Int32Array(Array.from(this).slice(a, b));
  };
  Uint16Array.prototype.slice = Uint16Array.prototype.slice || function(a, b) {
    return new Uint16Array(Array.from(this).slice(a, b));
  };
  Int16Array.prototype.slice = Int16Array.prototype.slice || function(a, b) {
    return new Int16Array(Array.from(this).slice(a, b));
  };
  Uint8Array.prototype.slice = Uint8Array.prototype.slice || function(a, b) {
    return new Uint8Array(Array.from(this).slice(a, b));
  };
  Int8Array.prototype.slice = Int8Array.prototype.slice || function(a, b) {
    return new Int8Array(Array.from(this).slice(a, b));
  };
  var ARRAY_ITER = function() {
    var self = this;
    return $traceurRuntime.initGeneratorFunction(function $__8() {
      var i;
      return $traceurRuntime.createGeneratorInstance(function($ctx) {
        while (true)
          switch ($ctx.state) {
            case 0:
              i = 0;
              $ctx.state = 7;
              break;
            case 7:
              $ctx.state = (i < self.length) ? 1 : -2;
              break;
            case 4:
              i++;
              $ctx.state = 7;
              break;
            case 1:
              $ctx.state = 2;
              return self[i];
            case 2:
              $ctx.maybeThrow();
              $ctx.state = 4;
              break;
            default:
              return $ctx.end();
          }
      }, $__8, this);
    })();
  };
  Float32Array.prototype[Symbol.iterator] = Float32Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Float64Array.prototype[Symbol.iterator] = Float64Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Uint32Array.prototype[Symbol.iterator] = Uint32Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Uint16Array.prototype[Symbol.iterator] = Uint16Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Uint8Array.prototype[Symbol.iterator] = Uint8Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Int32Array.prototype[Symbol.iterator] = Int32Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Int16Array.prototype[Symbol.iterator] = Int16Array.prototype[Symbol.iterator] || ARRAY_ITER;
  Int8Array.prototype[Symbol.iterator] = Int8Array.prototype[Symbol.iterator] || ARRAY_ITER;
  window.performance = window.performance || {};
  window.performance.now = window.performance.now || (function() {
    return Date.now();
  });
  var GL = WebGLRenderingContext;
  if (GL !== undefined && GL.INVALID_ENUM === undefined) {
    var keys = ['ARRAY_BUFFER', 'CLAMP_TO_EDGE', 'COLOR_ATTACHMENT0', 'COMPILE_STATUS', 'ELEMENT_ARRAY_BUFFER', 'FLOAT', 'FRAGMENT_SHADER', 'FRAMEBUFFER', 'FRAMEBUFFER_COMPLETE', 'HIGH_FLOAT', 'LINK_STATUS', 'MAX_TEXTURE_IMAGE_UNITS', 'MAX_TEXTURE_SIZE', 'MEDIUM_FLOAT', 'NEAREST', 'NO_ERROR', 'RGBA', 'STATIC_DRAW', 'TEXTURE_2D', 'TEXTURE_MAG_FILTER', 'TEXTURE_MIN_FILTER', 'TEXTURE_WRAP_S', 'TEXTURE_WRAP_T', 'TEXTURE0', 'TRIANGLES', 'UNSIGNED_SHORT', 'UNSIGNED_BYTE', 'VALIDATE_STATUS', 'VERTEX_SHADER'];
    var gl = document.createElement('canvas').getContext('webgl');
    if (gl !== null && gl !== undefined) {
      var $__4 = true;
      var $__5 = false;
      var $__6 = undefined;
      try {
        for (var $__2 = void 0,
            $__1 = (keys)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
          var key = $__2.value;
          {
            GL[key] = GL[key] || gl[key];
          }
        }
      } catch ($__7) {
        $__5 = true;
        $__6 = $__7;
      } finally {
        try {
          if (!$__4 && $__1.return != null) {
            $__1.return();
          }
        } finally {
          if ($__5) {
            throw $__6;
          }
        }
      }
    }
  }
  return {};
});
//# sourceURL=src/browser/Polyfills.js
;$traceurRuntime.registerModule("src/browser/SaveFile.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/SaveFile.js";
  function saveFile(name, content) {
    if (navigator.msSaveBlob) {
      navigator.msSaveBlob(new Blob([content], {type: 'text/html;charset=UTF-8'}), name);
      return;
    }
    var anchor = document.createElement("a");
    anchor.href = window.URL !== undefined ? window.URL.createObjectURL(new Blob([content], {type: 'text/html;charset=UTF-8'})) : 'data:application/octet-stream,' + encodeURI(moddedHtml);
    anchor.download = name;
    try {
      document.body.appendChild(anchor);
      anchor.click();
    } finally {
      document.body.removeChild(anchor);
    }
  }
  return {get saveFile() {
      return saveFile;
    }};
});
//# sourceURL=src/browser/SaveFile.js
;$traceurRuntime.registerModule("src/browser/TouchScrollBlocker.js", [], function() {
  "use strict";
  var __moduleName = "src/browser/TouchScrollBlocker.js";
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/browser/TouchScrollBlocker.js")).Rect;
  var TouchScrollBlocker = function() {
    function TouchScrollBlocker(parentElement) {
      this._parentElement = parentElement;
      this._curBlockers = [];
      this._curShowing = 0;
    }
    return ($traceurRuntime.createClass)(TouchScrollBlocker, {setBlockers: function(desiredBlockers, overrideCursorStyle) {
        while (this._curBlockers.length < desiredBlockers.length) {
          var blockerDiv = document.createElement('div');
          blockerDiv.style.touchAction = 'none';
          blockerDiv.style.position = 'absolute';
          blockerDiv.style.opacity = 0.0001;
          this._parentElement.appendChild(blockerDiv);
          this._curBlockers.push({
            div: blockerDiv,
            area: undefined
          });
        }
        for (var i = 0; i < desiredBlockers.length; i++) {
          var desiredArea = desiredBlockers[i].rect;
          var desiredCursor = overrideCursorStyle || desiredBlockers[i].cursor || 'auto';
          var cur = this._curBlockers[i];
          var style = cur.div.style;
          if (!desiredArea.isEqualTo(cur.area)) {
            cur.area = desiredArea;
            style.left = desiredArea.x + "px";
            style.top = desiredArea.y + "px";
            style.width = desiredArea.w + "px";
            style.height = desiredArea.h + "px";
          }
          if (style.cursor !== desiredCursor) {
            style.cursor = desiredCursor;
          }
        }
        while (this._curShowing < desiredBlockers.length) {
          this._curBlockers[this._curShowing].div.style.display = 'inline';
          this._curShowing++;
        }
        while (this._curShowing > desiredBlockers.length) {
          this._curShowing--;
          this._curBlockers[this._curShowing].div.style.display = 'none';
        }
      }}, {});
  }();
  return {get TouchScrollBlocker() {
      return TouchScrollBlocker;
    }};
});
//# sourceURL=src/browser/TouchScrollBlocker.js
;$traceurRuntime.registerModule("src/circuit/CircuitComputeUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitComputeUtil.js";
  var CircuitEvalContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitEvalContext.js", "src/circuit/CircuitComputeUtil.js")).CircuitEvalContext;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitShaders.js", "src/circuit/CircuitComputeUtil.js")).CircuitShaders;
  var KetTextureUtil = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetTextureUtil.js", "src/circuit/CircuitComputeUtil.js")).KetTextureUtil;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Controls.js", "src/circuit/CircuitComputeUtil.js")).Controls;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/circuit/CircuitComputeUtil.js")).GateBuilder;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/AllGates.js", "src/circuit/CircuitComputeUtil.js")).Gates;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/CircuitComputeUtil.js")).Util;
  function setGateBuilderEffectToCircuit(builder, circuitDefinition) {
    return builder.setActualEffectToUpdateFunc(function(ctx) {
      return advanceStateWithCircuit(ctx, circuitDefinition.withDisabledReasonsForEmbeddedContext(ctx.row, ctx.customContextFromGates), false);
    }).setKnownEffectToCircuit(circuitDefinition).setExtraDisableReasonFinder(function(args) {
      var def = circuitDefinition.withDisabledReasonsForEmbeddedContext(args.outerRow, args.context);
      for (var row = 0; row < def.numWires; row++) {
        for (var col = 0; col < def.columns.length; col++) {
          var r = def.gateAtLocIsDisabledReason(col, row);
          if (r !== undefined) {
            return r;
          }
          if (def.gateInSlot(col, row) === Gates.Special.Measurement) {
            return "hidden\nmeasure\nbroken";
          }
        }
      }
      return undefined;
    });
  }
  function advanceStateWithCircuit(ctx, circuitDefinition, collectStats) {
    var colQubitDensities = [];
    var customStats = [];
    var colNorms = [];
    var customStatsMap = [];
    var statsCallback = function(col) {
      return function(statArgs) {
        if (!collectStats) {
          return;
        }
        var $__8 = _extractStateStatsNeededByCircuitColumn(statArgs, circuitDefinition, col),
            qubitDensities = $__8.qubitDensities,
            norm = $__8.norm,
            customGateStats = $__8.customGateStats;
        colQubitDensities.push(qubitDensities);
        colNorms.push(norm);
        var $__4 = true;
        var $__5 = false;
        var $__6 = undefined;
        try {
          for (var $__2 = void 0,
              $__1 = (customGateStats)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
            var $__9 = $__2.value,
                row = $__9.row,
                stat = $__9.stat;
            {
              customStatsMap.push({
                col: col,
                row: row,
                out: customStats.length
              });
              customStats.push(stat);
            }
          }
        } catch ($__7) {
          $__5 = true;
          $__6 = $__7;
        } finally {
          try {
            if (!$__4 && $__1.return != null) {
              $__1.return();
            }
          } finally {
            if ($__5) {
              throw $__6;
            }
          }
        }
      };
    };
    for (var col = 0; col < circuitDefinition.columns.length; col++) {
      _advanceStateWithCircuitDefinitionColumn(ctx, circuitDefinition, col, statsCallback(col));
    }
    if (collectStats) {
      var allWiresMask = (1 << circuitDefinition.numWires) - 1;
      colQubitDensities.push(KetTextureUtil.superpositionToQubitDensities(ctx.stateTrader.currentTexture, Controls.NONE, allWiresMask));
    }
    return {
      colQubitDensities: colQubitDensities,
      colNorms: colNorms,
      customStats: customStats,
      customStatsMap: customStatsMap
    };
  }
  function _extractStateStatsNeededByCircuitColumn(ctx, circuitDefinition, col) {
    var customGateStats = [];
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (circuitDefinition.customStatRowsInCol(col))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var row = $__2.value;
        {
          var statCtx = new CircuitEvalContext(ctx.time, row, circuitDefinition.numWires, ctx.controls, ctx.controlsTexture, ctx.stateTrader, Util.mergeMaps(ctx.customContextFromGates, circuitDefinition.colCustomContextFromGates(col, row)));
          var stat = circuitDefinition.columns[col].gates[row].customStatTexturesMaker(statCtx);
          customGateStats.push({
            row: row,
            stat: stat
          });
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var qubitDensities = KetTextureUtil.superpositionToQubitDensities(ctx.stateTrader.currentTexture, ctx.controls, circuitDefinition.colDesiredSingleQubitStatsMask(col));
    var normMayHaveChanged = circuitDefinition.columns[col].indexOfNonUnitaryGate() !== undefined;
    var norm = KetTextureUtil.superpositionToNorm(ctx.stateTrader.currentTexture, normMayHaveChanged);
    return {
      qubitDensities: qubitDensities,
      norm: norm,
      customGateStats: customGateStats
    };
  }
  function _advanceStateWithCircuitDefinitionColumn(ctx, circuitDefinition, col, statsCallback) {
    var controls = ctx.controls.and(circuitDefinition.colControls(col).shift(ctx.row));
    var controlTex = CircuitShaders.controlMask(controls).toBoolTexture(ctx.wireCount);
    var colContext = Util.mergeMaps(ctx.customContextFromGates, circuitDefinition.colCustomContextFromGates(col, ctx.row));
    var trader = ctx.stateTrader;
    var aroundCtx = new CircuitEvalContext(ctx.time, ctx.row, ctx.wireCount, ctx.controls, ctx.controlsTexture, trader, colContext);
    var mainCtx = new CircuitEvalContext(ctx.time, ctx.row, ctx.wireCount, controls, controlTex, trader, colContext);
    circuitDefinition.applyBeforeOperationsInCol(col, aroundCtx);
    circuitDefinition.applyMainOperationsInCol(col, mainCtx);
    statsCallback(mainCtx);
    circuitDefinition.applyAfterOperationsInCol(col, aroundCtx);
    controlTex.deallocByDepositingInPool("controlTex in _advanceStateWithCircuitDefinitionColumn");
  }
  return {
    get setGateBuilderEffectToCircuit() {
      return setGateBuilderEffectToCircuit;
    },
    get advanceStateWithCircuit() {
      return advanceStateWithCircuit;
    }
  };
});
//# sourceURL=src/circuit/CircuitComputeUtil.js
;$traceurRuntime.registerModule("src/circuit/CircuitDefinition.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitDefinition.js";
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitShaders.js", "src/circuit/CircuitDefinition.js")).CircuitShaders;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/circuit/CircuitDefinition.js")).Config;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Controls.js", "src/circuit/CircuitDefinition.js")).Controls;
  var CustomGateSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CustomGateSet.js", "src/circuit/CircuitDefinition.js")).CustomGateSet;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/CircuitDefinition.js")).DetailedError;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/circuit/CircuitDefinition.js")).Gate;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateColumn.js", "src/circuit/CircuitDefinition.js")).GateColumn;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateShaders.js", "src/circuit/CircuitDefinition.js")).GateShaders;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/AllGates.js", "src/circuit/CircuitDefinition.js")).Gates;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/circuit/CircuitDefinition.js")).Point;
  var $__40 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/circuit/CircuitDefinition.js")),
      seq = $__40.seq,
      Seq = $__40.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/CircuitDefinition.js")).Util;
  var CircuitDefinition = function() {
    function CircuitDefinition(numWires, columns) {
      var outerRowOffset = arguments[2] !== (void 0) ? arguments[2] : 0;
      var outerContext = arguments[3] !== (void 0) ? arguments[3] : new Map();
      var customGateSet = arguments[4] !== (void 0) ? arguments[4] : new CustomGateSet();
      var isNested = arguments[5] !== (void 0) ? arguments[5] : false;
      if (numWires < 0) {
        throw new DetailedError("Bad numWires", {numWires: numWires});
      }
      if (!Array.isArray(columns)) {
        throw new DetailedError("Bad columns", {
          numWires: numWires,
          columns: columns
        });
      }
      if (!columns.every(function(e) {
        return e instanceof GateColumn;
      })) {
        throw new DetailedError("Not a GateColumn", {columns: columns});
      }
      if (!columns.every(function(e) {
        return e.gates.length === numWires;
      })) {
        throw new DetailedError("Wrong gate count in a column", {
          numWires: numWires,
          columns: columns
        });
      }
      this.numWires = numWires;
      this.columns = columns;
      this.customGateSet = customGateSet;
      this.outerRowOffset = outerRowOffset;
      this.outerContext = outerContext;
      this.isNested = isNested;
      this._colRowDisabledReason = [];
      this._measureMasks = [0];
      var mask = 0;
      var prevStickyCtx = new Map();
      var $__6 = true;
      var $__7 = false;
      var $__8 = undefined;
      try {
        for (var $__4 = void 0,
            $__3 = (columns)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
          var col = $__4.value;
          {
            var $__17 = col.perRowDisabledReasons(mask, outerRowOffset, outerContext, prevStickyCtx, isNested),
                rowReasons = $__17.allReasons,
                stickyCtx = $__17.stickyCtx;
            mask = col.nextMeasureMask(mask, rowReasons);
            this._colRowDisabledReason.push(rowReasons);
            this._measureMasks.push(mask);
            prevStickyCtx = stickyCtx;
          }
        }
      } catch ($__9) {
        $__7 = true;
        $__8 = $__9;
      } finally {
        try {
          if (!$__6 && $__3.return != null) {
            $__3.return();
          }
        } finally {
          if ($__7) {
            throw $__8;
          }
        }
      }
      this._gateSlotCoverMap = this._computeGateSlotCoverMap();
      this._cachedColumnContexts = new Map();
    }
    return ($traceurRuntime.createClass)(CircuitDefinition, {
      gateWeight: function() {
        return seq(this.columns).flatMap(function(e) {
          return e.gates;
        }).filter(function(e) {
          return e !== undefined;
        }).map(function(e) {
          return e.knownCircuit === undefined ? 1 : e.knownCircuit.gateWeight();
        }).sum();
      },
      hasControls: function() {
        return !this.columns.every(function(e) {
          return !e.hasControl(-1);
        });
      },
      hasOnlyUnitaryGates: function() {
        return this.columns.every(function(e) {
          return e.indexOfNonUnitaryGate() === undefined;
        });
      },
      hasNonControlGates: function() {
        var colHasNonControl = function(col) {
          return !col.gates.every(function(e) {
            return e === undefined || e.isControl();
          });
        };
        return !this.columns.every(function(e) {
          return !colHasNonControl(e);
        });
      },
      countGatesUpTo: function(max) {
        var n = 0;
        var $__13 = true;
        var $__14 = false;
        var $__15 = undefined;
        try {
          for (var $__11 = void 0,
              $__10 = (this.columns)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
            var c = $__11.value;
            {
              var $__6 = true;
              var $__7 = false;
              var $__8 = undefined;
              try {
                for (var $__4 = void 0,
                    $__3 = (c.gates)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                  var g = $__4.value;
                  {
                    if (g !== undefined) {
                      n++;
                      if (n >= max) {
                        return n;
                      }
                    }
                  }
                }
              } catch ($__9) {
                $__7 = true;
                $__8 = $__9;
              } finally {
                try {
                  if (!$__6 && $__3.return != null) {
                    $__3.return();
                  }
                } finally {
                  if ($__7) {
                    throw $__8;
                  }
                }
              }
            }
          }
        } catch ($__16) {
          $__14 = true;
          $__15 = $__16;
        } finally {
          try {
            if (!$__13 && $__10.return != null) {
              $__10.return();
            }
          } finally {
            if ($__14) {
              throw $__15;
            }
          }
        }
        return n;
      },
      getUnmetContextKeys: function() {
        var result = new Set();
        for (var c = 0; c < this.columns.length; c++) {
          var col = this.columns[c];
          var ctx = this.colCustomContextFromGates(c, 0);
          var $__13 = true;
          var $__14 = false;
          var $__15 = undefined;
          try {
            for (var $__11 = void 0,
                $__10 = (col.gates)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
              var gate = $__11.value;
              {
                var $__6 = true;
                var $__7 = false;
                var $__8 = undefined;
                try {
                  for (var $__4 = void 0,
                      $__3 = (gate === undefined ? [] : gate.getUnmetContextKeys())[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                    var key = $__4.value;
                    {
                      var altKey = key.replace('Input Range ', 'Input Default ').replace('Input NO_DEFAULT Range ', 'Input Range ');
                      if (!ctx.has(key) && !ctx.has(altKey)) {
                        result.add(key);
                      }
                    }
                  }
                } catch ($__9) {
                  $__7 = true;
                  $__8 = $__9;
                } finally {
                  try {
                    if (!$__6 && $__3.return != null) {
                      $__3.return();
                    }
                  } finally {
                    if ($__7) {
                      throw $__8;
                    }
                  }
                }
              }
            }
          } catch ($__16) {
            $__14 = true;
            $__15 = $__16;
          } finally {
            try {
              if (!$__13 && $__10.return != null) {
                $__10.return();
              }
            } finally {
              if ($__14) {
                throw $__15;
              }
            }
          }
        }
        return result;
      },
      withDisabledReasonsForEmbeddedContext: function(outerRowOffset, outerContext) {
        return new CircuitDefinition(this.numWires, this.columns, outerRowOffset, outerContext, this.customGateSet, true);
      },
      _computeGateSlotCoverMap: function() {
        var result = new Map();
        for (var col = 0; col < this.columns.length; col++) {
          for (var row = 0; row < this.numWires; row++) {
            var gate = this.columns[col].gates[row];
            if (gate !== undefined) {
              for (var i = 0; i < gate.width; i++) {
                for (var j = 0; j < gate.height; j++) {
                  result.set((col + i) + ":" + (row + j), {
                    col: col,
                    row: row,
                    gate: gate
                  });
                }
              }
            }
          }
        }
        return result;
      },
      isEmpty: function() {
        return this.columns.length === 0;
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof CircuitDefinition && this.numWires === other.numWires && seq(this.columns).isEqualTo(seq(other.columns), Util.CUSTOM_IS_EQUAL_TO_EQUALITY);
      },
      toString: function() {
        var $__2 = this;
        var wire = function(n) {
          return "─".repeat(n);
        };
        var wireAround = function(n, s) {
          return wire(Math.floor(n - s.length) / 2) + s + wire(Math.ceil(n - s.length) / 2);
        };
        var colWidths = Seq.range(this.columns.length).map(function(c) {
          return seq($__2.columns[c].gates).map(function(e) {
            return e === undefined ? 0 : e.serializedId.length;
          }).max();
        }).toArray();
        return ("CircuitDefinition (" + this.numWires + " wires, " + this.columns.length + " cols):\n\t") + Seq.range(this.numWires).map(function(r) {
          return wire(1) + Seq.range($__2.columns.length).map(function(c) {
            var g = $__2.columns[c].gates[r];
            var label = g === undefined ? "" : g.serializedId;
            return wireAround(colWidths[c], label);
          }).join(wire(1)) + wire(1);
        }).join('\n\t');
      },
      stableDuration: function() {
        return seq(this.columns).flatMap(function(c) {
          return c.gates;
        }).filter(function(g) {
          return g !== undefined;
        }).map(function(g) {
          return g.stableDuration();
        }).min(Infinity);
      },
      readableHash: function() {
        var allGates = seq(this.columns).flatMap(function(e) {
          return e.gates;
        }).filter(function(e) {
          return e !== undefined;
        }).map(function(e) {
          return e.symbol;
        }).toArray();
        if (allGates.length === 0) {
          return Config.EMPTY_CIRCUIT_TITLE;
        }
        var allGatesString = (this.numWires + " wires, " + allGates.length + " ops, " + allGates.join("").split("^").join(""));
        if (allGatesString.length <= 40) {
          return allGatesString;
        }
        return allGatesString.substring(0, 40) + "…";
      },
      withColumns: function(cols) {
        return new CircuitDefinition(this.numWires, cols, this.outerRowOffset, this.outerContext, this.customGateSet);
      },
      _usedColumns: function() {
        var usedCols = new Set();
        for (var col = 0; col < this.columns.length; col++) {
          for (var i = 0; i < this.columns[col].maximumGateWidth(); i++) {
            usedCols.add(col + i);
          }
        }
        return usedCols;
      },
      _findWidthWiseOverlapInRect: function(col, row, width, height) {
        for (var i = 1; i < width && col + i < this.columns.length; i++) {
          for (var j = 0; j < height; j++) {
            var otherGate = this.findGateCoveringSlot(col + i, row + j);
            if (otherGate === undefined || otherGate.col === col) {
              continue;
            }
            return {
              col: otherGate.col,
              row: otherGate.row
            };
          }
        }
        return undefined;
      },
      withWidthOverlapsFixed: function() {
        var $__2 = this;
        var newCols = [];
        var $__23 = this,
            $__24 = function(col) {
              var paddingRequired = Seq.range($__23.numWires).map(function(row) {
                var gate = $__2.columns[col].gates[row];
                if (gate === undefined) {
                  return 0;
                }
                var f = $__2._findWidthWiseOverlapInRect(col, row, gate.width, gate.height);
                if (f === undefined) {
                  return 0;
                }
                return gate.width - (f.col - col);
              }).max(0);
              newCols.push($__23.columns[col]);
              for (var i = 0; i < paddingRequired; i++) {
                newCols.push(GateColumn.empty($__23.numWires));
              }
            };
        for (var col = 0; col < this.columns.length; col++) {
          $__24(col);
        }
        return this.withColumns(newCols);
      },
      _findHeightWiseOverlapsInCol: function(col) {
        var pushedGates = new Set();
        var h = 0;
        for (var row = 0; row < this.numWires; row++) {
          h -= 1;
          var gate = this.gateInSlot(col, row);
          if (gate !== undefined) {
            if (h > 0) {
              pushedGates.add(row);
            }
            h = Math.max(h, gate.height);
          }
        }
        return pushedGates;
      },
      withHeightOverlapsFixed: function() {
        var recurseLimit = arguments[0] !== (void 0) ? arguments[0] : 5;
        var newCols = [];
        var $__26 = this,
            $__27 = function(col) {
              var pushedGateIndexes = $__26._findHeightWiseOverlapsInCol(col);
              if (pushedGateIndexes.size === 0) {
                newCols.push($__26.columns[col]);
                return 0;
              }
              var keptGates = seq($__26.columns[col].gates).mapWithIndex(function(g, row) {
                return pushedGateIndexes.has(row) ? undefined : g;
              }).toArray();
              var pushedGates = seq($__26.columns[col].gates).mapWithIndex(function(g, row) {
                return g !== undefined && (g.isControl() || pushedGateIndexes.has(row)) ? g : undefined;
              }).toArray();
              newCols.push(new GateColumn(keptGates));
              newCols.push(new GateColumn(pushedGates));
            },
            $__28;
        $__25: for (var col = 0; col < this.columns.length; col++) {
          $__28 = $__27(col);
          switch ($__28) {
            case 0:
              continue $__25;
          }
        }
        var result = this.withColumns(newCols);
        if (newCols.length > this.columns.length && recurseLimit > 0) {
          result = result.withHeightOverlapsFixed(recurseLimit - 1);
        }
        return result;
      },
      withTrailingSpacersIncluded: function() {
        var extra = arguments[0] !== (void 0) ? arguments[0] : 0;
        return this.withColumns($traceurRuntime.spread(this.columns, new Array(Math.max(0, this.minimumRequiredColCount() + extra - this.columns.length)).fill(GateColumn.empty(this.numWires))));
      },
      trimEmptyColumnsAtEndIgnoringGateWidths: function() {
        for (var n = this.columns.length; ; n--) {
          if (n === 0 || !this.columns[n - 1].isEmpty()) {
            return this.withColumns(this.columns.slice(0, n));
          }
        }
      },
      withUncoveredColumnsRemoved: function() {
        var used = this._usedColumns();
        return new CircuitDefinition(this.numWires, seq(this.columns).filterWithIndex(function(e, i) {
          return used.has(i);
        }).toArray(), this.outerRowOffset, this.outerContext, this.customGateSet);
      },
      withWireCount: function(newWireCount) {
        if (newWireCount === this.numWires) {
          return this;
        }
        return new CircuitDefinition(newWireCount, this.columns.map(function(c) {
          return new GateColumn($traceurRuntime.spread(c.gates.slice(0, newWireCount), new Array(Math.max(0, newWireCount - c.gates.length)).fill(undefined)));
        }), this.outerRowOffset, this.outerContext, this.customGateSet);
      },
      minimumRequiredWireCount: function() {
        var best = 1;
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this.columns)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var c = $__4.value;
            {
              best = Math.max(best, c.minimumRequiredWireCount());
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        return best;
      },
      withMinimumWireCount: function() {
        return this.withWireCount(this.minimumRequiredWireCount());
      },
      minimumRequiredColCount: function() {
        var best = 0;
        for (var col = 0; col < this.columns.length; col++) {
          best = Math.max(best, this.columns[col].maximumGateWidth() + col);
        }
        return best;
      },
      colIsMeasuredMask: function(col) {
        if (col < 0) {
          return 0;
        }
        return this._measureMasks[Math.min(col, this.columns.length)];
      },
      colDesiredSingleQubitStatsMask: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return 0;
        }
        var c = this.columns[col];
        var total = 0;
        for (var row = 0; row < c.gates.length; row++) {
          if (c.gates[row] !== undefined && c.gates[row].isSingleQubitDisplay && this.gateAtLocIsDisabledReason(col, row) === undefined) {
            total |= 1 << row;
          }
        }
        return total;
      },
      colCustomContextFromGates: function(col, outerRowOffset) {
        if (col < 0 || col >= this.columns.length) {
          return new Map();
        }
        var key = "" + outerRowOffset;
        var result = this._cachedColumnContexts.get(key);
        if (result === undefined) {
          result = this._uncached_customContextFromGates(outerRowOffset);
          this._cachedColumnContexts.set(key, result);
        }
        return result[col];
      },
      _uncached_customContextFromGates: function(outerRowOffset) {
        var results = [];
        var stickyCtx = new Map();
        for (var col = 0; col < this.columns.length; col++) {
          var ctx = new Map(stickyCtx);
          var c = this.columns[col];
          for (var row = 0; row < c.gates.length; row++) {
            var g = c.gates[row];
            if (g === undefined || this.gateAtLocIsDisabledReason(col, row) !== undefined) {
              continue;
            }
            var $__6 = true;
            var $__7 = false;
            var $__8 = undefined;
            try {
              for (var $__4 = void 0,
                  $__3 = (g.customColumnContextProvider(outerRowOffset + row, g))[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                var $__17 = $__4.value,
                    key = $__17.key,
                    val = $__17.val;
                {
                  ctx.set(key, val);
                  if (!g.isContextTemporary) {
                    stickyCtx.set(key, val);
                  }
                }
              }
            } catch ($__9) {
              $__7 = true;
              $__8 = $__9;
            } finally {
              try {
                if (!$__6 && $__3.return != null) {
                  $__3.return();
                }
              } finally {
                if ($__7) {
                  throw $__8;
                }
              }
            }
          }
          results.push(ctx);
        }
        return results;
      },
      locIsMeasured: function(pt) {
        var row = pt.y;
        if (row < 0 || row >= this.numWires) {
          return false;
        }
        return (this.colIsMeasuredMask(pt.x) & (1 << row)) !== 0;
      },
      locClassifyMeasuredIncludingGateExtension: function(pt) {
        var row = pt.y;
        if (row < 0 || row >= this.numWires) {
          return false;
        }
        var gate = this.columns[pt.x].gates[row];
        var h = gate === undefined ? 1 : gate.height;
        var r = (this.colIsMeasuredMask(pt.x) >> row) & ((1 << h) - 1);
        return r === 0 ? false : r === (1 << h) - 1 ? true : undefined;
      },
      gateInSlot: function(col, row) {
        if (col < 0 || col >= this.columns.length || row < 0 || row >= this.numWires) {
          return undefined;
        }
        var gate = this.columns[col].gates[row];
        return gate === undefined ? undefined : gate;
      },
      findGateCoveringSlot: function(col, row) {
        var key = col + ":" + row;
        if (!this._gateSlotCoverMap.has(key)) {
          return undefined;
        }
        return this._gateSlotCoverMap.get(key);
      },
      locIsControlWireStarter: function(pt) {
        var gate = this.gateInSlot(pt.x, pt.y);
        return gate !== undefined && gate.isControlWireSource;
      },
      locStartsSingleControlWire: function(pt) {
        return this.locIsControlWireStarter(pt) && this.locClassifyMeasuredIncludingGateExtension(pt) !== true && this.gateAtLocIsDisabledReason(pt.x, pt.y) === undefined;
      },
      locStartsDoubleControlWire: function(pt) {
        return this.locIsControlWireStarter(pt) && this.locClassifyMeasuredIncludingGateExtension(pt) !== false && this.gateAtLocIsDisabledReason(pt.x, pt.y) === undefined;
      },
      colGetEnabledSwapGate: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return undefined;
        }
        var locs = [];
        for (var row = 0; row < this.numWires; row++) {
          if (this.gateInSlot(col, row) === Gates.Special.SwapHalf) {
            if (this.gateAtLocIsDisabledReason(col, row) !== undefined) {
              return undefined;
            }
            locs.push(row);
          }
        }
        if (locs.length !== 2) {
          return undefined;
        }
        return locs;
      },
      locProvidesStat: function(pt, key) {
        var g = this.gateInSlot(pt.x, pt.y);
        return g !== undefined && !g.customColumnContextProvider(0, g).every(function(e) {
          return e.key !== key;
        });
      },
      locNeedsStat: function(pt, key) {
        var g = this.gateInSlot(pt.x, pt.y);
        return g !== undefined && g.getUnmetContextKeys().has(key);
      },
      locHasControllableGate: function(pt) {
        var g = this.gateInSlot(pt.x, pt.y);
        return g !== undefined && g.interestedInControls;
      },
      colHasControls: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return false;
        }
        return this.columns[col].hasControl();
      },
      colHasSingleWireControl: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return false;
        }
        return this.columns[col].hasCoherentControl(this._measureMasks[col]);
      },
      colHasDoubleWireControl: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return false;
        }
        return this.columns[col].hasMeasuredControl(this._measureMasks[col]);
      },
      colControls: function(col) {
        if (col < 0 || col >= this.columns.length) {
          return Controls.NONE;
        }
        var result = Controls.NONE;
        var column = this.columns[col];
        for (var i = 0; i < column.gates.length; i++) {
          var gate = column.gates[i];
          if (gate !== undefined && this.gateAtLocIsDisabledReason(col, i) === undefined) {
            var bit = gate.controlBit();
            if (bit !== undefined) {
              result = result.and(Controls.bit(i, bit));
            }
          }
        }
        return result;
      },
      gateAtLocIsDisabledReason: function(col, row) {
        if (col < 0 || row < 0 || col >= this._colRowDisabledReason.length || row >= this.numWires) {
          return undefined;
        }
        return this._colRowDisabledReason[col][row];
      },
      applyMainOperationsInCol: function(colIndex, ctx) {
        var $__18,
            $__19;
        if (colIndex < 0 || colIndex >= this.columns.length) {
          return;
        }
        this._applyOpsInCol(colIndex, ctx, function(gate) {
          if (gate.definitelyHasNoEffect() || gate === Gates.Special.SwapHalf) {
            return undefined;
          }
          if (gate.customOperation !== undefined) {
            return gate.customOperation;
          }
          return function(ctx) {
            return GateShaders.applyMatrixOperation(ctx, gate.knownMatrixAt(ctx.time));
          };
        });
        var swapRows = this.colGetEnabledSwapGate(colIndex);
        if (swapRows !== undefined) {
          var $__17 = swapRows,
              i = ($__18 = $__17[Symbol.iterator](), ($__19 = $__18.next()).done ? void 0 : $__19.value),
              j = ($__19 = $__18.next()).done ? void 0 : $__19.value;
          ctx.applyOperation(CircuitShaders.swap(ctx.withRow(i + ctx.row), j + ctx.row));
        }
      },
      applyBeforeOperationsInCol: function(colIndex, ctx) {
        this._applyOpsInCol(colIndex, ctx, function(g) {
          return g.customBeforeOperation;
        });
      },
      applyAfterOperationsInCol: function(colIndex, ctx) {
        this._applyOpsInCol(colIndex, ctx, function(g) {
          return g.customAfterOperation;
        });
      },
      _applyOpsInCol: function(colIndex, ctx, opGetter) {
        if (colIndex < 0 || colIndex >= this.columns.length) {
          return;
        }
        var col = this.columns[colIndex];
        for (var row = 0; row < this.numWires; row++) {
          var gate = col.gates[row];
          if (gate === undefined || this.gateAtLocIsDisabledReason(colIndex, row) !== undefined) {
            continue;
          }
          var op = opGetter(gate);
          if (op !== undefined) {
            op(ctx.withRow(ctx.row + row));
          }
        }
      },
      customStatRowsInCol: function(colIndex) {
        if (colIndex < 0 || colIndex >= this.columns.length) {
          return [];
        }
        var col = this.columns[colIndex];
        var result = [];
        for (var row = 0; row < col.gates.length; row++) {
          if (col.gates[row] !== undefined && col.gates[row].customStatTexturesMaker !== undefined && this.gateAtLocIsDisabledReason(colIndex, row) === undefined) {
            result.push(row);
          }
        }
        return result;
      },
      isSlotRectCoveredByGateInSameColumn: function(col, row, height) {
        for (var j = 0; j < height; j++) {
          var f = this.findGateCoveringSlot(col, row + j);
          if (f !== undefined && f.col === col) {
            return true;
          }
        }
        return false;
      },
      withCustomGate: function(gate) {
        return new CircuitDefinition(this.numWires, this.columns, this.outerRowOffset, this.outerContext, this.customGateSet.withGate(gate));
      },
      controlLinesRanges: function(columnIndex) {
        var $__2 = this;
        var col = this.columns[columnIndex];
        var n = col.gates.length;
        var swapRows = this.colGetEnabledSwapGate(columnIndex);
        var pt = function(i) {
          return new Point(columnIndex, i);
        };
        var hasControllable = function(i) {
          return $__2.locHasControllableGate(pt(i));
        };
        var hasCoherentControl = function(i) {
          return $__2.locStartsSingleControlWire(pt(i));
        };
        var hasMeasuredControl = function(i) {
          return $__2.locStartsDoubleControlWire(pt(i));
        };
        var hasSwap = function(i) {
          return swapRows !== undefined && swapRows.indexOf(i) !== -1;
        };
        var coversCoherentWire = function(i) {
          return $__2.locClassifyMeasuredIncludingGateExtension(pt(i)) !== true;
        };
        var coversMeasuredWire = function(i) {
          return $__2.locClassifyMeasuredIncludingGateExtension(pt(i)) !== false;
        };
        var result = [srcDstMatchInRange(n, hasSwap, hasSwap, false), srcDstMatchInRange(n, hasControllable, hasCoherentControl, false), srcDstMatchInRange(n, hasControllable, hasMeasuredControl, true)];
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          var $__29 = function() {
            var letter = $__4.value;
            {
              var key = ("Input Range " + letter);
              var altInKey = ("Input Default " + letter);
              var altOutKey = ("Input NO_DEFAULT Range " + letter);
              var isInput = function(i) {
                return $__2.locProvidesStat(pt(i), key) || $__2.locProvidesStat(pt(i), altInKey);
              };
              var isOutput = function(i) {
                return $__2.locNeedsStat(pt(i), key) || $__2.locNeedsStat(pt(i), altOutKey);
              };
              result.push(srcDstMatchInRange(n, function(i) {
                return isInput(i) && coversCoherentWire(i);
              }, isOutput, false), srcDstMatchInRange(n, function(i) {
                return isInput(i) && coversMeasuredWire(i);
              }, isOutput, true));
            }
          };
          for (var $__4 = void 0,
              $__3 = (Gates.InputGates.Letters)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            $__29();
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        return result.filter(function(e) {
          return e !== undefined;
        });
      }
    }, {fromTextDiagram: function(gateMap, diagram) {
        var lines = seq(diagram.split('\n')).map(function(e) {
          return e.trim();
        }).filter(function(e) {
          return e !== '';
        }).toArray();
        if (seq(lines.map(function(e) {
          return e.length;
        })).distinct().count() > 1) {
          throw new DetailedError("Uneven diagram", {diagram: diagram});
        }
        var rowCount = lines.length;
        var colCount = lines.length > 0 ? lines[0].length : 0;
        var spanAt = function(col, row) {
          for (var d = 1; row + d < lines.length; d++) {
            if (gateMap.get(lines[row + d][col]) !== null) {
              return d;
            }
          }
          return lines.length - row;
        };
        return new CircuitDefinition(rowCount, Seq.range(colCount).map(function(col) {
          return new GateColumn(seq(lines).mapWithIndex(function(line, row) {
            var char = line[col];
            if (!gateMap.has(char)) {
              throw new DetailedError("Unspecified gate", {char: char});
            }
            var gateOrFamily = gateMap.get(char);
            if (gateOrFamily === null || gateOrFamily === undefined) {
              return undefined;
            }
            if (gateOrFamily.hasOwnProperty('ofSize')) {
              return gateOrFamily.ofSize(spanAt(col, row));
            }
            if (gateOrFamily instanceof Gate) {
              return gateOrFamily;
            }
            throw new DetailedError("Not a gate", gateOrFamily);
          }).toArray());
        }).toArray());
      }});
  }();
  function srcDstMatchInRange(rangeLen, srcPredicate, dstPredicate, measured) {
    var $__18,
        $__19,
        $__21,
        $__22;
    var $__17 = firstLastMatchInRange(rangeLen, srcPredicate),
        src1 = ($__18 = $__17[Symbol.iterator](), ($__19 = $__18.next()).done ? void 0 : $__19.value),
        src2 = ($__19 = $__18.next()).done ? void 0 : $__19.value;
    var $__20 = firstLastMatchInRange(rangeLen, dstPredicate),
        dst1 = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
        dst2 = ($__22 = $__21.next()).done ? void 0 : $__22.value;
    if (dst1 === undefined || src1 === undefined) {
      return undefined;
    }
    return {
      first: Math.min(src1, dst1),
      last: Math.max(src2, dst2),
      measured: measured
    };
  }
  function firstLastMatchInRange(rangeLen, predicate) {
    var first = undefined;
    var last = undefined;
    for (var i = 0; i < rangeLen; i++) {
      if (predicate(i)) {
        if (first === undefined) {
          first = i;
        }
        last = i;
      }
    }
    return [first, last];
  }
  CircuitDefinition.EMPTY = new CircuitDefinition(0, []);
  return {get CircuitDefinition() {
      return CircuitDefinition;
    }};
});
//# sourceURL=src/circuit/CircuitDefinition.js
;$traceurRuntime.registerModule("src/circuit/CircuitEvalContext.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitEvalContext.js";
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/circuit/CircuitEvalContext.js")).WglConfiguredShader;
  var CircuitEvalContext = function() {
    function CircuitEvalContext(time, qubitRow, wireCount, controls, controlsTexture, stateTrader, customContextFromGates) {
      this.time = time;
      this.row = qubitRow;
      this.wireCount = wireCount;
      this.controls = controls;
      this.controlsTexture = controlsTexture;
      this.stateTrader = stateTrader;
      this.customContextFromGates = customContextFromGates;
    }
    return ($traceurRuntime.createClass)(CircuitEvalContext, {
      applyOperation: function(operation) {
        var configuredShader = operation instanceof WglConfiguredShader ? operation : operation(this);
        this.stateTrader.shadeAndTrade(configuredShader);
      },
      _clone: function() {
        return new CircuitEvalContext(this.time, this.row, this.wireCount, this.controls, this.controlsTexture, this.stateTrader, this.customContextFromGates);
      },
      withRow: function(row) {
        var r = this._clone();
        r.row = row;
        return r;
      },
      withInputSetToRange: function(letter, offset, length) {
        var r = this._clone();
        r.customContextFromGates = new Map(r.customContextFromGates);
        r.customContextFromGates.set(("Input Range " + letter), {
          offset: offset,
          length: length
        });
        return r;
      },
      withInputSetToConstant: function(letter, value) {
        var r = this._clone();
        r.customContextFromGates = new Map(r.customContextFromGates);
        r.customContextFromGates.delete(("Input Range " + letter));
        r.customContextFromGates.set(("Input Default " + letter), value);
        return r;
      },
      withInputSetToOtherInput: function(letter, other) {
        var r = this._clone();
        r.customContextFromGates = new Map(r.customContextFromGates);
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (['Range', 'Default'])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              var otherVal = r.customContextFromGates.get(("Input " + key + " " + other));
              if (otherVal !== undefined) {
                r.customContextFromGates.set(("Input " + key + " " + letter), otherVal);
              } else {
                r.customContextFromGates.delete(("Input " + key + " " + letter));
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return r;
      }
    }, {});
  }();
  return {get CircuitEvalContext() {
      return CircuitEvalContext;
    }};
});
//# sourceURL=src/circuit/CircuitEvalContext.js
;$traceurRuntime.registerModule("src/circuit/CircuitShaders.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitShaders.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/circuit/CircuitShaders.js")).Config;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Controls.js", "src/circuit/CircuitShaders.js")).Controls;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/circuit/CircuitShaders.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/Shaders.js", "src/circuit/CircuitShaders.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/CircuitShaders.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/circuit/CircuitShaders.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/circuit/CircuitShaders.js")).WglConfiguredShader;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/circuit/CircuitShaders.js")),
      currentShaderCoder = $__9.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__9.makePseudoShaderWithInputsAndOutputAndCode,
      Inputs = $__9.Inputs,
      Outputs = $__9.Outputs;
  var CircuitShaders = function() {
    function CircuitShaders() {}
    return ($traceurRuntime.createClass)(CircuitShaders, {}, {});
  }();
  CircuitShaders.classicalState = function(stateBitMask) {
    return SET_SINGLE_PIXEL_SHADER(WglArg.float("state", stateBitMask));
  };
  var SET_SINGLE_PIXEL_SHADER = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.vec2(), "\n    uniform float state;\n    vec2 outputFor(float k) {\n        return vec2(float(k == state), 0.0);\n    }");
  CircuitShaders.linearOverlay = function(offset, foregroundTexture, backgroundTexture) {
    return LINEAR_OVERLAY_SHADER(backgroundTexture, foregroundTexture, WglArg.float("offset", offset));
  };
  var LINEAR_OVERLAY_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('back'), Inputs.vec4('fore')], Outputs.vec4(), "\n    uniform float offset;\n    vec4 outputFor(float k) {\n        // Note: can't use multiplication to combine because it spreads NaNs from the background into the foreground.\n        return k >= offset && k < offset + len_fore() ? read_fore(k - offset) : read_back(k);\n    }");
  CircuitShaders.controlMask = function(controlMask) {
    if (controlMask.isEqualTo(Controls.NONE)) {
      return Shaders.color(1, 0, 0, 0);
    }
    return CONTROL_MASK_SHADER(WglArg.float('used', controlMask.inclusionMask), WglArg.float('desired', controlMask.desiredValueMask));
  };
  var CONTROL_MASK_SHADER = makePseudoShaderWithInputsAndOutputAndCode([], Outputs.bool(), ("\n    uniform float used;\n    uniform float desired;\n\n    bool outputFor(float k) {\n        float pass = 1.0;\n        float bit = 1.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float v = mod(floor(k/bit), 2.0);\n            float u = mod(floor(used/bit), 2.0);\n            float d = mod(floor(desired/bit), 2.0);\n            pass *= 1.0 - abs(v-d)*u;\n            bit *= 2.0;\n        }\n        return pass == 1.0;\n    }"));
  CircuitShaders.controlSelect = function(controlMask, dataTexture) {
    if (controlMask.isEqualTo(Controls.NONE)) {
      return Shaders.passthrough(dataTexture);
    }
    return CONTROL_SELECT_SHADER(dataTexture, WglArg.float('used', controlMask.inclusionMask), WglArg.float('desired', controlMask.desiredValueMask));
  };
  var CONTROL_SELECT_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), ("\n    uniform float used;\n    uniform float desired;\n\n    /**\n     * Inserts bits from the given value into the holes between used bits in the desired mask.\n     */\n    float scatter(float k) {\n        float maskPos = 1.0;\n        float coordPos = 1.0;\n        float result = 0.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float v = mod(floor(k/coordPos), 2.0);\n            float u = mod(floor(used/maskPos), 2.0);\n            float d = mod(floor(desired/maskPos), 2.0);\n            result += (v + u*(d-v)) * maskPos;\n            coordPos *= 2.0-u;\n            maskPos *= 2.0;\n        }\n        return result;\n    }\n\n    vec2 outputFor(float k) {\n        return read_input(scatter(k));\n    }"));
  CircuitShaders.swap = function(ctx, otherRow) {
    var $__1;
    return ($__1 = SWAP_QUBITS_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, otherRow - ctx.row + 1)));
  };
  var SWAP_QUBITS_SHADER = ketShaderPermute('', "\n    float low_bit = mod(out_id, 2.0);\n    float mid_bits = floor(mod(out_id, span*0.5)*0.5);\n    float high_bit = floor(out_id*2.0/span);\n    return high_bit + mid_bits*2.0 + low_bit*span*0.5;");
  CircuitShaders.qubitDensities = function(inputTexture) {
    var keptBitMask = arguments[1];
    if (keptBitMask === undefined) {
      keptBitMask = (1 << currentShaderCoder().vec2.arrayPowerSizeOfTexture(inputTexture)) - 1;
    }
    var keptCount = Util.ceilingPowerOf2(Util.numberOfSetBits(keptBitMask));
    return QUBIT_DENSITIES_SHADER(inputTexture, WglArg.float('keptCount', keptCount), WglArg.float('keptBitMask', keptBitMask));
  };
  var QUBIT_DENSITIES_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec4(), ("\n    uniform float keptCount;\n    uniform float keptBitMask;\n\n    float scatter(float val, float used) {\n        float result = 0.0;\n        float posUsed = 1.0;\n        float posVal = 1.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float u = mod(floor(used/posUsed), 2.0);\n            float v = mod(floor(val/posVal), 2.0);\n            result += u * v * posUsed;\n            posVal *= 1.0+u;\n            posUsed *= 2.0;\n        }\n        return result;\n    }\n\n    vec4 outputFor(float k) {\n        float bitIndex = mod(k, keptCount);\n        float otherBits = floor(k / keptCount);\n        float bit = scatter(exp2(bitIndex), keptBitMask);\n\n        // Indices of the two complex values making up the current conditional ket.\n        float srcIndex0 = mod(otherBits, bit) + floor(otherBits / bit) * bit * 2.0;\n        float srcIndex1 = srcIndex0 + bit;\n\n        // Grab the two complex values.\n        vec2 w1 = read_input(srcIndex0);\n        vec2 w2 = read_input(srcIndex1);\n\n        // Compute density matrix components.\n        float a = dot(w1, w1);\n        float br = dot(w1, w2);\n        float bi = dot(vec2(-w1.y, w1.x), w2);\n        float d = dot(w2, w2);\n\n        return vec4(a, br, bi, d);\n    }"));
  return {get CircuitShaders() {
      return CircuitShaders;
    }};
});
//# sourceURL=src/circuit/CircuitShaders.js
;$traceurRuntime.registerModule("src/circuit/CircuitStats.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CircuitStats.js";
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitDefinition.js", "src/circuit/CircuitStats.js")).CircuitDefinition;
  var CircuitEvalContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitEvalContext.js", "src/circuit/CircuitStats.js")).CircuitEvalContext;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitShaders.js", "src/circuit/CircuitStats.js")).CircuitShaders;
  var KetTextureUtil = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetTextureUtil.js", "src/circuit/CircuitStats.js")).KetTextureUtil;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Controls.js", "src/circuit/CircuitStats.js")).Controls;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/CircuitStats.js")).DetailedError;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/circuit/CircuitStats.js")).Matrix;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/Shaders.js", "src/circuit/CircuitStats.js")).Shaders;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Serializer.js", "src/circuit/CircuitStats.js")).Serializer;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/CircuitStats.js")).Util;
  var notifyAboutRecoveryFromUnexpectedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/fallback.js", "src/circuit/CircuitStats.js")).notifyAboutRecoveryFromUnexpectedError;
  var advanceStateWithCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitComputeUtil.js", "src/circuit/CircuitStats.js")).advanceStateWithCircuit;
  var currentShaderCoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/circuit/CircuitStats.js")).currentShaderCoder;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTextureTrader.js", "src/circuit/CircuitStats.js")).WglTextureTrader;
  var CircuitStats = function() {
    function CircuitStats(circuitDefinition, time, survivalRates, singleQubitDensities, finalState, customStatsProcessed) {
      this.circuitDefinition = circuitDefinition;
      this.time = time;
      this._survivalRates = survivalRates;
      this._qubitDensities = singleQubitDensities;
      this.finalState = finalState;
      this._customStatsProcessed = customStatsProcessed;
    }
    return ($traceurRuntime.createClass)(CircuitStats, {
      qubitDensityMatrix: function(colIndex, wireIndex) {
        if (wireIndex < 0) {
          throw new DetailedError("Bad wireIndex", {
            wireIndex: wireIndex,
            colIndex: colIndex
          });
        }
        if (colIndex < 0 || wireIndex >= this.circuitDefinition.numWires) {
          if (wireIndex >= this.circuitDefinition.numWires && this.qubitDensityMatrix(colIndex, 0).hasNaN()) {
            return Matrix.zero(2, 2).times(NaN);
          }
          var buf = new Float32Array(8);
          buf[0] = 1;
          return new Matrix(2, 2, buf);
        }
        var col = Math.min(colIndex, this._qubitDensities.length - 1);
        if (col < 0 || wireIndex >= this._qubitDensities[col].length) {
          return Matrix.zero(2, 2).times(NaN);
        }
        return this._qubitDensities[col][wireIndex];
      },
      survivalRate: function(colIndex) {
        colIndex = Math.min(colIndex, this._survivalRates.length - 1);
        return colIndex < 0 ? 1 : this._survivalRates[colIndex];
      },
      customStatsForSlot: function(col, row) {
        var key = col + ":" + row;
        return this._customStatsProcessed.has(key) ? this._customStatsProcessed.get(key) : undefined;
      },
      controlledWireProbabilityJustAfter: function(wireIndex, colIndex) {
        return this.qubitDensityMatrix(colIndex, wireIndex).rawBuffer()[6];
      },
      withTime: function(time) {
        return new CircuitStats(this.circuitDefinition, time, this._survivalRates, this._qubitDensities, this.finalState, this._customStatsProcessed);
      }
    }, {
      withNanDataFromCircuitAtTime: function(circuitDefinition, time) {
        return new CircuitStats(circuitDefinition, time, [1], [], Matrix.zero(1, 1 << circuitDefinition.numWires).times(NaN), new Map());
      },
      fromCircuitAtTime: function(circuitDefinition, time) {
        try {
          return CircuitStats._fromCircuitAtTime_noFallback(circuitDefinition, time);
        } catch (ex) {
          notifyAboutRecoveryFromUnexpectedError("Defaulted to NaN results. Computing circuit values failed.", {circuitDefinition: Serializer.toJson(circuitDefinition)}, ex);
          return CircuitStats.withNanDataFromCircuitAtTime(circuitDefinition, time);
        }
      },
      decohereMeasuredBitsInDensityMatrix: function(densityMatrix, isMeasuredMask) {
        if (isMeasuredMask === 0) {
          return densityMatrix;
        }
        var buf = new Float32Array(densityMatrix.rawBuffer());
        var n = densityMatrix.width();
        for (var row = 0; row < n; row++) {
          for (var col = 0; col < n; col++) {
            if (((row ^ col) & isMeasuredMask) !== 0) {
              var k = (row * n + col) * 2;
              buf[k] = 0;
              buf[k + 1] = 0;
            }
          }
        }
        return new Matrix(n, n, buf);
      },
      scatterAndDecohereDensities: function(rawMatrices, numWires, qubitSpan, isMeasuredMask, hasDisplayMask) {
        var nanMatrix = Matrix.zero(1 << qubitSpan, 1 << qubitSpan).times(NaN);
        var used = 0;
        var result = [];
        for (var row = 0; row < numWires - qubitSpan + 1; row++) {
          if ((hasDisplayMask & (1 << row)) === 0) {
            result.push(nanMatrix);
          } else {
            result.push(CircuitStats.decohereMeasuredBitsInDensityMatrix(rawMatrices[used++], (isMeasuredMask >> row) & ((1 << qubitSpan) - 1)));
          }
        }
        return result;
      },
      _extractColumnQubitStatsFromPixelDatas: function(circuitDefinition, colQubitDensitiesPixelData) {
        var qubitDensityGrid = [];
        for (var col = 0; col < colQubitDensitiesPixelData.length; col++) {
          var dataHasStatsMask = col === circuitDefinition.columns.length ? -1 : circuitDefinition.colDesiredSingleQubitStatsMask(col);
          qubitDensityGrid.push(CircuitStats.scatterAndDecohereDensities(KetTextureUtil.pixelsToQubitDensityMatrices(colQubitDensitiesPixelData[col]), circuitDefinition.numWires, 1, circuitDefinition.colIsMeasuredMask(col), dataHasStatsMask));
        }
        return qubitDensityGrid;
      },
      _extractColumnSurvivalRateStatsFromPixelDatas: function(normsPixelData) {
        var curSurvivalRate = 1;
        var survivalRates = [];
        for (var col = 0; col < normsPixelData.length; col++) {
          if (normsPixelData[col].length > 0) {
            curSurvivalRate = normsPixelData[col][0];
          }
          survivalRates.push(curSurvivalRate);
        }
        return survivalRates;
      },
      _fromCircuitAtTime_noFallback: function(circuitDefinition, time) {
        circuitDefinition = circuitDefinition.withMinimumWireCount();
        var numWires = circuitDefinition.numWires;
        var stateTrader = new WglTextureTrader(CircuitShaders.classicalState(0).toVec2Texture(numWires));
        var controlTex = CircuitShaders.controlMask(Controls.NONE).toBoolTexture(numWires);
        var $__9 = advanceStateWithCircuit(new CircuitEvalContext(time, 0, numWires, Controls.NONE, controlTex, stateTrader, new Map()), circuitDefinition, true),
            colQubitDensities = $__9.colQubitDensities,
            colNorms = $__9.colNorms,
            customStats = $__9.customStats,
            customStatsMap = $__9.customStatsMap;
        controlTex.deallocByDepositingInPool("controlTex in _fromCircuitAtTime_noFallback");
        if (currentShaderCoder().vec2.needRearrangingToBeInVec4Format) {
          stateTrader.shadeHalveAndTrade(Shaders.packVec2IntoVec4);
        }
        var pixelData = Util.objectifyArrayFunc(KetTextureUtil.mergedReadFloats)({
          output: stateTrader.currentTexture,
          colQubitDensities: colQubitDensities,
          colNorms: colNorms,
          customStats: customStats
        });
        var qubitDensities = CircuitStats._extractColumnQubitStatsFromPixelDatas(circuitDefinition, pixelData.colQubitDensities);
        var survivalRates = CircuitStats._extractColumnSurvivalRateStatsFromPixelDatas(pixelData.colNorms);
        var outputSuperposition = KetTextureUtil.pixelsToAmplitudes(pixelData.output, survivalRates.length === 0 ? 1 : survivalRates[survivalRates.length - 1]);
        var customStatsProcessed = new Map();
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (customStatsMap)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__10 = $__3.value,
                col = $__10.col,
                row = $__10.row,
                out = $__10.out;
            {
              var func = circuitDefinition.gateInSlot(col, row).customStatPostProcesser || (function(e) {
                return e;
              });
              customStatsProcessed.set(col + ":" + row, func(pixelData.customStats[out], circuitDefinition, col, row));
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return new CircuitStats(circuitDefinition, time, survivalRates, qubitDensities, outputSuperposition, customStatsProcessed);
      }
    });
  }();
  CircuitStats.EMPTY = CircuitStats.withNanDataFromCircuitAtTime(CircuitDefinition.EMPTY, 0);
  return {get CircuitStats() {
      return CircuitStats;
    }};
});
//# sourceURL=src/circuit/CircuitStats.js
;$traceurRuntime.registerModule("src/circuit/Controls.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/Controls.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/Controls.js")).DetailedError;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/circuit/Controls.js")).Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/Controls.js")).Util;
  var Controls = function() {
    function Controls(inclusionMask, desiredValueMask) {
      if ((desiredValueMask & ~inclusionMask) !== 0) {
        throw new DetailedError("Desired un-included bits", {
          inclusionMask: inclusionMask,
          desiredValueMask: desiredValueMask
        });
      }
      this.inclusionMask = inclusionMask;
      this.desiredValueMask = desiredValueMask;
    }
    return ($traceurRuntime.createClass)(Controls, {
      isEqualTo: function(other) {
        return other instanceof Controls && this.inclusionMask === other.inclusionMask && this.desiredValueMask === other.desiredValueMask;
      },
      toString: function() {
        var $__2 = this;
        if (this.inclusionMask === 0) {
          return "No Controls";
        }
        return "Controls: ...__" + Seq.naturals().takeWhile(function(i) {
          return (1 << i) <= $__2.inclusionMask;
        }).map(this.desiredValueFor.bind(this)).map(function(e) {
          return e === undefined ? "_" : e ? "1" : "0";
        }).reverse().join("");
      },
      allowsState: function(stateIndex) {
        return (this.inclusionMask & stateIndex) === this.desiredValueMask;
      },
      desiredValueFor: function(bitIndex) {
        if ((this.inclusionMask & (1 << bitIndex)) === 0) {
          return undefined;
        }
        return (this.desiredValueMask & (1 << bitIndex)) !== 0;
      },
      includedBitCount: function() {
        if (this.inclusionMask < 0) {
          return Infinity;
        }
        return Util.numberOfSetBits(this.inclusionMask);
      },
      and: function(other) {
        if ((other.desiredValueMask & this.inclusionMask) !== (this.desiredValueMask & other.inclusionMask)) {
          throw new DetailedError("Contradictory controls.", {
            "this": this,
            other: other
          });
        }
        return new Controls(this.inclusionMask | other.inclusionMask, this.desiredValueMask | other.desiredValueMask);
      },
      shift: function(offset) {
        return new Controls(this.inclusionMask << offset, this.desiredValueMask << offset);
      }
    }, {bit: function(bitIndex, desiredValue) {
        if (bitIndex < 0) {
          throw new DetailedError("Out of range", {bitIndex: bitIndex});
        }
        return new Controls(1 << bitIndex, desiredValue ? (1 << bitIndex) : 0);
      }});
  }();
  Controls.NONE = new Controls(0, 0);
  return {get Controls() {
      return Controls;
    }};
});
//# sourceURL=src/circuit/Controls.js
;$traceurRuntime.registerModule("src/circuit/CustomGateSet.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/CustomGateSet.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/CustomGateSet.js")).DetailedError;
  var CustomGateSet = function() {
    function CustomGateSet() {
      for (var gates = [],
          $__9 = 0; $__9 < arguments.length; $__9++)
        gates[$__9] = arguments[$__9];
      this.gates = gates;
    }
    return ($traceurRuntime.createClass)(CustomGateSet, {
      withGate: function(gate) {
        if (!gate.serializedId.startsWith("~")) {
          throw new DetailedError("Custom gates' serialized id must start with '~'.", {
            id: gate.serializedId,
            gate: gate
          });
        }
        if (this.findGateWithSerializedId(gate.serializedId)) {
          throw new DetailedError("Duplicate serialized id.", {gate: gate});
        }
        return new (Function.prototype.bind.apply(CustomGateSet, $traceurRuntime.spread([null], this.gates, [gate])))();
      },
      findGateWithSerializedId: function(id) {
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (this.gates)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var g = $__3.value;
            {
              if (g.serializedId === id) {
                return g;
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return undefined;
      }
    }, {});
  }();
  return {get CustomGateSet() {
      return CustomGateSet;
    }};
});
//# sourceURL=src/circuit/CustomGateSet.js
;$traceurRuntime.registerModule("src/circuit/Gate.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/Gate.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/Gate.js")).DetailedError;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GateDrawParams.js", "src/circuit/Gate.js")).GateDrawParams;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/circuit/Gate.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/circuit/Gate.js")).Matrix;
  var Gate = function() {
    function Gate() {
      this.symbol = '';
      this.serializedId = '';
      this.name = '';
      this.blurb = '';
      this.width = 1;
      this.height = 1;
      this.param = undefined;
      this.customDrawer = undefined;
      this.onClickGateFunc = undefined;
      this.tag = undefined;
      this.customBeforeOperation = undefined;
      this.customOperation = undefined;
      this.customAfterOperation = undefined;
      this.customStatTexturesMaker = undefined;
      this.customStatPostProcesser = undefined;
      this.gateFamily = [this];
      this.interestedInControls = true;
      this._stableDuration = undefined;
      this._knownMatrix = undefined;
      this._knownMatrixFunc = undefined;
      this._hasNoEffect = false;
      this._effectPermutesStates = undefined;
      this._effectCreatesSuperpositions = undefined;
      this.isControlWireSource = false;
      this.knownCircuit = undefined;
      this.knownCircuitNested = undefined;
      this._requiredContextKeys = [];
      this.isSingleQubitDisplay = false;
      this._controlBit = undefined;
      this._isDefinitelyUnitary = false;
      this.customColumnContextProvider = function(qubit, gate) {
        return [];
      };
      this.isContextTemporary = true;
      this.customDisableReasonFinder = function(args) {
        return undefined;
      };
      this.knownBitPermutationFunc = undefined;
      this.knownPhaseTurnsFunc = undefined;
      this.knownPermutationFuncTakingInputs = undefined;
      this._showAsReachesOtherWires = false;
    }
    return ($traceurRuntime.createClass)(Gate, {
      _copy: function() {
        var g = new Gate();
        g.symbol = this.symbol;
        g.name = this.name;
        g.blurb = this.blurb;
        g.serializedId = this.serializedId;
        g.onClickGateFunc = this.onClickGateFunc;
        g.tag = this.tag;
        g.param = this.param;
        g.customDrawer = this.customDrawer;
        g.interestedInControls = this.interestedInControls;
        g.customBeforeOperation = this.customBeforeOperation;
        g.knownBitPermutationFunc = this.knownBitPermutationFunc;
        g.customOperation = this.customOperation;
        g.customAfterOperation = this.customAfterOperation;
        g.customStatTexturesMaker = this.customStatTexturesMaker;
        g.customStatPostProcesser = this.customStatPostProcesser;
        g.width = this.width;
        g.height = this.height;
        g.isSingleQubitDisplay = this.isSingleQubitDisplay;
        g._knownMatrix = this._knownMatrix;
        g.knownCircuit = this.knownCircuit;
        g._showAsReachesOtherWires = this._showAsReachesOtherWires;
        g.isContextTemporary = this.isContextTemporary;
        g.knownCircuitNested = this.knownCircuitNested;
        g._requiredContextKeys = this._requiredContextKeys;
        g._knownMatrixFunc = this._knownMatrixFunc;
        g._stableDuration = this._stableDuration;
        g._hasNoEffect = this._hasNoEffect;
        g._effectPermutesStates = this._effectPermutesStates;
        g._effectCreatesSuperpositions = this._effectCreatesSuperpositions;
        g._affectsOtherWires = this._affectsOtherWires;
        g._controlBit = this._controlBit;
        g.isControlWireSource = this.isControlWireSource;
        g._isDefinitelyUnitary = this._isDefinitelyUnitary;
        g.knownPhaseTurnsFunc = this.knownPhaseTurnsFunc;
        g.knownPermutationFuncTakingInputs = this.knownPermutationFuncTakingInputs;
        g.customColumnContextProvider = this.customColumnContextProvider;
        g.customDisableReasonFinder = this.customDisableReasonFinder;
        return g;
      },
      withParam: function(value) {
        var g = this._copy();
        g.param = value;
        return g;
      },
      getUnmetContextKeys: function() {
        var result = new Set(this._requiredContextKeys);
        if (this.knownCircuit !== undefined) {
          var $__6 = true;
          var $__7 = false;
          var $__8 = undefined;
          try {
            for (var $__4 = void 0,
                $__3 = (this.knownCircuit.getUnmetContextKeys())[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
              var key = $__4.value;
              {
                result.add(key);
              }
            }
          } catch ($__9) {
            $__7 = true;
            $__8 = $__9;
          } finally {
            try {
              if (!$__6 && $__3.return != null) {
                $__3.return();
              }
            } finally {
              if ($__7) {
                throw $__8;
              }
            }
          }
        }
        return result;
      },
      shouldShowAsHavingGlobalEffect: function() {
        return this._showAsReachesOtherWires || !this._isDefinitelyUnitary;
      },
      canChangeInSize: function() {
        return this.gateFamily.length > 1;
      },
      canIncreaseInSize: function() {
        var $__2 = this;
        return !this.gateFamily.every(function(e) {
          return e.height !== $__2.height + 1;
        });
      },
      canDecreaseInSize: function() {
        var $__2 = this;
        return !this.gateFamily.every(function(e) {
          return e.height !== $__2.height - 1;
        });
      },
      knownMatrixAt: function(time) {
        return this._knownMatrix !== undefined ? this._knownMatrix : this._knownMatrixFunc !== undefined ? this._knownMatrixFunc(time) : undefined;
      },
      isControl: function() {
        return this._controlBit !== undefined;
      },
      controlBit: function() {
        return this._controlBit;
      },
      effectMightPermutesStates: function() {
        return this._effectPermutesStates !== undefined ? this._effectPermutesStates : this._knownMatrix !== undefined ? !this._knownMatrix.isDiagonal() : true;
      },
      effectMightCreateSuperpositions: function() {
        return this._effectCreatesSuperpositions !== undefined ? this._effectCreatesSuperpositions : this._knownMatrix !== undefined ? !this._knownMatrix.isPhasedPermutation() : true;
      },
      definitelyHasNoEffect: function() {
        return this._hasNoEffect;
      },
      isDefinitelyUnitary: function() {
        return this._isDefinitelyUnitary;
      },
      stableDuration: function() {
        return this._stableDuration !== undefined ? this._stableDuration : this._knownMatrix !== undefined || this._hasNoEffect ? Infinity : 0;
      },
      toString: function() {
        return ("Gate(" + this.symbol + ")");
      }
    }, {
      fromKnownMatrix: function(symbol, matrix) {
        var name = arguments[2] !== (void 0) ? arguments[2] : '';
        var blurb = arguments[3] !== (void 0) ? arguments[3] : '';
        if (!(matrix instanceof Matrix)) {
          throw new DetailedError("Bad matrix.", {
            symbol: symbol,
            matrix: matrix,
            name: name,
            blurb: blurb
          });
        }
        var g = new Gate();
        g.symbol = symbol;
        g.serializedId = symbol;
        g.name = name;
        g.blurb = blurb;
        g._isDefinitelyUnitary = matrix.isUnitary(0.01);
        g._hasNoEffect = matrix.isIdentity();
        g._stableDuration = Infinity;
        g._knownMatrix = matrix;
        return g;
      },
      buildFamily: function(minSize, maxSize, gateBuildFunc) {
        var gates = [];
        for (var span = minSize; span <= maxSize; span++) {
          var builder = new GateBuilder();
          builder.setHeight(span);
          gateBuildFunc(span, builder);
          builder.gate.gateFamily = gates;
          gates.push(builder.gate);
        }
        var ofSize = function(h) {
          var $__6 = true;
          var $__7 = false;
          var $__8 = undefined;
          try {
            for (var $__4 = void 0,
                $__3 = (gates)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
              var g = $__4.value;
              {
                if (g.height === h) {
                  return g;
                }
              }
            }
          } catch ($__9) {
            $__7 = true;
            $__8 = $__9;
          } finally {
            try {
              if (!$__6 && $__3.return != null) {
                $__3.return();
              }
            } finally {
              if ($__7) {
                throw $__8;
              }
            }
          }
          return undefined;
        };
        return {
          all: gates,
          ofSize: ofSize
        };
      }
    });
  }();
  var GateBuilder = function() {
    function GateBuilder() {
      this.gate = new Gate();
    }
    return ($traceurRuntime.createClass)(GateBuilder, {
      setSerializedIdAndSymbol: function(id) {
        this.gate.symbol = id;
        this.gate.serializedId = id;
        return this;
      },
      setSymbol: function(symbol) {
        this.gate.symbol = symbol;
        return this;
      },
      setSerializedId: function(serializedId) {
        this.gate.serializedId = serializedId;
        return this;
      },
      setTitle: function(title) {
        this.gate.name = title;
        return this;
      },
      setBlurb: function(blurb) {
        this.gate.blurb = blurb;
        return this;
      },
      setHeight: function(height) {
        this.gate.height = height;
        return this;
      },
      setWidth: function(width) {
        this.gate.width = width;
        return this;
      },
      setDrawer: function(drawer) {
        this.gate.customDrawer = drawer;
        return this;
      },
      setOnClickGateFunc: function(gateFunc) {
        this.gate.onClickGateFunc = gateFunc;
        return this;
      },
      setKnownEffectToMatrix: function(matrix) {
        if (!(matrix instanceof Matrix)) {
          throw new DetailedError("Bad matrix.", {matrix: matrix});
        }
        this.gate._isDefinitelyUnitary = matrix.isUnitary(0.01);
        this.gate._hasNoEffect = matrix.isIdentity();
        this.gate._stableDuration = Infinity;
        this.gate._knownMatrix = matrix;
        return this;
      },
      setKnownEffectToPermutation: function(permutationFunc) {
        var $__2 = this;
        this.gate.knownPermutationFuncTakingInputs = permutationFunc;
        this.gate._knownMatrixFunc = function(_) {
          return Matrix.generateTransition(1 << $__2.gate.height, permutationFunc);
        };
        this.gate._stableDuration = Infinity;
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = true;
        this.gate._effectCreatesSuperpositions = false;
        this.gate._isDefinitelyUnitary = true;
        return this;
      },
      setKnownEffectToBitPermutation: function(knownBitPermutationFunc) {
        this.gate.knownBitPermutationFunc = knownBitPermutationFunc;
        this.gate._isDefinitelyUnitary = true;
        this.gate._stableDuration = Infinity;
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = true;
        this.gate._effectCreatesSuperpositions = false;
        return this;
      },
      setKnownEffectToTimeVaryingPermutation: function(timeVaryingPermutationFunc) {
        var g = this.gate;
        g._stableDuration = 0;
        g._knownMatrixFunc = function(t) {
          return Matrix.generateTransition(1 << g.height, function(i) {
            return timeVaryingPermutationFunc(t, i);
          });
        };
        g._hasNoEffect = false;
        g._effectPermutesStates = true;
        g._effectCreatesSuperpositions = false;
        g._isDefinitelyUnitary = true;
        return this;
      },
      setKnownEffectToParametrizedPermutation: function(permutationFunc) {
        var g = this.gate;
        g.knownPermutationFuncTakingInputs = permutationFunc;
        g._knownMatrixFunc = undefined;
        g._stableDuration = Infinity;
        g._hasNoEffect = false;
        g._effectPermutesStates = true;
        g._effectCreatesSuperpositions = false;
        g._isDefinitelyUnitary = true;
        return this;
      },
      setKnownEffectToPhaser: function(phaseTurnsFunc) {
        var $__2 = this;
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = false;
        this.gate._effectCreatesSuperpositions = false;
        this.gate._isDefinitelyUnitary = true;
        this.gate._stableDuration = Infinity;
        this.gate.knownPhaseTurnsFunc = phaseTurnsFunc;
        this.gate._knownMatrixFunc = function() {
          return Matrix.generateDiagonal(1 << $__2.gate.height, function(k) {
            return Complex.polar(1, Math.PI * 2 * phaseTurnsFunc(k));
          });
        };
        return this;
      },
      setTooltipMatrixFunc: function(matrixFunc) {
        this.gate._knownMatrixFunc = function(_) {
          return matrixFunc();
        };
        this.gate._stableDuration = Infinity;
        return this;
      },
      setKnownEffectToCircuit: function(circuitDefinition) {
        this.gate.knownCircuit = circuitDefinition;
        this.gate.knownCircuitNested = circuitDefinition.withDisabledReasonsForEmbeddedContext(0, new Map());
        this.gate._isDefinitelyUnitary = circuitDefinition.hasOnlyUnitaryGates();
        this.gate._stableDuration = circuitDefinition.stableDuration();
        this.gate.height = circuitDefinition.numWires;
        return this;
      },
      setEffectToTimeVaryingMatrix: function(timeToMatrixFunc) {
        this.gate._stableDuration = 0;
        this.gate._knownMatrixFunc = timeToMatrixFunc;
        this.gate._hasNoEffect = false;
        return this;
      },
      setActualEffectToUpdateFunc: function(circuitUpdateFunc) {
        if (circuitUpdateFunc !== undefined && typeof circuitUpdateFunc !== "function") {
          throw new DetailedError("Bad customOperation", {circuitUpdateFunc: circuitUpdateFunc});
        }
        this.gate.customOperation = circuitUpdateFunc;
        return this;
      },
      setActualEffectToShaderProvider: function(shaderFunc) {
        return this.setActualEffectToUpdateFunc(function(ctx) {
          return ctx.applyOperation(shaderFunc);
        });
      },
      promiseEffectOnlyPermutesAndPhases: function() {
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = true;
        this.gate._effectCreatesSuperpositions = false;
        this.gate._isDefinitelyUnitary = true;
        return this;
      },
      promiseEffectIsDiagonal: function() {
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = false;
        this.gate._effectCreatesSuperpositions = false;
        return this;
      },
      promiseEffectOnlyPhases: function() {
        this.gate._hasNoEffect = false;
        this.gate._effectPermutesStates = false;
        this.gate._effectCreatesSuperpositions = false;
        this.gate._isDefinitelyUnitary = true;
        return this;
      },
      promiseEffectIsUnitary: function() {
        this.gate._isDefinitelyUnitary = true;
        return this;
      },
      promiseEffectIsStable: function() {
        this.gate._stableDuration = Infinity;
        return this;
      },
      promiseHasNoNetEffectOnStateVector: function() {
        this.gate._stableDuration = Infinity;
        this.gate._hasNoEffect = true;
        this.gate._isDefinitelyUnitary = true;
        this.gate._effectPermutesStates = false;
        this.gate._effectCreatesSuperpositions = false;
        return this;
      },
      promiseHasNoNetEffectOnStateVectorButStillRequiresDynamicRedraw: function() {
        this.promiseHasNoNetEffectOnStateVector();
        this.gate._stableDuration = 0;
        return this;
      },
      markAsNotInterestedInControls: function() {
        this.gate.interestedInControls = false;
        return this;
      },
      markAsControlExpecting: function(bit) {
        this.gate._controlBit = bit;
        this.gate.isControlWireSource = true;
        this.gate._isDefinitelyUnitary = true;
        this.gate.interestedInControls = false;
        return this;
      },
      markAsReachingOtherWires: function() {
        this.gate._showAsReachesOtherWires = true;
        return this;
      },
      markAsDrawerNeedsSingleQubitDensityStats: function() {
        this.gate.isSingleQubitDisplay = true;
        return this;
      },
      setRequiredContextKeys: function() {
        for (var keys = [],
            $__10 = 0; $__10 < arguments.length; $__10++)
          keys[$__10] = arguments[$__10];
        this.gate._requiredContextKeys = keys;
        return this;
      },
      setContextProvider: function(customColumnContextProvider) {
        this.gate.customColumnContextProvider = customColumnContextProvider;
        this.gate.isContextTemporary = true;
        return this;
      },
      setStickyContextProvider: function(customColumnContextProvider) {
        this.gate.customColumnContextProvider = customColumnContextProvider;
        this.gate.isContextTemporary = false;
        return this;
      },
      setSetupCleanupEffectsToShaderProviders: function(beforeColumnShaderFunc, afterColumnShaderFunc) {
        return this.setSetupCleanupEffectToUpdateFunc(beforeColumnShaderFunc === undefined ? undefined : function(ctx) {
          return ctx.applyOperation(beforeColumnShaderFunc);
        }, afterColumnShaderFunc === undefined ? undefined : function(ctx) {
          return ctx.applyOperation(afterColumnShaderFunc);
        });
      },
      setSetupCleanupEffectToUpdateFunc: function(beforeColumnUpdateFunc, afterColumnUpdateFunc) {
        if (beforeColumnUpdateFunc !== undefined && typeof beforeColumnUpdateFunc !== "function") {
          throw new DetailedError("Bad beforeColumnUpdateFunc", {customOperation: customOperation});
        }
        if (afterColumnUpdateFunc !== undefined && typeof afterColumnUpdateFunc !== "function") {
          throw new DetailedError("Bad afterColumnUpdateFunc", {customOperation: customOperation});
        }
        this.gate.customBeforeOperation = beforeColumnUpdateFunc;
        this.gate.customAfterOperation = afterColumnUpdateFunc;
        return this;
      },
      setExtraDisableReasonFinder: function(customDisableReasonFinder) {
        this.gate.customDisableReasonFinder = customDisableReasonFinder;
        return this;
      },
      setStatTexturesMaker: function(statTexturesMaker) {
        this.gate.customStatTexturesMaker = statTexturesMaker;
        return this;
      },
      setStatPixelDataPostProcessor: function(pixelFunc) {
        this.gate.customStatPostProcesser = pixelFunc;
        return this;
      },
      setTag: function(tag) {
        this.gate.tag = tag;
        return this;
      }
    }, {});
  }();
  return {
    get Gate() {
      return Gate;
    },
    get GateBuilder() {
      return GateBuilder;
    }
  };
});
//# sourceURL=src/circuit/Gate.js
;$traceurRuntime.registerModule("src/circuit/GateCheckArgs.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/GateCheckArgs.js";
  var GateCheckArgs = function() {
    function GateCheckArgs(gate, innerColumn, outerRow, measuredMask, context, isNested) {
      this.gate = gate;
      this.innerColumn = innerColumn;
      this.outerRow = outerRow;
      this.measuredMask = measuredMask;
      this.context = context;
      this.isNested = isNested;
    }
    return ($traceurRuntime.createClass)(GateCheckArgs, {}, {});
  }();
  return {get GateCheckArgs() {
      return GateCheckArgs;
    }};
});
//# sourceURL=src/circuit/GateCheckArgs.js
;$traceurRuntime.registerModule("src/circuit/GateColumn.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/GateColumn.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/GateColumn.js")).DetailedError;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/circuit/GateColumn.js")).Gate;
  var GateCheckArgs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateCheckArgs.js", "src/circuit/GateColumn.js")).GateCheckArgs;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/AllGates.js", "src/circuit/GateColumn.js")).Gates;
  var $__15 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/circuit/GateColumn.js")),
      seq = $__15.seq,
      Seq = $__15.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/GateColumn.js")).Util;
  var GateColumn = function() {
    function GateColumn(gates) {
      this.gates = gates;
    }
    return ($traceurRuntime.createClass)(GateColumn, {
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof GateColumn && seq(this.gates).isEqualTo(seq(other.gates), Util.STRICT_EQUALITY);
      },
      stableDuration: function() {
        var $__10;
        return ($__10 = Math).min.apply($__10, $traceurRuntime.spread([Infinity], this.gates.filter(function(e) {
          return e !== undefined;
        }).map(function(e) {
          return e.stableDuration();
        })));
      },
      isEmpty: function() {
        return this.gates.every(function(e) {
          return e === undefined;
        });
      },
      hasControl: function(inputMeasureMask) {
        return this.hasCoherentControl(inputMeasureMask) || this.hasMeasuredControl(inputMeasureMask);
      },
      hasCoherentControl: function(inputMeasureMask) {
        for (var i = 0; i < this.gates.length; i++) {
          if ((inputMeasureMask & (1 << i)) === 0 && this.gates[i] !== undefined && this.gates[i].isControl()) {
            return true;
          }
        }
        return false;
      },
      hasMeasuredControl: function(inputMeasureMask) {
        for (var i = 0; i < this.gates.length; i++) {
          if ((inputMeasureMask & (1 << i)) !== 0 && this.gates[i] !== undefined && this.gates[i].definitelyHasNoEffect() && this.gates[i].isControl()) {
            return true;
          }
        }
        return false;
      },
      _disabledReason: function(inputMeasureMask, row, outerRowOffset, context, isNested) {
        var g = this.gates[row];
        if (g === undefined) {
          return undefined;
        }
        var args = new GateCheckArgs(g, this, outerRowOffset + row, inputMeasureMask, context, isNested);
        return g.customDisableReasonFinder(args) || GateColumn._disabledReason_inputs(args) || this._disabledReason_controlInside(row) || this._disabledReason_remixing(row, inputMeasureMask) || this._disabledReason_overlappingTags(outerRowOffset, row);
      },
      _disabledReason_overlappingTags: function(outerRow, row) {
        var keys = new Set(this.gates[row].customColumnContextProvider(outerRow + row, this.gates[row]).map(function(e) {
          return e.key;
        }));
        if (keys.length === 0) {
          return undefined;
        }
        for (var i = 0; i < row; i++) {
          var g = this.gates[i];
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (g === undefined ? [] : g.customColumnContextProvider(outerRow + i, g))[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var otherKey = $__3.value.key;
              {
                if (keys.has(otherKey)) {
                  return "already\ndefined";
                }
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        }
        return undefined;
      },
      _disabledReason_remixing: function(row, inputMeasureMask) {
        var g = this.gates[row];
        var mask = ((1 << g.height) - 1) << row;
        var maskMeasured = mask & inputMeasureMask;
        if (maskMeasured !== 0) {
          if (g.effectMightCreateSuperpositions()) {
            return "no\nremix\n(sorry)";
          }
          if (g.effectMightPermutesStates()) {
            if (maskMeasured !== mask && (g.knownBitPermutationFunc === undefined || this.hasMeasuredControl(inputMeasureMask))) {
              return "no\nremix\n(sorry)";
            }
            if (this.hasCoherentControl(inputMeasureMask)) {
              return "no\nremix\n(sorry)";
            }
          }
        }
        return undefined;
      },
      hasGatesWithGlobalEffects: function() {
        for (var i = 0; i < this.gates.length; i++) {
          var gate = this.gates[i];
          if (gate !== undefined && gate.shouldShowAsHavingGlobalEffect()) {
            return true;
          }
        }
        return false;
      },
      indexOfNonUnitaryGate: function() {
        for (var i = 0; i < this.gates.length; i++) {
          var gate = this.gates[i];
          if (gate !== undefined && !gate.isDefinitelyUnitary()) {
            return i;
          }
        }
        return undefined;
      },
      _disabledReason_controlInside: function(row) {
        var g = this.gates[row];
        for (var j = 1; j < g.height && row + j < this.gates.length; j++) {
          if (this.gates[row + j] !== undefined && this.gates[row + j].isControl()) {
            return "control\ninside";
          }
        }
        return undefined;
      },
      minimumRequiredWireCount: function() {
        var best = 0;
        for (var i = 0; i < this.gates.length; i++) {
          if (this.gates[i] !== undefined) {
            best = Math.max(best, this.gates[i].height + i);
          }
        }
        return best;
      },
      maximumGateWidth: function() {
        var best = -Infinity;
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (this.gates)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var g = $__3.value;
            {
              if (g !== undefined) {
                best = Math.max(best, g.width);
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return best;
      },
      perRowDisabledReasons: function(inputMeasureMask, outerRowOffset, outerContext, prevStickyCtx, isNested) {
        var context = Util.mergeMaps(outerContext, prevStickyCtx);
        var stickyCtx = new Map(prevStickyCtx);
        for (var row = this.gates.length - 1; row >= 0; row--) {
          var g = this.gates[row];
          if (g !== undefined) {
            var $__5 = true;
            var $__6 = false;
            var $__7 = undefined;
            try {
              for (var $__3 = void 0,
                  $__2 = (g.customColumnContextProvider(row + outerRowOffset, g))[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                var $__9 = $__3.value,
                    key = $__9.key,
                    val = $__9.val;
                {
                  context.set(key, val);
                  if (!g.isContextTemporary) {
                    stickyCtx.set(key, val);
                  }
                }
              }
            } catch ($__8) {
              $__6 = true;
              $__7 = $__8;
            } finally {
              try {
                if (!$__5 && $__2.return != null) {
                  $__2.return();
                }
              } finally {
                if ($__6) {
                  throw $__7;
                }
              }
            }
          }
        }
        var allReasons = [];
        for (var i = 0; i < this.gates.length; i++) {
          allReasons.push(this._disabledReason(inputMeasureMask, i, outerRowOffset, context, isNested));
        }
        return {
          allReasons: allReasons,
          stickyCtx: stickyCtx
        };
      },
      _updateMeasureMask_gateStep: function(state, row, disabledReasons) {
        if (disabledReasons[row] !== undefined) {
          return;
        }
        var gate = this.gates[row];
        if (gate === undefined) {
          return;
        }
        if (gate === Gates.Special.Measurement) {
          state.measureMask |= 1 << row;
          return;
        }
        var hasSingleResult = gate === Gates.PostSelectionGates.PostSelectOn || gate === Gates.PostSelectionGates.PostSelectOff || gate === Gates.Detector;
        if (!this.hasControl() && hasSingleResult) {
          state.measureMask &= ~(1 << row);
          return;
        }
        GateColumn._updateMeasureMask_swapGate(gate, state, row);
        GateColumn._updateMeasureMask_customPermute(gate, state, row);
      },
      nextMeasureMask: function(inputMeasureMask, disabledReasons) {
        var state = {
          measureMask: inputMeasureMask,
          earlierRowWithSwapGate: undefined
        };
        for (var row = 0; row < this.gates.length; row++) {
          this._updateMeasureMask_gateStep(state, row, disabledReasons);
        }
        return state.measureMask;
      },
      withGatesAdded: function(startIndex, insertedCol) {
        if (!Number.isInteger(startIndex) || startIndex < 0 || startIndex > this.gates.length - insertedCol.gates.length) {
          throw new DetailedError("Bad start index", {
            baseCol: this,
            startIndex: startIndex,
            insertedCol: insertedCol
          });
        }
        var gates = this.gates.map(function(e) {
          return e;
        });
        for (var i = 0; i < insertedCol.gates.length; i++) {
          gates[startIndex + i] = insertedCol.gates[i];
        }
        return new GateColumn(gates);
      }
    }, {
      empty: function(qubitCount) {
        return new GateColumn(new Array(qubitCount).fill(undefined));
      },
      _disabledReason_inputs: function(args) {
        var rangeVals = [];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (args.gate.getUnmetContextKeys())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              if (key.startsWith("Input Range ") && args.context.has(key)) {
                rangeVals.push(args.context.get(key));
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return GateColumn._disabledReason_inputs_missing(args) || GateColumn._disabledReason_inputs_inside(args, rangeVals) || GateColumn._disabledReason_inputs_coherenceMismatch(args, rangeVals);
      },
      _disabledReason_inputs_missing: function(args) {
        var missing = [];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (args.gate.getUnmetContextKeys())[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var key = $__3.value;
            {
              var altKey = key.replace("Input Range ", "Input Default ").replace("Input NO_DEFAULT Range ", "Input Range ");
              if (!args.context.has(key) && !args.context.has(altKey) && !args.isNested) {
                missing.push(key);
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        if (missing.length > 0) {
          return "Need\nInput\n " + missing.map(function(e) {
            return e.replace("Input NO_DEFAULT Range ", "").replace("Input Range ", "");
          }).join(", ");
        }
        return undefined;
      },
      _disabledReason_inputs_inside: function(args, rangeVals) {
        var row = args.outerRow;
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (rangeVals)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__9 = $__3.value,
                offset = $__9.offset,
                length = $__9.length;
            {
              if (offset + length > row && row + args.gate.height > offset) {
                return "input\ninside";
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        return undefined;
      },
      _disabledReason_inputs_coherenceMismatch: function(args, rangeVals) {
        var row = args.outerRow;
        if (args.gate.effectMightPermutesStates()) {
          var hasMeasuredOutputs = ((args.measuredMask >> row) & ((1 << args.gate.height) - 1)) !== 0;
          if (hasMeasuredOutputs) {
            var $__5 = true;
            var $__6 = false;
            var $__7 = undefined;
            try {
              for (var $__3 = void 0,
                  $__2 = (rangeVals)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
                var $__9 = $__3.value,
                    offset = $__9.offset,
                    length = $__9.length;
                {
                  if (((~args.measuredMask >> offset) & ((1 << length) - 1)) !== 0) {
                    return "no\nremix\n(sorry)";
                  }
                }
              }
            } catch ($__8) {
              $__6 = true;
              $__7 = $__8;
            } finally {
              try {
                if (!$__5 && $__2.return != null) {
                  $__2.return();
                }
              } finally {
                if ($__6) {
                  throw $__7;
                }
              }
            }
          }
        }
        return undefined;
      },
      _updateMeasureMask_swapGate: function(gate, state, row) {
        if (gate !== Gates.Special.SwapHalf) {
          return;
        }
        if (state.earlierRowWithSwapGate === undefined) {
          state.earlierRowWithSwapGate = row;
          return;
        }
        var other = 1 << state.earlierRowWithSwapGate;
        var d = row - state.earlierRowWithSwapGate;
        var bit = 1 << row;
        state.measureMask = (state.measureMask & ~(other | bit)) | ((state.measureMask & other) << d) | ((state.measureMask & bit) >> d);
        state.earlierRowWithSwapGate = undefined;
      },
      _updateMeasureMask_customPermute: function(gate, state, row) {
        if (gate.knownBitPermutationFunc === undefined) {
          return;
        }
        var mask = ((1 << gate.height) - 1) << row;
        var prev = state.measureMask & mask;
        state.measureMask &= ~mask;
        for (var i = 0; i < gate.height; i++) {
          var prevBit = 1 << (row + i);
          if ((prev & prevBit) !== 0) {
            var nextBit = 1 << (row + gate.knownBitPermutationFunc(i));
            state.measureMask |= nextBit;
          }
        }
      }
    });
  }();
  return {get GateColumn() {
      return GateColumn;
    }};
});
//# sourceURL=src/circuit/GateColumn.js
;$traceurRuntime.registerModule("src/circuit/GateShaders.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/GateShaders.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/GateShaders.js")).DetailedError;
  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/circuit/GateShaders.js")),
      ketArgs = $__8.ketArgs,
      ketShader = $__8.ketShader;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/circuit/GateShaders.js")).Matrix;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/Shaders.js", "src/circuit/GateShaders.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/GateShaders.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/circuit/GateShaders.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/circuit/GateShaders.js")).WglConfiguredShader;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/circuit/GateShaders.js")),
      Inputs = $__14.Inputs,
      Outputs = $__14.Outputs,
      currentShaderCoder = $__14.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__14.makePseudoShaderWithInputsAndOutputAndCode;
  var GateShaders = function() {
    function GateShaders() {}
    return ($traceurRuntime.createClass)(GateShaders, {}, {});
  }();
  function _applySingleQubitOperationFunc(ctx, matrix) {
    var $__5;
    var $__3,
        $__4;
    if (matrix.width() !== 2 || matrix.height() !== 2) {
      throw new DetailedError("Not a single-qubit operation.", {matrix: matrix});
    }
    var $__2 = matrix.rawBuffer(),
        ar = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
        ai = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        br = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        bi = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        cr = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        ci = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        dr = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        di = ($__4 = $__3.next()).done ? void 0 : $__4.value;
    ctx.applyOperation(($__5 = CUSTOM_SINGLE_QUBIT_OPERATION_SHADER).withArgs.apply($__5, $traceurRuntime.spread(ketArgs(ctx), [WglArg.vec2("a", ar, ai), WglArg.vec2("b", br, bi), WglArg.vec2("c", cr, ci), WglArg.vec2("d", dr, di)])));
  }
  var CUSTOM_SINGLE_QUBIT_OPERATION_SHADER = ketShader('uniform vec2 a, b, c, d;', 'return cmul(inp(0.0), a+(c-a)*out_id) + cmul(inp(1.0), b+(d-b)*out_id);', 1);
  var hugeQubitOperationMaker = function(qubitCount) {
    return ketShader('', ("\n        vec2 t = vec2(0.0, 0.0);\n        for (int k = 0; k < " + (1 << qubitCount) + "; k++) {\n            t += cmul(inp(float(k)),\n                      read_coefs(out_id * " + (1 << qubitCount) + ".0 + float(k)));\n        }\n        return t;\n    "), qubitCount, [Inputs.vec2('coefs')]);
  };
  var multiQubitOperationMaker = function(qubitCount) {
    return ketShader(("uniform vec4 coefs[" + (1 << (2 * qubitCount - 1)) + "];"), ("\n        int row = int(out_id);\n        vec2 t = vec2(0.0, 0.0);\n        for (int d = 0; d < " + (1 << qubitCount) + "; d++) {\n            // Can't index by row, since it's not a constant, so we do a const brute force loop searching for it.\n            if (d == row) {\n                for (int k = 0; k < " + (1 << (qubitCount - 1)) + "; k++) {\n                    vec4 u = coefs[d*" + (1 << (qubitCount - 1)) + " + k];\n                    t += cmul(inp(float(k*2)), u.xy);\n                    t += cmul(inp(float(k*2+1)), u.zw);\n                }\n            }\n        }\n        return t;\n    "), qubitCount);
  };
  var matrix_operation_shaders = [undefined, undefined, multiQubitOperationMaker(2), multiQubitOperationMaker(3), hugeQubitOperationMaker(4)];
  GateShaders.applyMatrixOperation = function(ctx, matrix) {
    var $__5,
        $__6;
    if (!Util.isPowerOf2(matrix.width())) {
      throw new DetailedError("Matrix size isn't a power of 2.", {
        ctx: ctx,
        matrix: matrix
      });
    }
    if (matrix.width() === 2) {
      _applySingleQubitOperationFunc(ctx, matrix);
      return;
    }
    var sizePower = Math.round(Math.log2(matrix.width()));
    if (sizePower <= 3) {
      ctx.applyOperation(($__5 = matrix_operation_shaders[sizePower]).withArgs.apply($__5, $traceurRuntime.spread(ketArgs(ctx), [WglArg.vec4_array("coefs", matrix.rawBuffer())])));
      return;
    }
    if (sizePower <= 4) {
      var tex = Shaders.data(currentShaderCoder().vec2.dataToPixels(matrix.rawBuffer())).toVec2Texture(sizePower * 2);
      try {
        ctx.applyOperation(($__6 = matrix_operation_shaders[sizePower]).withArgs.apply($__6, $traceurRuntime.spread([tex], ketArgs(ctx))));
      } finally {
        tex.deallocByDepositingInPool();
      }
      return;
    }
    throw new DetailedError("Matrix is past 4 qubits. Too expensive.", {
      ctx: ctx,
      matrix: matrix
    });
  };
  GateShaders.cycleAllBits = function(inputTexture, shiftAmount) {
    var size = currentShaderCoder().vec2.arrayPowerSizeOfTexture(inputTexture);
    return CYCLE_ALL_SHADER_VEC2(inputTexture, WglArg.float("shiftAmount", 1 << Util.properMod(-shiftAmount, size)));
  };
  var CYCLE_ALL_SHADER_VEC2 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), "\n    uniform float shiftAmount;\n\n    vec2 outputFor(float k) {\n        float span = len_input();\n        float shiftedState = k * shiftAmount;\n        float cycledState = mod(shiftedState, span) + floor(shiftedState / span);\n        return read_input(cycledState);\n    }");
  GateShaders.cycleAllBitsFloat = function(inputTexture, shiftAmount) {
    var size = currentShaderCoder().vec2.arrayPowerSizeOfTexture(inputTexture);
    return CYCLE_ALL_SHADER_FLOAT(inputTexture, WglArg.float("shiftAmount", 1 << Util.properMod(-shiftAmount, size)));
  };
  var CYCLE_ALL_SHADER_FLOAT = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('input')], Outputs.float(), "\n    uniform float shiftAmount;\n\n    float outputFor(float k) {\n        float span = len_input();\n        float shiftedState = k * shiftAmount;\n        float cycledState = mod(shiftedState, span) + floor(shiftedState / span);\n        return read_input(cycledState);\n    }");
  return {get GateShaders() {
      return GateShaders;
    }};
});
//# sourceURL=src/circuit/GateShaders.js
;$traceurRuntime.registerModule("src/circuit/KetShaderUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/KetShaderUtil.js";
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/circuit/KetShaderUtil.js")).WglArg;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/circuit/KetShaderUtil.js")),
      makePseudoShaderWithInputsAndOutputAndCode = $__10.makePseudoShaderWithInputsAndOutputAndCode,
      Inputs = $__10.Inputs,
      Outputs = $__10.Outputs;
  var ketShader = function(head, body) {
    var span = arguments[2] !== (void 0) ? arguments[2] : null;
    var inputs = arguments[3] !== (void 0) ? arguments[3] : [];
    return ({withArgs: makePseudoShaderWithInputsAndOutputAndCode($traceurRuntime.spread(inputs, [Inputs.vec2('ketgen_ket'), Inputs.bool('ketgen_control')]), Outputs.vec2(), ("\n    uniform float _ketgen_step;\n    " + (span === null ? 'uniform float span;' : '') + "\n    float _ketgen_off;\n    float full_out_id;\n\n    " + (body.match(/\bcmul\b/) ? 'vec2 cmul(vec2 c1, vec2 c2) { return mat2(c1.x, c1.y, -c1.y, c1.x) * c2; }' : '') + "\n    " + (body.match(/\binp\b/) ? 'vec2 inp(float k) { return read_ketgen_ket(_ketgen_off + _ketgen_step*k); }' : '') + "\n\n    " + head + "\n\n    vec2 _ketgen_output_for(float out_id, vec2 amp) {\n        " + body + "\n    }\n\n    vec2 outputFor(float k) {\n        full_out_id = k;\n\n        float relevant_out_id = mod(floor(full_out_id / _ketgen_step), " + (span === null ? 'span' : (1 << span) + '.0') + ");\n        _ketgen_off = full_out_id - relevant_out_id*_ketgen_step;\n\n        float c = read_ketgen_control(full_out_id);\n        vec2 vc = read_ketgen_ket(full_out_id);\n        vec2 vt = _ketgen_output_for(relevant_out_id, vc);\n        return (1.0-c)*vc + c*vt;\n    }"))});
  };
  var ketShaderPermute = function(head, body) {
    var span = arguments[2] !== (void 0) ? arguments[2] : null;
    return ketShader(head + ("float _ketgen_input_for(float out_id) { " + body + " }"), 'return inp(_ketgen_input_for(out_id));', span);
  };
  var ketShaderPhase = function(head, body) {
    var span = arguments[2] !== (void 0) ? arguments[2] : null;
    return ketShader((head + "\n        float _ketgen_phase_for(float out_id) {\n            " + body + "\n        }\n    "), "\n        float angle = _ketgen_phase_for(out_id);\n        return cmul(amp, vec2(cos(angle), sin(angle)));\n    ", span);
  };
  function ketArgs(ctx) {
    var $__8;
    var span = arguments[1];
    var input_letters = arguments[2] !== (void 0) ? arguments[2] : [];
    var result = [ctx.stateTrader.currentTexture, ctx.controlsTexture, WglArg.float("_ketgen_step", 1 << ctx.row)];
    if (span !== undefined) {
      result.push(WglArg.float('span', 1 << span));
    }
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (input_letters)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var letter = $__2.value;
        {
          ($__8 = result).push.apply($__8, $traceurRuntime.spread(ketInputGateArgs(ctx, letter)));
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    return result;
  }
  function ketInputGateShaderCode(letter) {
    return ("\n        //////// INPUT GATE " + letter + " ////////\n        uniform float _gen_input_default_" + letter + ";\n        uniform float _gen_input_offset_" + letter + ";\n        uniform float _gen_input_span_" + letter + ";\n        \n        float read_input_" + letter + "() {\n            return _gen_input_span_" + letter + " == 0.0\n                ? _gen_input_default_" + letter + "\n                : mod(floor(full_out_id / _gen_input_offset_" + letter + "), _gen_input_span_" + letter + ");\n        }");
  }
  function ketInputGateArgs(ctx, letter) {
    var offset = 0;
    var length = -1;
    var defaultVal = ctx.customContextFromGates.get(("Input Default " + letter)) || 0;
    var inputCtx = ctx.customContextFromGates.get(("Input Range " + letter));
    if (inputCtx !== undefined) {
      offset = inputCtx.offset;
      length = inputCtx.length;
    }
    return [WglArg.float(("_gen_input_default_" + letter), defaultVal), WglArg.float(("_gen_input_offset_" + letter), 1 << offset), WglArg.float(("_gen_input_span_" + letter), length === -1 ? 0 : 1 << length)];
  }
  return {
    get ketArgs() {
      return ketArgs;
    },
    get ketShader() {
      return ketShader;
    },
    get ketShaderPermute() {
      return ketShaderPermute;
    },
    get ketShaderPhase() {
      return ketShaderPhase;
    },
    get ketInputGateShaderCode() {
      return ketInputGateShaderCode;
    },
    get ketInputGateArgs() {
      return ketInputGateArgs;
    }
  };
});
//# sourceURL=src/circuit/KetShaderUtil.js
;$traceurRuntime.registerModule("src/circuit/KetTextureUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/KetTextureUtil.js";
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitShaders.js", "src/circuit/KetTextureUtil.js")).CircuitShaders;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Controls.js", "src/circuit/KetTextureUtil.js")).Controls;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/KetTextureUtil.js")).DetailedError;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/circuit/KetTextureUtil.js")).Matrix;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/Shaders.js", "src/circuit/KetTextureUtil.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/KetTextureUtil.js")).Util;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexture.js", "src/circuit/KetTextureUtil.js")).WglTexture;
  var $__25 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/circuit/KetTextureUtil.js")),
      seq = $__25.seq,
      Seq = $__25.Seq;
  var $__26 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/circuit/KetTextureUtil.js")),
      outputShaderCoder = $__26.outputShaderCoder,
      currentShaderCoder = $__26.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__26.makePseudoShaderWithInputsAndOutputAndCode,
      Inputs = $__26.Inputs,
      Outputs = $__26.Outputs;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexturePool.js", "src/circuit/KetTextureUtil.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTextureTrader.js", "src/circuit/KetTextureUtil.js")).WglTextureTrader;
  var KetTextureUtil = function() {
    function KetTextureUtil() {}
    return ($traceurRuntime.createClass)(KetTextureUtil, {}, {});
  }();
  KetTextureUtil.tradeTextureForVec2Output = function(trader) {
    if (currentShaderCoder().vec2.needRearrangingToBeInVec4Format) {
      trader.shadeHalveAndTrade(Shaders.packVec2IntoVec4);
    }
    return KetTextureUtil.tradeTextureForVec4Output(trader);
  };
  KetTextureUtil.tradeTextureForVec4Output = function(trader) {
    if (outputShaderCoder() === currentShaderCoder()) {
      var result$__16 = currentShaderCoder().vec4.pixelsToData(trader.currentTexture.readPixels());
      trader.currentTexture.deallocByDepositingInPool("tradeTextureForVec4Output");
      return result$__16;
    }
    var sizePower = currentShaderCoder().vec4.arrayPowerSizeOfTexture(trader.currentTexture);
    var adjustedSizePower = sizePower + outputShaderCoder().vec4.powerSizeOverhead;
    trader.shadeAndTrade(Shaders.convertVec4CodingForOutput, WglTexturePool.take(adjustedSizePower, outputShaderCoder().vec4.pixelType));
    var result = outputShaderCoder().vec4.pixelsToData(trader.currentTexture.readPixels());
    trader.currentTexture.deallocByDepositingInPool("tradeTextureForVec4Output");
    return result;
  };
  KetTextureUtil.mergedReadFloats = function(textures) {
    var len = function(tex) {
      return tex.width === 0 ? 0 : 1 << currentShaderCoder().vec4.arrayPowerSizeOfTexture(tex);
    };
    var totalPowerSize = Math.round(Math.log2(Util.ceilingPowerOf2(seq(textures).map(len).sum())));
    var trader = new WglTextureTrader(Shaders.color(0, 0, 0, 0).toVec4Texture(totalPowerSize));
    var offset = 0;
    var $__5 = true;
    var $__6 = false;
    var $__7 = undefined;
    try {
      var $__17 = function() {
        var tex = $__3.value;
        {
          if (tex.width > 0) {
            trader.shadeAndTrade(function(acc) {
              return CircuitShaders.linearOverlay(offset, tex, acc);
            });
          }
          offset += len(tex);
        }
      };
      for (var $__3 = void 0,
          $__2 = (textures)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
        $__17();
      }
    } catch ($__8) {
      $__6 = true;
      $__7 = $__8;
    } finally {
      try {
        if (!$__5 && $__2.return != null) {
          $__2.return();
        }
      } finally {
        if ($__6) {
          throw $__7;
        }
      }
    }
    var combinedPixels = KetTextureUtil.tradeTextureForVec4Output(trader);
    var result = [];
    var pixelOffset = 0;
    var $__12 = true;
    var $__13 = false;
    var $__14 = undefined;
    try {
      for (var $__10 = void 0,
          $__9 = (textures)[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
        var tex = $__10.value;
        {
          var pixelLen = len(tex) << 2;
          result.push(combinedPixels.subarray(pixelOffset, pixelOffset + pixelLen));
          pixelOffset += pixelLen;
          tex.deallocByDepositingInPool();
        }
      }
    } catch ($__15) {
      $__13 = true;
      $__14 = $__15;
    } finally {
      try {
        if (!$__12 && $__9.return != null) {
          $__9.return();
        }
      } finally {
        if ($__13) {
          throw $__14;
        }
      }
    }
    return result;
  };
  KetTextureUtil.pixelsToAmplitudes = function(pixels, unity) {
    if (unity < 0.000001) {
      unity = NaN;
    }
    var d = Math.sqrt(unity);
    var n = pixels.length >> 1;
    var buf = new Float32Array(n * 2);
    for (var i = 0; i < pixels.length; i++) {
      buf[i] = pixels[i] / d;
    }
    return new Matrix(1, n, buf);
  };
  KetTextureUtil.superpositionToQubitDensities = function(stateTex, controls, keptBitMask) {
    if (keptBitMask === 0) {
      return new WglTexture(0, 0, currentShaderCoder().vec4.pixelType);
    }
    var hasControls = !controls.isEqualTo(Controls.NONE);
    var trader = new WglTextureTrader(stateTex);
    trader.dontDeallocCurrentTexture();
    if (hasControls) {
      var n = currentShaderCoder().vec2.arrayPowerSizeOfTexture(stateTex) - controls.includedBitCount();
      trader.shadeAndTrade(function(t) {
        return CircuitShaders.controlSelect(controls, t);
      }, WglTexturePool.takeVec2Tex(n));
    }
    var p = 1;
    for (var i = 1; i <= controls.inclusionMask; i <<= 1) {
      if ((controls.inclusionMask & i) === 0) {
        p <<= 1;
      } else {
        keptBitMask = (keptBitMask & (p - 1)) | ((keptBitMask & ~(p - 1)) >> 1);
      }
    }
    _superpositionTexToUnsummedQubitDensitiesTex(trader, keptBitMask);
    var keptQubitCount = Util.numberOfSetBits(keptBitMask);
    _sumDownVec4(trader, keptQubitCount);
    return trader.currentTexture;
  };
  function _superpositionTexToUnsummedQubitDensitiesTex(trader, keptBitMask) {
    if (keptBitMask === 0) {
      throw new DetailedError("keptBitMask === 0", {
        trader: trader,
        keptBitMask: keptBitMask
      });
    }
    var startingQubitCount = currentShaderCoder().vec2.arrayPowerSizeOfTexture(trader.currentTexture);
    var remainingQubitCount = Util.numberOfSetBits(keptBitMask);
    trader.shadeAndTrade(function(tex) {
      return CircuitShaders.qubitDensities(tex, keptBitMask);
    }, WglTexturePool.takeVec4Tex(startingQubitCount - 1 + Util.ceilLg2(remainingQubitCount)));
  }
  function _sumDownVec4(trader, outCount) {
    var outputSizePower = Util.ceilLg2(outCount);
    var curSizePower = currentShaderCoder().vec4.arrayPowerSizeOfTexture(trader.currentTexture);
    while (curSizePower > outputSizePower) {
      trader.shadeHalveAndTrade(Shaders.sumFoldVec4);
      curSizePower -= 1;
    }
  }
  KetTextureUtil.pixelsToQubitDensityMatrices = function(buffer) {
    var qubitCount = buffer.length / 4;
    return Seq.range(qubitCount).map(function(i) {
      var a = buffer[i * 4];
      var d = buffer[i * 4 + 3];
      var unity = a + d;
      if (unity < 0.0000001 || isNaN(unity)) {
        return new Matrix(2, 2, new Float32Array([NaN, NaN, NaN, NaN, NaN, NaN, NaN, NaN]));
      }
      var br = buffer[i * 4 + 1] / unity;
      var bi = buffer[i * 4 + 2] / unity;
      return new Matrix(2, 2, new Float32Array([a / unity, 0, br, bi, br, -bi, d / unity, 0]));
    }).toArray();
  };
  var amplitudesToProbabilities = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.float(), "float outputFor(float k) {\n        vec2 amp = read_input(k);\n        return dot(amp, amp);\n    }");
  KetTextureUtil.superpositionToNorm = function(stateTex, mayHaveChanged) {
    if (!mayHaveChanged) {
      return new WglTexture(0, 0, currentShaderCoder().vec4.pixelType);
    }
    var trader = new WglTextureTrader(stateTex);
    trader.dontDeallocCurrentTexture();
    var n = currentShaderCoder().vec2.arrayPowerSizeOfTexture(stateTex);
    trader.shadeAndTrade(amplitudesToProbabilities, WglTexturePool.takeVecFloatTex(n));
    while (n > 0) {
      n -= 1;
      trader.shadeHalveAndTrade(Shaders.sumFoldFloat);
    }
    trader.shadeAndTrade(Shaders.packFloatIntoVec4, WglTexturePool.takeVec4Tex(0));
    return trader.currentTexture;
  };
  return {get KetTextureUtil() {
      return KetTextureUtil;
    }};
});
//# sourceURL=src/circuit/KetTextureUtil.js
;$traceurRuntime.registerModule("src/circuit/Serializer.js", [], function() {
  "use strict";
  var __moduleName = "src/circuit/Serializer.js";
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitDefinition.js", "src/circuit/Serializer.js")).CircuitDefinition;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/circuit/Serializer.js")).Complex;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/circuit/Serializer.js")).Config;
  var CustomGateSet = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CustomGateSet.js", "src/circuit/Serializer.js")).CustomGateSet;
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Describe.js", "src/circuit/Serializer.js")).describe;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/circuit/Serializer.js")).DetailedError;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/circuit/Serializer.js")).Format;
  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/circuit/Serializer.js")),
      Gate = $__19.Gate,
      GateBuilder = $__19.GateBuilder;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateColumn.js", "src/circuit/Serializer.js")).GateColumn;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/AllGates.js", "src/circuit/Serializer.js")).Gates;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/circuit/Serializer.js")).Matrix;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/circuit/Serializer.js")).Util;
  var notifyAboutRecoveryFromUnexpectedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/fallback.js", "src/circuit/Serializer.js")).notifyAboutRecoveryFromUnexpectedError;
  var $__25 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Joke_MysteryGate.js", "src/circuit/Serializer.js")),
      MysteryGateSymbol = $__25.MysteryGateSymbol,
      MysteryGateMakerWithMatrix = $__25.MysteryGateMakerWithMatrix;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/circuit/Serializer.js")).seq;
  var setGateBuilderEffectToCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitComputeUtil.js", "src/circuit/Serializer.js")).setGateBuilderEffectToCircuit;
  var matrixDrawer = undefined;
  var circuitDrawer = undefined;
  var labelDrawer = undefined;
  var locationIndependentDrawer = undefined;
  function initSerializer(gateLabelDrawer, gateMatrixDrawer, gateCircuitDrawer, locationIndependentGateDrawer) {
    labelDrawer = gateLabelDrawer;
    matrixDrawer = gateMatrixDrawer;
    circuitDrawer = gateCircuitDrawer;
    locationIndependentDrawer = locationIndependentGateDrawer;
  }
  var Serializer = function() {
    function Serializer() {}
    return ($traceurRuntime.createClass)(Serializer, {}, {
      toJson: function(value) {
        var $__10,
            $__11;
        var context = arguments[1];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (BINDINGS)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__9 = $__3.value,
                type = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
                toJ = ($__11 = $__10.next()).done ? void 0 : $__11.value,
                _ = ($__11 = $__10.next()).done ? void 0 : $__11.value;
            {
              if (value instanceof type) {
                return toJ(value, context);
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        throw new Error(("Don't know how to convert " + describe(value) + " to JSON."));
      },
      fromJson: function(expectedType, json) {
        var $__10,
            $__11;
        var context = arguments[2];
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (BINDINGS)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var $__9 = $__3.value,
                type = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
                _ = ($__11 = $__10.next()).done ? void 0 : $__11.value,
                fromJ = ($__11 = $__10.next()).done ? void 0 : $__11.value;
            {
              if (type === expectedType) {
                return fromJ(json, context);
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
        throw new Error(("Don't know how to deserialize JSON " + describe(json) + " into an instance of " + expectedType + "."));
      }
    });
  }();
  var toJson_Complex = function(v) {
    return v.toString(Format.MINIFIED);
  };
  var fromJson_Complex = function(json) {
    if (typeof json === "string") {
      return Complex.parse(json);
    }
    throw new Error("Not a packed complex string: " + json);
  };
  var toJson_Matrix = function(v) {
    return v.toString(Format.MINIFIED);
  };
  var fromJson_Matrix = function(json) {
    if (typeof json !== "string") {
      throw new Error("Not a packed matrix string: " + json);
    }
    return Matrix.parse(json);
  };
  var toJson_Gate = function(gate) {
    var context = arguments[1] !== (void 0) ? arguments[1] : new CustomGateSet();
    var found = Gates.findKnownGateById(gate.serializedId, context);
    if (found === gate) {
      return gate.serializedId;
    }
    if (found !== undefined && found.param !== undefined) {
      return {
        id: gate.serializedId,
        arg: gate.param
      };
    }
    if (gate.name === "Parse Error") {
      return gate.tag;
    }
    var result = {};
    if (gate.serializedId !== "") {
      result.id = gate.serializedId;
    }
    if (gate.serializedId.startsWith("~") ? gate.symbol !== '' : gate.symbol !== gate.serializedId) {
      result.name = gate.symbol;
    }
    if (gate.stableDuration() === Infinity && gate.knownMatrixAt(0) !== undefined) {
      result.matrix = toJson_Matrix(gate.knownMatrixAt(0.25));
    } else if (gate.knownCircuit !== undefined) {
      result.circuit = toJson_CircuitDefinition(gate.knownCircuit, context);
    } else {
      throw new DetailedError("Don't known how to serialize gate's function.", {gate: gate});
    }
    return result;
  };
  function _getGateId(json) {
    var symbol = typeof json === "string" ? json : json["id"];
    if (symbol === undefined) {
      return "";
    }
    if (typeof symbol !== "string") {
      return describe(symbol);
    }
    return symbol;
  }
  function _parseGateMatrix(matrixProp) {
    if (matrixProp === undefined) {
      throw new Error("Unrecognized gate id, but no matrix specified.");
    }
    var matrix = fromJson_Matrix(matrixProp);
    if (matrix.width() !== matrix.height()) {
      throw new Error("Gate matrix must be square.");
    }
    if (matrix.width() < 2 || matrix.width() > 1 << 4 || !Util.isPowerOf2(matrix.width())) {
      throw new Error("Supported gate matrix sizes are 2, 4, 8, and 16.");
    }
    return matrix;
  }
  var fromJson_Gate_props = function(json) {
    var id = _getGateId(json);
    var matrix = json["matrix"];
    var circuit = json["circuit"];
    var param = json["arg"];
    if (param !== undefined && (!Number.isInteger(param) || param < 0 || param > 1 << 16)) {
      throw new DetailedError("Gate arg not int in [0, 2^16].", {json: json});
    }
    var symbol = json.name !== undefined ? json.name : id.startsWith('~') ? '' : id;
    var name = id.startsWith('~') ? ((symbol || 'Custom') + " Gate [" + id.substring(1) + "]") : symbol !== '' ? symbol : id;
    return {
      id: id,
      matrix: matrix,
      circuit: circuit,
      symbol: symbol,
      name: name,
      param: param
    };
  };
  var fromJson_Gate_Matrix = function(props) {
    var mat = _parseGateMatrix(props.matrix);
    if (props.id === MysteryGateSymbol) {
      return MysteryGateMakerWithMatrix(mat);
    }
    var height = Math.round(Math.log2(mat.height()));
    var width = props.symbol === '' ? height : 1;
    var matrix = _parseGateMatrix(props.matrix);
    var builder = new GateBuilder().setSerializedId(props.id).setSymbol(props.symbol).setTitle(props.name).setHeight(height).setWidth(width).setDrawer(props.symbol === "" ? matrixDrawer : matrix.isIdentity() ? labelDrawer : matrix.isScaler() ? locationIndependentDrawer : undefined).setKnownEffectToMatrix(matrix);
    if (matrix.isIdentity()) {
      builder.markAsNotInterestedInControls();
    }
    return builder.gate;
  };
  var fromJson_Gate_Circuit = function(props, context) {
    var circuit = fromJson_CircuitDefinition(props.circuit, context).withMinimumWireCount();
    return setGateBuilderEffectToCircuit(new GateBuilder(), circuit).setSerializedId(props.id).setSymbol(props.symbol).setTitle(props.name).setDrawer(circuitDrawer).gate;
  };
  var fromJson_Gate = function(json) {
    var context = arguments[1] !== (void 0) ? arguments[1] : new CustomGateSet();
    var props = fromJson_Gate_props(json);
    try {
      if (props.matrix !== undefined) {
        return fromJson_Gate_Matrix(props);
      }
      if (props.circuit !== undefined) {
        return fromJson_Gate_Circuit(props, context);
      }
      var match = Gates.findKnownGateById(props.id, context);
      if (match === undefined) {
        throw new DetailedError(("No gate with the id '" + props.id + "'."), {json: json});
      }
      if (props.param !== undefined) {
        if (match.param === undefined) {
          throw new DetailedError("Arg for gate without arg.", {json: json});
        }
        match = match.withParam(props.param);
      }
      return match;
    } catch (ex) {
      notifyAboutRecoveryFromUnexpectedError("Defaulted to a do-nothing 'parse error' gate. Failed to understand the json defining a gate.", {gate_json: json}, ex);
      return new GateBuilder().setSerializedIdAndSymbol(props.id).setTitle("Parse Error").setBlurb(describe(ex)).promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function() {
        return "parse\nerror";
      }).setTag(json).gate;
    }
  };
  function toJson_GateColumn(v) {
    var context = arguments[1] !== (void 0) ? arguments[1] : new CustomGateSet();
    return v.gates.map(function(e) {
      return e === undefined ? 1 : toJson_Gate(e, context);
    });
  }
  var fromJson_GateColumn = function(json) {
    var context = arguments[1] !== (void 0) ? arguments[1] : new CustomGateSet();
    if (!Array.isArray(json)) {
      throw new Error(("GateColumn json should be an array. Json: " + describe(json)));
    }
    return new GateColumn(json.map(function(e) {
      return e === 1 || e === undefined ? undefined : fromJson_Gate(e, context);
    }));
  };
  function toJson_CustomGateSet(v) {
    var result = [];
    for (var i = 0; i < v.gates.length; i++) {
      result.push(toJson_Gate(v.gates[i], new (Function.prototype.bind.apply(CustomGateSet, $traceurRuntime.spread([null], v.gates.slice(0, i))))()));
    }
    return result;
  }
  function fromJson_CustomGateSet(json) {
    if (!Array.isArray(json)) {
      throw new DetailedError("Expected an array of gates.", {json: json});
    }
    var gatesSoFar = new CustomGateSet();
    var $__5 = true;
    var $__6 = false;
    var $__7 = undefined;
    try {
      for (var $__3 = void 0,
          $__2 = (json)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
        var e = $__3.value;
        {
          gatesSoFar = gatesSoFar.withGate(fromJson_Gate(e, gatesSoFar));
        }
      }
    } catch ($__8) {
      $__6 = true;
      $__7 = $__8;
    } finally {
      try {
        if (!$__5 && $__2.return != null) {
          $__2.return();
        }
      } finally {
        if ($__6) {
          throw $__7;
        }
      }
    }
    return gatesSoFar;
  }
  var toJson_CircuitDefinition = function(v, context) {
    var result = {cols: v.trimEmptyColumnsAtEndIgnoringGateWidths().columns.map(function(e) {
        return toJson_GateColumn(e, context || v.customGateSet);
      }).map(function(c) {
        return seq(c).skipTailWhile(function(e) {
          return e === 1;
        }).toArray();
      })};
    if (context === undefined && v.customGateSet.gates.length > 0) {
      result.gates = toJson_CustomGateSet(v.customGateSet);
    }
    return result;
  };
  var _cachedCircuit = undefined;
  var _cachedCircuit_Arg = undefined;
  function fromJsonText_CircuitDefinition(jsonText) {
    if (_cachedCircuit_Arg === jsonText) {
      return _cachedCircuit;
    }
    _cachedCircuit_Arg = jsonText;
    _cachedCircuit = fromJson_CircuitDefinition(JSON.parse(jsonText), undefined);
    return _cachedCircuit;
  }
  function fromJson_CircuitDefinition(json) {
    var context = arguments[1];
    var cols = json.cols;
    var customGateSet = context || (json.gates === undefined ? new CustomGateSet() : fromJson_CustomGateSet(json.gates));
    if (!Array.isArray(cols)) {
      throw new Error(("CircuitDefinition json should contain an array of cols. Json: " + describe(json)));
    }
    var gateCols = cols.map(function(e) {
      return fromJson_GateColumn(e, customGateSet);
    });
    var numWires = 0;
    var $__5 = true;
    var $__6 = false;
    var $__7 = undefined;
    try {
      for (var $__3 = void 0,
          $__2 = (gateCols)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
        var col = $__3.value;
        {
          numWires = Math.max(numWires, col.minimumRequiredWireCount());
        }
      }
    } catch ($__8) {
      $__6 = true;
      $__7 = $__8;
    } finally {
      try {
        if (!$__5 && $__2.return != null) {
          $__2.return();
        }
      } finally {
        if ($__6) {
          throw $__7;
        }
      }
    }
    numWires = Math.max(Config.MIN_WIRE_COUNT, Math.min(numWires, Config.MAX_WIRE_COUNT));
    gateCols = gateCols.map(function(col) {
      return new GateColumn($traceurRuntime.spread(col.gates, new Array(Math.max(0, numWires - col.gates.length)).fill(undefined)).slice(0, numWires));
    });
    return new CircuitDefinition(numWires, gateCols, undefined, undefined, customGateSet).withTrailingSpacersIncluded();
  }
  var BINDINGS = [[Complex, toJson_Complex, fromJson_Complex], [Gate, toJson_Gate, fromJson_Gate], [Matrix, toJson_Matrix, fromJson_Matrix], [GateColumn, toJson_GateColumn, fromJson_GateColumn], [CircuitDefinition, toJson_CircuitDefinition, fromJson_CircuitDefinition]];
  return {
    get Serializer() {
      return Serializer;
    },
    get initSerializer() {
      return initSerializer;
    },
    get fromJsonText_CircuitDefinition() {
      return fromJsonText_CircuitDefinition;
    }
  };
});
//# sourceURL=src/circuit/Serializer.js
;$traceurRuntime.registerModule("src/Config.js", [], function() {
  "use strict";
  var __moduleName = "src/Config.js";
  var Config = function() {
    function Config() {}
    return ($traceurRuntime.createClass)(Config, {}, {});
  }();
  Config.EMPTY_CIRCUIT_TITLE = 'Quirk: Quantum Circuit Simulator';
  Config.MAX_WIRE_COUNT = 16;
  Config.SIMPLE_SUPERPOSITION_DRAWING_WIRE_THRESHOLD = 14;
  Config.MIN_WIRE_COUNT = 2;
  Config.MIN_COL_COUNT = 5;
  Config.URL_CIRCUIT_PARAM_KEY = 'circuit';
  Config.GATE_FILL_COLOR = 'white';
  Config.HIGHLIGHTED_GATE_FILL_COLOR = '#FB7';
  Config.TIME_DEPENDENT_HIGHLIGHT_COLOR = '#FFC';
  Config.DISPLAY_GATE_IN_TOOLBOX_FILL_COLOR = '#4F4';
  Config.DISPLAY_GATE_BACK_COLOR = '#EFE';
  Config.DISPLAY_GATE_FORE_COLOR = '#3F3';
  Config.OPERATION_BACK_COLOR = '#FFE';
  Config.OPERATION_FORE_COLOR = '#FF0';
  Config.SUPERPOSITION_BACK_COLOR = '#EFF';
  Config.SUPERPOSITION_MID_COLOR = '#8FF';
  Config.SUPERPOSITION_FORE_COLOR = '#0BB';
  Config.CYCLE_DURATION_MS = 8000;
  Config.TIME_CACHE_GRANULARITY = 196;
  Config.REDRAW_COOLDOWN_MILLIS = 10;
  Config.GATE_RADIUS = 20;
  Config.WIRE_SPACING = 50;
  Config.BACKGROUND_COLOR = 'white';
  Config.BACKGROUND_COLOR_CIRCUIT = 'white';
  Config.BACKGROUND_COLOR_TOOLBOX = '#CCC';
  Config.TOOLBOX_GATE_SPACING = 2;
  Config.TOOLBOX_GROUP_SPACING = 24 - Config.TOOLBOX_GATE_SPACING;
  Config.TOOLBOX_GATE_SPAN = Config.GATE_RADIUS * 2 + Config.TOOLBOX_GATE_SPACING;
  Config.TOOLBOX_GROUP_SPAN = Config.TOOLBOX_GATE_SPAN * 2 + Config.TOOLBOX_GROUP_SPACING;
  Config.TOOLBOX_MARGIN_X = 35;
  Config.TOOLBOX_MARGIN_Y = 18;
  Config.MINIMUM_CANVAS_HEIGHT = 400;
  Config.SUPPRESSED_GLSL_WARNING_PATTERNS = [];
  Config.DEFAULT_FILL_COLOR = 'white';
  Config.DEFAULT_STROKE_COLOR = 'black';
  Config.DEFAULT_TEXT_COLOR = 'black';
  Config.DEFAULT_FONT_SIZE = 12;
  Config.DEFAULT_FONT_FAMILY = 'sans-serif';
  Config.DEFAULT_STROKE_THICKNESS = 1;
  Config.CHECK_WEB_GL_ERRORS_EVEN_ON_HOT_PATHS = false;
  Config.SEMI_STABLE_RANDOM_VALUE_LIFETIME_MILLIS = 300;
  return {get Config() {
      return Config;
    }};
});
//# sourceURL=src/Config.js
;$traceurRuntime.registerModule("src/draw/CachablePainting.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/CachablePainting.js";
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/Painter.js", "src/draw/CachablePainting.js")).Painter;
  var RestartableRng = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/RestartableRng.js", "src/draw/CachablePainting.js")).RestartableRng;
  var fixedRng = new RestartableRng();
  var CachablePainting = function() {
    function CachablePainting(sizeFunc, drawingFunc) {
      this.sizeFunc = sizeFunc;
      this._drawingFunc = drawingFunc;
      this._cachedCanvases = new Map();
    }
    return ($traceurRuntime.createClass)(CachablePainting, {paint: function(x, y, painter) {
        var key = arguments[3];
        if (!this._cachedCanvases.has(key)) {
          var canvas = document.createElement('canvas');
          var $__1 = this.sizeFunc(key),
              width = $__1.width,
              height = $__1.height;
          canvas.width = width;
          canvas.height = height;
          this._drawingFunc(new Painter(canvas, fixedRng.restarted()), key);
          this._cachedCanvases.set(key, canvas);
        }
        painter.ctx.drawImage(this._cachedCanvases.get(key), x, y);
      }}, {});
  }();
  return {get CachablePainting() {
      return CachablePainting;
    }};
});
//# sourceURL=src/draw/CachablePainting.js
;$traceurRuntime.registerModule("src/draw/GateDrawParams.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/GateDrawParams.js";
  var GateDrawParams = function() {
    function GateDrawParams(painter, isInToolbox, isHighlighted, isResizeShowing, isResizeHighlighted, rect, gate, stats, positionInCircuit, focusPoints, customStatsForCircuitPos) {
      this.painter = painter;
      this.isInToolbox = isInToolbox;
      this.isHighlighted = isHighlighted;
      this.isResizeShowing = isResizeShowing;
      this.isResizeHighlighted = isResizeHighlighted;
      this.rect = rect;
      this.gate = gate;
      this.stats = stats;
      this.positionInCircuit = positionInCircuit;
      this.focusPoints = focusPoints;
      this.customStats = customStatsForCircuitPos;
    }
    return ($traceurRuntime.createClass)(GateDrawParams, {getGateContext: function(key) {
        if (this.positionInCircuit === undefined) {
          return undefined;
        }
        return this.stats.circuitDefinition.colCustomContextFromGates(this.positionInCircuit.col, 0).get(key);
      }}, {});
  }();
  return {get GateDrawParams() {
      return GateDrawParams;
    }};
});
//# sourceURL=src/draw/GateDrawParams.js
;$traceurRuntime.registerModule("src/draw/GatePainting.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/GatePainting.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/draw/GatePainting.js")).Config;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GateDrawParams.js", "src/draw/GatePainting.js")).GateDrawParams;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/draw/GatePainting.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/draw/GatePainting.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/draw/GatePainting.js")).Rect;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/draw/GatePainting.js")).Util;
  var GatePainting = function() {
    function GatePainting() {}
    return ($traceurRuntime.createClass)(GatePainting, {}, {});
  }();
  var GATE_SYMBOL_FONT = '16px sans-serif';
  GatePainting.paintOutline = function(args) {
    if (args.isInToolbox) {
      var r = args.rect.shiftedBy(0.5, 0.5);
      args.painter.strokeLine(r.topRight(), r.bottomRight());
      args.painter.strokeLine(r.bottomLeft(), r.bottomRight());
    }
    args.painter.strokeRect(args.rect, 'black');
  };
  GatePainting.paintBackground = function(args) {
    var toolboxFillColor = arguments[1] !== (void 0) ? arguments[1] : Config.GATE_FILL_COLOR;
    var normalFillColor = arguments[2] !== (void 0) ? arguments[2] : Config.GATE_FILL_COLOR;
    var backColor = args.isInToolbox ? toolboxFillColor : normalFillColor;
    if (args.isHighlighted) {
      backColor = Config.HIGHLIGHTED_GATE_FILL_COLOR;
    }
    args.painter.fillRect(args.rect, backColor);
  };
  GatePainting.LABEL_DRAWER = function(args) {
    if (args.positionInCircuit === undefined || args.isHighlighted) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    var cut = Math.max(0, args.rect.h - Config.GATE_RADIUS * 2) / 2;
    args.painter.fillRect(args.rect.skipTop(cut).skipBottom(cut), Config.GATE_FILL_COLOR);
    GatePainting.paintGateSymbol(args);
  };
  GatePainting.MAKE_HIGHLIGHTED_DRAWER = function() {
    var toolboxFillColor = arguments[0] !== (void 0) ? arguments[0] : Config.GATE_FILL_COLOR;
    var normalFillColor = arguments[1] !== (void 0) ? arguments[1] : Config.GATE_FILL_COLOR;
    return function(args) {
      GatePainting.paintBackground(args, toolboxFillColor, normalFillColor);
      GatePainting.paintOutline(args);
      GatePainting.paintResizeTab(args);
      GatePainting.paintGateSymbol(args);
    };
  };
  GatePainting.DEFAULT_DRAWER = GatePainting.MAKE_HIGHLIGHTED_DRAWER();
  GatePainting.rectForResizeTab = function(gateRect) {
    var overlap = Math.min(Config.GATE_RADIUS, gateRect.h / 4);
    return new Rect(gateRect.x, gateRect.bottom() - overlap, gateRect.w, Config.GATE_RADIUS * 2);
  };
  GatePainting.paintResizeTab = function(args) {
    if (!args.isResizeShowing || !args.gate.canChangeInSize()) {
      return;
    }
    var d = Config.GATE_RADIUS;
    var rect = GatePainting.rectForResizeTab(args.rect);
    var trimRect = rect.skipLeft(2).skipRight(2);
    var $__16 = trimRect.center(),
        cx = $__16.x,
        cy = $__16.y;
    var backColor = args.isResizeHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : Config.GATE_FILL_COLOR;
    var foreColor = args.isResizeHighlighted ? '#222' : 'gray';
    args.painter.ctx.save();
    args.painter.ctx.globalAlpha *= args.isResizeHighlighted ? 1 : 0.7;
    args.painter.fillRect(trimRect, backColor);
    args.painter.strokeRect(trimRect, 'gray');
    args.painter.ctx.restore();
    args.painter.print('resize', cx, cy, 'center', 'middle', foreColor, 'monospace', trimRect.w - 4, trimRect.h - 4);
    args.painter.trace(function(tracer) {
      var arrowDirs = [args.gate.canIncreaseInSize() ? +1 : -1, args.gate.canDecreaseInSize() ? -1 : +1];
      var arrowOffsets = [+1, -1];
      var $__5 = true;
      var $__6 = false;
      var $__7 = undefined;
      try {
        for (var $__3 = void 0,
            $__2 = ([-1, +1])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
          var sx = $__3.value;
          {
            for (var k = 0; k < 2; k++) {
              var by = cy + d * arrowOffsets[k] * 5 / 8;
              var y1 = by + d * arrowDirs[k] / 8;
              var y2 = by - d * arrowDirs[k] / 8;
              tracer.line(cx, y1, cx + d * sx * 0.3, y2);
            }
          }
        }
      } catch ($__8) {
        $__6 = true;
        $__7 = $__8;
      } finally {
        try {
          if (!$__5 && $__2.return != null) {
            $__2.return();
          }
        } finally {
          if ($__6) {
            throw $__7;
          }
        }
      }
    }).thenStroke(foreColor);
  };
  GatePainting.paintGateSymbol = function(args) {
    var $__18,
        $__19;
    var symbolOverride = arguments[1];
    var painter = args.painter;
    var rect = args.rect.paddedBy(-2);
    if (symbolOverride === undefined) {
      symbolOverride = args.gate.symbol;
    }
    var $__16 = _paintSymbolHandleLines(args.painter, symbolOverride, rect),
        symbol = $__16.symbol,
        offsetY = $__16.offsetY;
    painter.ctx.font = GATE_SYMBOL_FONT;
    var parts = symbol.split("^");
    if (parts.length !== 2 || parts[0] === "" || parts[1] === "") {
      painter.print(symbol, rect.x + rect.w / 2, rect.y + rect.h / 2 + offsetY, 'center', 'middle', 'black', GATE_SYMBOL_FONT, rect.w, rect.h);
      return;
    }
    var $__17 = parts,
        baseText = ($__18 = $__17[Symbol.iterator](), ($__19 = $__18.next()).done ? void 0 : $__19.value),
        expText = ($__19 = $__18.next()).done ? void 0 : $__19.value;
    var lines = baseText.split('\n');
    baseText = lines[0];
    var baseWidth = painter.ctx.measureText(baseText).width;
    var expWidth = painter.ctx.measureText(expText).width;
    var scaleDown = Math.min(rect.w, baseWidth + expWidth) / (baseWidth + expWidth);
    var divider = rect.w / 2 + (baseWidth - expWidth) * scaleDown / 2;
    painter.print(baseText, rect.x + divider, rect.y + rect.h / 2 + offsetY, 'right', 'hanging', 'black', GATE_SYMBOL_FONT, divider, rect.h);
    painter.print(expText, rect.x + divider, rect.y + rect.h / 2 + offsetY, 'left', 'alphabetic', 'black', GATE_SYMBOL_FONT, rect.w - divider, rect.h);
  };
  function _paintSymbolHandleLines(painter, symbol, rect) {
    var lines = symbol.split('\n');
    for (var i = 1; i < lines.length; i++) {
      painter.print(lines[i], rect.x + rect.w / 2, rect.y + rect.h / 2 + 9 * i, 'center', 'hanging', 'black', GATE_SYMBOL_FONT, rect.w, 16);
    }
    return {
      symbol: lines[0],
      offsetY: lines.length > 1 ? -5 : 0
    };
  }
  GatePainting.traceLocationIndependentOutline = function(args, tracer) {
    var $__17,
        $__18;
    var $__16 = [args.rect.x, args.rect.right(), args.rect.y, args.rect.bottom()],
        x1 = ($__17 = $__16[Symbol.iterator](), ($__18 = $__17.next()).done ? void 0 : $__18.value),
        x2 = ($__18 = $__17.next()).done ? void 0 : $__18.value,
        y1 = ($__18 = $__17.next()).done ? void 0 : $__18.value,
        y2 = ($__18 = $__17.next()).done ? void 0 : $__18.value;
    var diameter = Math.min(args.rect.h, args.rect.w, Config.GATE_RADIUS * 2);
    var clip = diameter / (2 + Math.sqrt(2));
    tracer.polygon([x1, y1 + clip, x1 + clip, y1, x2 - clip, y1, x2, y1 + clip, x2, y2 - clip, x2 - clip, y2, x1 + clip, y2, x1, y2 - clip]);
  };
  GatePainting.paintLocationIndependentFrame = function(args) {
    var normalFillColor = arguments[1] !== (void 0) ? arguments[1] : Config.GATE_FILL_COLOR;
    var toolboxFillColor = arguments[2] !== (void 0) ? arguments[2] : Config.GATE_FILL_COLOR;
    if (args.isInToolbox) {
      GatePainting.paintBackground(args, toolboxFillColor, normalFillColor);
      GatePainting.paintOutline(args);
      return;
    }
    var backColor = args.isHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : normalFillColor;
    args.painter.trace(function(tracer) {
      return GatePainting.traceLocationIndependentOutline(args, tracer);
    }).thenFill(backColor).thenStroke('black');
  };
  GatePainting.makeLocationIndependentGateDrawer = function(normalFillColor) {
    return function(args) {
      GatePainting.paintLocationIndependentFrame(args, normalFillColor);
      GatePainting.paintGateSymbol(args);
    };
  };
  GatePainting.LOCATION_INDEPENDENT_GATE_DRAWER = GatePainting.makeLocationIndependentGateDrawer(Config.GATE_FILL_COLOR);
  GatePainting.SECTIONED_DRAWER_MAKER = function(labels, dividers) {
    return function(args) {
      if (args.isInToolbox) {
        GatePainting.DEFAULT_DRAWER(args);
        return;
      }
      var backColor = args.isHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : Config.GATE_FILL_COLOR;
      var font = '16px sans-serif';
      args.painter.fillRect(args.rect, backColor);
      var p = 0;
      for (var i = 0; i < labels.length; i++) {
        var p2 = void 0;
        if (i < labels.length - 1) {
          p2 = p + dividers[i];
          var cy = args.rect.y + args.rect.h * p2;
          args.painter.strokeLine(new Point(args.rect.x, cy), new Point(args.rect.right(), cy), '#BBB');
        } else {
          p2 = 1;
        }
        args.painter.print(labels[i], args.rect.x + args.rect.w / 2, args.rect.y + args.rect.h * (p + p2) / 2, 'center', 'middle', 'black', font, args.rect.w - 2, args.rect.h * (p2 - p));
        p = p2;
      }
      args.painter.strokeRect(args.rect);
      GatePainting.paintResizeTab(args);
    };
  };
  var DISPLAY_GATE_DEFAULT_DRAWER = GatePainting.MAKE_HIGHLIGHTED_DRAWER(Config.DISPLAY_GATE_IN_TOOLBOX_FILL_COLOR);
  GatePainting.makeDisplayDrawer = function(statePainter) {
    return function(args) {
      if (args.positionInCircuit === undefined) {
        DISPLAY_GATE_DEFAULT_DRAWER(args);
        return;
      }
      GatePainting.paintResizeTab(args);
      statePainter(args);
      if (args.isHighlighted) {
        args.painter.strokeRect(args.rect, 'black', 1.5);
      }
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.25;
      GatePainting.paintResizeTab(args);
      args.painter.ctx.restore();
    };
  };
  GatePainting.MATRIX_DRAWER = function(args) {
    var m = args.gate.knownMatrixAt(args.stats.time);
    if (m === undefined) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    args.painter.fillRect(args.rect, args.isHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : Config.GATE_FILL_COLOR);
    MathPainter.paintMatrix(args.painter, m, args.rect, Config.OPERATION_FORE_COLOR, 'black', undefined, Config.OPERATION_BACK_COLOR, undefined, 'transparent');
    if (args.isHighlighted) {
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.9;
      args.painter.fillRect(args.rect, Config.HIGHLIGHTED_GATE_FILL_COLOR);
      args.painter.ctx.restore();
    }
    GatePainting.paintOutline(args);
  };
  GatePainting.makeCycleDrawer = function() {
    var xScale = arguments[0] !== (void 0) ? arguments[0] : 1;
    var yScale = arguments[1] !== (void 0) ? arguments[1] : 1;
    var tScale = arguments[2] !== (void 0) ? arguments[2] : 1;
    var zeroAngle = arguments[3] !== (void 0) ? arguments[3] : 0;
    return function(args) {
      GatePainting.MAKE_HIGHLIGHTED_DRAWER(Config.TIME_DEPENDENT_HIGHLIGHT_COLOR)(args);
      if (args.isInToolbox && !args.isHighlighted) {
        return;
      }
      var τ = 2 * Math.PI;
      var t = Util.properMod(-args.stats.time * τ * tScale, τ);
      var c = args.rect.center();
      var r = 0.4 * args.rect.w;
      args.painter.ctx.save();
      args.painter.ctx.translate(c.x, c.y);
      args.painter.ctx.scale(-xScale, -yScale);
      args.painter.ctx.rotate(zeroAngle);
      args.painter.ctx.strokeStyle = 'black';
      args.painter.ctx.fillStyle = 'yellow';
      args.painter.ctx.globalAlpha *= 0.4;
      args.painter.ctx.beginPath();
      args.painter.ctx.moveTo(0, 0);
      args.painter.ctx.lineTo(0, r);
      args.painter.ctx.arc(0, 0, r, τ / 4, τ / 4 + t, true);
      args.painter.ctx.lineTo(0, 0);
      args.painter.ctx.closePath();
      args.painter.ctx.stroke();
      args.painter.ctx.fill();
      args.painter.ctx.restore();
    };
  };
  GatePainting.MATRIX_SYMBOL_DRAWER_EXCEPT_IN_TOOLBOX = function(args) {
    if (args.isInToolbox) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    GatePainting.MATRIX_DRAWER(args);
  };
  function _wireY(args, offset) {
    return args.rect.center().y + (offset - args.gate.height / 2 + 0.5) * Config.WIRE_SPACING;
  }
  GatePainting.gateButtonRect = function(wholeRect) {
    return wholeRect.bottomHalf().skipTop(6).paddedBy(-7);
  };
  GatePainting.paintGateButton = function(args) {
    if (!args.isHighlighted || args.isInToolbox) {
      return;
    }
    var buttonRect = GatePainting.gateButtonRect(args.rect);
    var buttonFocus = !args.focusPoints.every(function(pt) {
      return !buttonRect.containsPoint(pt);
    });
    args.painter.fillRect(buttonRect, buttonFocus ? 'red' : 'orange');
    args.painter.print('change', buttonRect.center().x, buttonRect.center().y, 'center', 'middle', 'black', '12px sans-serif', buttonRect.w, buttonRect.h);
    args.painter.strokeRect(buttonRect, 'black');
  };
  function _eraseWiresForPermutation(args) {
    for (var i = 0; i < args.gate.height; i++) {
      var y = _wireY(args, i);
      var p = new Point(args.rect.x, y);
      var c = new Point(args.rect.x + Config.GATE_RADIUS, y);
      var q = new Point(args.rect.right(), y);
      var loc = new Point(args.positionInCircuit.col, args.positionInCircuit.row + i);
      var isMeasured1 = args.stats.circuitDefinition.locIsMeasured(loc);
      var isMeasured2 = args.stats.circuitDefinition.locIsMeasured(loc.offsetBy(1, 0));
      var $__5 = true;
      var $__6 = false;
      var $__7 = undefined;
      try {
        for (var $__3 = void 0,
            $__2 = (isMeasured1 ? [-1, +1] : [0])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
          var dy = $__3.value;
          {
            args.painter.strokeLine(p.offsetBy(0, dy), c.offsetBy(1, dy), 'white');
          }
        }
      } catch ($__8) {
        $__6 = true;
        $__7 = $__8;
      } finally {
        try {
          if (!$__5 && $__2.return != null) {
            $__2.return();
          }
        } finally {
          if ($__6) {
            throw $__7;
          }
        }
      }
      var $__12 = true;
      var $__13 = false;
      var $__14 = undefined;
      try {
        for (var $__10 = void 0,
            $__9 = (isMeasured2 ? [-1, +1] : [0])[Symbol.iterator](); !($__12 = ($__10 = $__9.next()).done); $__12 = true) {
          var dy$__20 = $__10.value;
          {
            args.painter.strokeLine(c.offsetBy(-1, dy$__20), q.offsetBy(0, dy$__20), 'white');
          }
        }
      } catch ($__15) {
        $__13 = true;
        $__14 = $__15;
      } finally {
        try {
          if (!$__12 && $__9.return != null) {
            $__9.return();
          }
        } finally {
          if ($__13) {
            throw $__14;
          }
        }
      }
    }
  }
  GatePainting.PERMUTATION_DRAWER = function(args) {
    var $__17,
        $__18;
    if (args.positionInCircuit === undefined) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    if (args.isHighlighted || args.isResizeHighlighted || args.stats.circuitDefinition.colHasControls(args.positionInCircuit.col)) {
      GatePainting.paintBackground(args, '#F3F3F3', '#F3F3F3');
      GatePainting.paintOutline(args);
      GatePainting.paintResizeTab(args);
    } else {
      _eraseWiresForPermutation(args);
    }
    var x1 = args.rect.x;
    var x2 = args.rect.right();
    args.painter.ctx.strokeStyle = 'black';
    for (var i = 0; i < args.gate.height; i++) {
      var j = args.gate.knownBitPermutationFunc(i);
      var pt = new Point(args.positionInCircuit.col, args.positionInCircuit.row + i);
      var isMeasured = args.stats.circuitDefinition.locIsMeasured(pt);
      var y1 = _wireY(args, i);
      var y2 = _wireY(args, j);
      args.painter.ctx.beginPath();
      var $__5 = true;
      var $__6 = false;
      var $__7 = undefined;
      try {
        for (var $__3 = void 0,
            $__2 = (isMeasured ? [[j > i ? +1 : -1, -1], [0, +1]] : [[0, 0]])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
          var $__16 = $__3.value,
              dx = ($__17 = $__16[Symbol.iterator](), ($__18 = $__17.next()).done ? void 0 : $__18.value),
              dy = ($__18 = $__17.next()).done ? void 0 : $__18.value;
          {
            args.painter.ctx.moveTo(Math.min(x1, x1 + dx), y1 + dy);
            args.painter.ctx.lineTo(x1 + dx, y1 + dy);
            args.painter.ctx.lineTo(x2 + dx, y2 + dy);
            args.painter.ctx.lineTo(Math.max(x2, x2 + dx), y2 + dy);
          }
        }
      } catch ($__8) {
        $__6 = true;
        $__7 = $__8;
      } finally {
        try {
          if (!$__5 && $__2.return != null) {
            $__2.return();
          }
        } finally {
          if ($__6) {
            throw $__7;
          }
        }
      }
      args.painter.ctx.stroke();
    }
  };
  return {get GatePainting() {
      return GatePainting;
    }};
});
//# sourceURL=src/draw/GatePainting.js
;$traceurRuntime.registerModule("src/draw/MathPainter.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/MathPainter.js";
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/Painter.js", "src/draw/MathPainter.js")).Painter;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/draw/MathPainter.js")).Format;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/draw/MathPainter.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/draw/MathPainter.js")).Rect;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/draw/MathPainter.js")),
      seq = $__17.seq,
      Seq = $__17.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/draw/MathPainter.js")).Util;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/draw/MathPainter.js")).Config;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/draw/MathPainter.js")).Complex;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/draw/MathPainter.js")).Matrix;
  var MathPainter = function() {
    function MathPainter() {}
    return ($traceurRuntime.createClass)(MathPainter, {}, {
      describeProbability: function(p, fractionalDigits) {
        var v = p * 100;
        var e = Math.pow(10, -fractionalDigits);
        if (v > 100 - e / 2) {
          return "On";
        }
        if (v < e / 2) {
          return "Off";
        }
        return Math.min(Math.max(v, e), 100 - e).toFixed(fractionalDigits) + "%";
      },
      paintProbabilityBox: function(painter, probability, drawArea) {
        var focusPoints = arguments[3] !== (void 0) ? arguments[3] : [];
        var backgroundColor = arguments[4] !== (void 0) ? arguments[4] : Config.DISPLAY_GATE_BACK_COLOR;
        var fillColor = arguments[5] !== (void 0) ? arguments[5] : Config.DISPLAY_GATE_FORE_COLOR;
        painter.fillRect(drawArea, backgroundColor);
        var cen = drawArea.center();
        if (isNaN(probability)) {
          painter.fillPolygon([drawArea.bottomLeft(), drawArea.topLeft(), drawArea.topRight()], fillColor);
          painter.print("NaN", cen.x, cen.y, 'center', 'middle', 'red', '9pt sans-serif', drawArea.w, drawArea.h);
        } else {
          painter.fillRect(drawArea.takeBottomProportion(probability), fillColor);
          painter.print(MathPainter.describeProbability(probability, 1), cen.x, cen.y, 'center', 'middle', 'black', '9pt sans-serif', drawArea.w, drawArea.h);
        }
        painter.strokeRect(drawArea, 'lightgray');
        if (seq(focusPoints).any(function(pt) {
          return drawArea.containsPoint(pt);
        })) {
          painter.strokeRect(drawArea, 'orange', 2);
          MathPainter.paintDeferredValueTooltip(painter, drawArea.right(), drawArea.y, 'Chance of being ON if measured', (100 * probability).toFixed(5) + "%");
        }
      },
      paintMatrixTooltip: function(painter, matrix, drawArea, focusPoints, titleFunc, valueTextFunc1) {
        var valueTextFunc2 = arguments[6] !== (void 0) ? arguments[6] : function() {
          return undefined;
        };
        var numCols = matrix.width();
        var numRows = matrix.height();
        var $__9 = drawArea,
            x = $__9.x,
            y = $__9.y;
        var diam = Math.min(drawArea.w / numCols, drawArea.h / numRows);
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          for (var $__3 = void 0,
              $__2 = (focusPoints)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            var pt = $__3.value;
            {
              var c = Math.floor((pt.x - x) / diam);
              var r = Math.floor((pt.y - y) / diam);
              if (c >= 0 && c < matrix.width() && r >= 0 && r < matrix.height()) {
                painter.strokeRect(new Rect(x + diam * c, y + diam * r, diam, diam), 'orange', 2);
                var v = matrix.cell(c, r);
                MathPainter.paintDeferredValueTooltip(painter, x + diam * c + diam, y + diam * r, titleFunc(c, r), valueTextFunc1(c, r, v), valueTextFunc2(c, r, v));
              }
            }
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
      },
      _traceAmplitudeProbabilitySquare: function(trace, real, imag, x, y, d) {
        var p = real * real + imag * imag;
        if (p > 0.001) {
          trace.polygon([x, y + d * (1 - p), x + d, y + d * (1 - p), x + d, y + d, x, y + d]);
        }
      },
      _traceProbabilitySquare: function(trace, real, imag, x, y, d) {
        var p = real;
        if (d * p > 0.1) {
          trace.polygon([x, y + d * (1 - p), x + d, y + d * (1 - p), x + d, y + d, x, y + d]);
        }
      },
      _traceAmplitudeProbabilityCircle: function(trace, real, imag, x, y, d) {
        var mag = Math.sqrt(real * real + imag * imag);
        if (d * mag > 0.5) {
          trace.circle(x + d / 2, y + d / 2, mag * d / 2);
        }
      },
      _traceAmplitudeLogarithmCircle: function(trace, real, imag, x, y, d) {
        var g = 1 + Math.log(real * real + imag * imag) / 15;
        if (g > 0) {
          trace.circle(x + d / 2, y + d / 2, g * d / 2);
        }
      },
      _traceAmplitudePhaseDirection: function(trace, real, imag, x, y, d) {
        var mag = Math.sqrt(real * real + imag * imag);
        var g = 1 + Math.log(mag) / 10;
        var r = Math.max(1, g / mag) * Math.max(d / 2, 5);
        if (r < 0.1) {
          return;
        }
        var cx = x + d / 2;
        var cy = y + d / 2;
        trace.line(cx, cy, cx + real * r, cy - imag * r);
      },
      paintMatrix: function(painter, matrix, drawArea, amplitudeCircleFillColor, amplitudeCircleStrokeColor, amplitudeProbabilityFillColor) {
        var backColor = arguments[6] !== (void 0) ? arguments[6] : Config.DISPLAY_GATE_BACK_COLOR;
        var amplitudePhaseStrokeColor = arguments[7];
        var logCircleStrokeColor = arguments[8] !== (void 0) ? arguments[8] : '#AAA';
        var numCols = matrix.width();
        var numRows = matrix.height();
        var buf = matrix.rawBuffer();
        var diam = Math.min(drawArea.w / numCols, drawArea.h / numRows);
        drawArea = drawArea.withW(diam * numCols).withH(diam * numRows);
        var $__9 = drawArea,
            x = $__9.x,
            y = $__9.y;
        var hasNaN = matrix.hasNaN();
        amplitudePhaseStrokeColor = amplitudePhaseStrokeColor || amplitudeCircleStrokeColor;
        painter.fillRect(drawArea, backColor);
        var traceCellsWith = function(cellTraceFunc) {
          return painter.trace(function(trace) {
            for (var row = 0; row < numRows; row++) {
              for (var col = 0; col < numCols; col++) {
                var k = (row * numCols + col) * 2;
                cellTraceFunc(trace, buf[k], buf[k + 1], x + diam * col, y + diam * row, diam);
              }
            }
          });
        };
        if (!hasNaN) {
          if (amplitudeProbabilityFillColor !== undefined) {
            traceCellsWith(MathPainter._traceAmplitudeProbabilitySquare).thenFill(amplitudeProbabilityFillColor).thenStroke('lightgray', 0.5);
          }
          if (amplitudeCircleFillColor !== undefined) {
            traceCellsWith(MathPainter._traceAmplitudeProbabilityCircle).thenFill(amplitudeCircleFillColor).thenStroke(amplitudeCircleStrokeColor, 0.5);
            traceCellsWith(MathPainter._traceAmplitudeLogarithmCircle).thenStroke(logCircleStrokeColor, 0.5);
          }
        }
        painter.trace(function(trace) {
          return trace.grid(x, y, drawArea.w, drawArea.h, numCols, numRows);
        }).thenStroke('lightgray');
        if (!hasNaN) {
          if (logCircleStrokeColor !== undefined) {
            traceCellsWith(MathPainter._traceAmplitudePhaseDirection).thenStroke(amplitudePhaseStrokeColor);
          }
        }
        if (hasNaN) {
          painter.print('NaN', drawArea.x + drawArea.w / 2, drawArea.y + drawArea.h / 2, 'center', 'middle', 'red', '16px sans-serif', drawArea.w, drawArea.h);
        }
      },
      paintDeferredValueTooltip: function(painter, x, y, labelText, valueText) {
        var valueText2 = arguments[5];
        var backColor = arguments[6] !== (void 0) ? arguments[6] : Config.DISPLAY_GATE_BACK_COLOR;
        var labelFont = '12px sans-serif';
        var valueFont = 'bold 12px monospace';
        painter.defer(function() {
          painter.ctx.font = labelFont;
          var width1 = painter.ctx.measureText(labelText).width;
          painter.ctx.font = valueFont;
          var width2 = painter.ctx.measureText(valueText).width;
          var width3 = valueText2 === undefined ? 0 : painter.ctx.measureText(valueText2).width;
          var lineHeight = 20;
          var height = 40 + (valueText2 === undefined ? 0 : 20);
          var width = Math.max(Math.max(width1, width2), width3);
          var boundingRect = new Rect(x, y - height, width, height).snapInside(new Rect(0, 0, painter.ctx.canvas.clientWidth, painter.ctx.canvas.clientHeight));
          var borderPainter = function(w, h) {
            var r = new Rect(boundingRect.x, boundingRect.bottom() - h, w, h).paddedBy(4);
            painter.trace(function(tracer) {
              return tracer.rect(r.x, r.y, r.w, r.h);
            }).thenFill(backColor).thenStroke('black');
          };
          var labelPainter = function(w, h) {
            painter.print(labelText, boundingRect.x, boundingRect.bottom() - h, 'left', 'bottom', 'black', labelFont, boundingRect.w, lineHeight, function(w2, h2) {
              return borderPainter(Math.max(w, w2), h + h2);
            });
          };
          var value1Painter = function(w, h) {
            painter.print(valueText, boundingRect.x, boundingRect.bottom() - h, 'left', 'bottom', 'black', valueFont, boundingRect.w, lineHeight, function(w2, h2) {
              return labelPainter(Math.max(w, w2), h + h2);
            });
          };
          if (valueText2 === undefined) {
            value1Painter(0, 0);
          } else {
            painter.print(valueText2, boundingRect.x, boundingRect.bottom(), 'left', 'bottom', 'black', valueFont, boundingRect.w, lineHeight, value1Painter);
          }
        });
      },
      coordinateSystem: function(unit) {
        return {
          dx: new Point(unit / 3, -unit / 3),
          dy: new Point(unit, 0),
          dz: new Point(0, unit)
        };
      },
      paintBlochSphereRotation: function(painter, operation, drawArea) {
        var $__11;
        var backgroundColor = arguments[3] !== (void 0) ? arguments[3] : Config.DISPLAY_GATE_BACK_COLOR;
        var fillColor = arguments[4] !== (void 0) ? arguments[4] : Config.DISPLAY_GATE_FORE_COLOR;
        var c = drawArea.center();
        var u = Math.min(drawArea.w, drawArea.h) / 2;
        var $__9 = MathPainter.coordinateSystem(u),
            dx = $__9.dx,
            dy = $__9.dy,
            dz = $__9.dz;
        var projMatrix = Matrix.fromRows([[-dx.x, -dx.y], [dy.x, dy.y], [-dz.x, -dz.y]]).adjoint();
        var projToPt = function(col) {
          var p = projMatrix.times(col);
          return new Point(p.cell(0, 0).real, p.cell(0, 1).real);
        };
        var axes = Seq.range(3).map(function(i) {
          return Matrix.generate(1, 3, function(r, _) {
            return r === i ? 1 : 0;
          });
        }).toArray();
        painter.fillCircle(c, u, backgroundColor);
        painter.trace(function(trace) {
          trace.circle(c.x, c.y, u);
          trace.ellipse(c.x, c.y, u, u / 3);
          trace.ellipse(c.x, c.y, u / 3, u);
          var $__5 = true;
          var $__6 = false;
          var $__7 = undefined;
          try {
            for (var $__3 = void 0,
                $__2 = (axes)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
              var a = $__3.value;
              {
                var d = projToPt(a);
                trace.line(c.x - d.x, c.y - d.y, c.x + d.x, c.y + d.y);
              }
            }
          } catch ($__8) {
            $__6 = true;
            $__7 = $__8;
          } finally {
            try {
              if (!$__5 && $__2.return != null) {
                $__2.return();
              }
            } finally {
              if ($__6) {
                throw $__7;
              }
            }
          }
        }).thenStroke('#BBB');
        var $__10 = operation.qubitOperationToAngleAxisRotation(),
            angle = $__10.angle,
            axis = $__10.axis;
        var axisVec = ($__11 = Matrix).col.apply($__11, $traceurRuntime.spread(axis));
        var dAxis = projToPt(axisVec);
        var guideDeltas = [Matrix.col(axis[0], axis[1], 0), axisVec, Matrix.col(0, 0, axis[2])].map(projToPt);
        painter.strokePolygon(seq(guideDeltas).reverse().concat(guideDeltas.map(function(d) {
          return d.times(-1);
        })).map(function(d) {
          return c.plus(d);
        }).toArray(), '#666');
        painter.strokeLine(c.plus(dAxis), c.plus(dAxis.times(-1)), 'black', 2);
        var norm = function(e) {
          return Math.sqrt(e.adjoint().times(e).cell(0, 0).real);
        };
        var perpVec1 = seq(axes).mapWithIndex(function(a, i) {
          return a.times([-3, -2, 1][i]);
        }).map(function(a) {
          return axisVec.cross3(a);
        }).maxBy(norm);
        var perpVec2 = axisVec.cross3(perpVec1);
        perpVec1 = perpVec1.times(0.15 / norm(perpVec1));
        perpVec2 = perpVec2.times(0.15 / norm(perpVec2));
        var dPerp1 = projToPt(perpVec1);
        var dPerp2 = projToPt(perpVec2);
        MathPainter._paintBlochSphereRotation_rotationGuideArrows(painter, c, angle, dAxis, dPerp1, dPerp2, fillColor);
      },
      _paintBlochSphereRotation_rotationGuideArrows: function(painter, center, angle, dAlong, dPerp1, dPerp2, fillColor) {
        var rotationGuideDeltas = Seq.range(Math.floor(Math.abs(angle) * 32)).map(function(i) {
          var θ = (angle < 0 ? Math.PI - i / 32 : i / 32);
          return dPerp1.times(Math.cos(θ)).plus(dPerp2.times(Math.sin(θ)));
        }).toArray();
        if (rotationGuideDeltas.length <= 1) {
          return;
        }
        var $__5 = true;
        var $__6 = false;
        var $__7 = undefined;
        try {
          var $__12 = function() {
            var offsetFactor = $__3.value;
            {
              var offsetCenter = center.plus(dAlong.times(offsetFactor));
              var arcPts = rotationGuideDeltas.map(function(d) {
                return offsetCenter.plus(d);
              });
              var arrowHeadRoot = arcPts[arcPts.length - 1];
              var arrowHeadDirection = arrowHeadRoot.plus(arcPts[arcPts.length - 2].times(-1));
              var arrowHeadPts = [dAlong.times(0.15), arrowHeadDirection.times(30), dAlong.times(-0.15)].map(function(d) {
                return arrowHeadRoot.plus(d);
              });
              var interleaved = [].concat.apply([], arrowHeadPts.map(function(e) {
                return [e.x, e.y];
              }));
              painter.strokePath(arcPts, '#444');
              painter.trace(function(tracer) {
                return tracer.polygon(interleaved);
              }).thenFill(fillColor).thenStroke('#444');
            }
          };
          for (var $__3 = void 0,
              $__2 = ([-0.55, 0, 0.55])[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
            $__12();
          }
        } catch ($__8) {
          $__6 = true;
          $__7 = $__8;
        } finally {
          try {
            if (!$__5 && $__2.return != null) {
              $__2.return();
            }
          } finally {
            if ($__6) {
              throw $__7;
            }
          }
        }
      },
      paintDensityMatrix: function(painter, matrix, drawArea) {
        var focusPoints = arguments[3] !== (void 0) ? arguments[3] : [];
        var backgroundColor = arguments[4] !== (void 0) ? arguments[4] : Config.DISPLAY_GATE_BACK_COLOR;
        var fillColor = arguments[5] !== (void 0) ? arguments[5] : Config.DISPLAY_GATE_FORE_COLOR;
        var numCols = matrix.width();
        var numRows = matrix.height();
        var buf = matrix.rawBuffer();
        var diam = Math.min(drawArea.w / numCols, drawArea.h / numRows);
        var x = drawArea.x;
        var y = drawArea.y;
        var hasNaN = matrix.hasNaN();
        var traceCouplingsWith = function(cellTraceFunc) {
          return painter.trace(function(trace) {
            for (var row = 0; row < numRows; row++) {
              for (var col = 0; col < numCols; col++) {
                var k = (row * numCols + col) * 2;
                cellTraceFunc(trace, buf[k], buf[k + 1], x + diam * col, y + diam * row, diam);
              }
            }
          });
        };
        var traceDiagonalWith = function(cellTraceFunc) {
          return painter.trace(function(trace) {
            for (var col = 0; col < numRows; col++) {
              var k = col * (numCols + 1) * 2;
              cellTraceFunc(trace, buf[k], buf[k + 1], x + diam * col, y + diam * col, diam);
            }
          });
        };
        painter.fillRect(drawArea, backgroundColor);
        if (!hasNaN) {
          traceDiagonalWith(MathPainter._traceProbabilitySquare).thenFill(fillColor).thenStroke('#040', 0.5);
          traceCouplingsWith(MathPainter._traceAmplitudeProbabilityCircle).thenFill(fillColor).thenStroke('#040', 0.5);
          traceCouplingsWith(MathPainter._traceAmplitudeLogarithmCircle).thenStroke('#BBB', 0.5);
          traceCouplingsWith(MathPainter._traceAmplitudePhaseDirection).thenStroke('black');
        }
        var d = drawArea.w / numCols;
        if (d > 2) {
          painter.trace(function(trace) {
            return trace.grid(x, y, drawArea.w, drawArea.h, numCols, numRows);
          }).thenStroke('lightgray', Math.min(1, 2 / Math.log(numCols)));
        } else {
          painter.ctx.save();
          painter.ctx.globalAlpha *= 0.2;
          painter.fillRect(drawArea, 'lightgray');
          painter.ctx.restore();
        }
        if (hasNaN) {
          painter.print('NaN', drawArea.x + drawArea.w / 2, drawArea.y + drawArea.h / 2, 'center', 'middle', 'red', '16px sans-serif', drawArea.w, drawArea.h);
        }
        var n = Math.round(Math.log2(numRows));
        MathPainter.paintMatrixTooltip(painter, matrix, drawArea, focusPoints, function(c, r) {
          return c === r ? ("Probability of |" + Util.bin(c, n) + "⟩") : ("Coupling of |" + Util.bin(c, n) + "⟩ to ⟨" + Util.bin(r, n) + "|");
        }, function(c, r, v) {
          return c === r ? (matrix.cell(c, r).real * 100).toFixed(4) + "%" : matrix.cell(c, r).toString(new Format(false, 0, 6, ", "));
        });
      }
    });
  }();
  return {get MathPainter() {
      return MathPainter;
    }};
});
//# sourceURL=src/draw/MathPainter.js
;$traceurRuntime.registerModule("src/draw/Painter.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/Painter.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/draw/Painter.js")).Config;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/draw/Painter.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/draw/Painter.js")).Rect;
  var RestartableRng = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/RestartableRng.js", "src/draw/Painter.js")).RestartableRng;
  var $__15 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/draw/Painter.js")),
      seq = $__15.seq,
      Seq = $__15.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/draw/Painter.js")).Util;
  var Painter = function() {
    function Painter(canvas) {
      var rng = arguments[1] !== (void 0) ? arguments[1] : new RestartableRng();
      this.canvas = canvas;
      this.ctx = canvas.getContext("2d");
      this._deferredPaintActions = [];
      this._traceAction = new TraceAction(this.ctx);
      this._tracer = new Tracer(this.ctx);
      this.desiredCursorStyle = undefined;
      this.touchBlockers = [];
      this.rng = rng;
    }
    return ($traceurRuntime.createClass)(Painter, {
      noteTouchBlocker: function(blocker) {
        this.touchBlockers.push(blocker);
      },
      setDesiredCursor: function(cursorStyle) {
        this.desiredCursorStyle = cursorStyle;
      },
      defer: function(tooltipPainter) {
        this._deferredPaintActions.push(tooltipPainter);
      },
      paintDeferred: function() {
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (this._deferredPaintActions)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var e = $__5.value;
            {
              e();
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        this._deferredPaintActions = [];
      },
      paintableArea: function() {
        return new Rect(0, 0, this.canvas.width, this.canvas.height);
      },
      clear: function() {
        var color = arguments[0] !== (void 0) ? arguments[0] : Config.DEFAULT_FILL_COLOR;
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      },
      strokeLine: function(p1, p2) {
        var color = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_STROKE_COLOR;
        var thickness = arguments[3] !== (void 0) ? arguments[3] : 1;
        this.ctx.beginPath();
        this.ctx.moveTo(p1.x, p1.y);
        this.ctx.lineTo(p2.x, p2.y);
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.stroke();
      },
      strokeRect: function(rect) {
        var color = arguments[1] !== (void 0) ? arguments[1] : "black";
        var thickness = arguments[2] !== (void 0) ? arguments[2] : 1;
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
      },
      fillRect: function(rect) {
        var color = arguments[1] !== (void 0) ? arguments[1] : Config.DEFAULT_FILL_COLOR;
        this.ctx.fillStyle = color;
        this.ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
      },
      strokeCircle: function(center, radius) {
        var color = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_STROKE_COLOR;
        var thickness = arguments[3] !== (void 0) ? arguments[3] : Config.DEFAULT_STROKE_THICKNESS;
        this.ctx.beginPath();
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.arc(center.x, center.y, Math.max(radius - 0.5, 0), 0, 2 * Math.PI);
        this.ctx.stroke();
      },
      trace: function(tracerFunc) {
        this.ctx.beginPath();
        tracerFunc(this._tracer);
        return this._traceAction;
      },
      fillCircle: function(center, radius) {
        var color = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_FILL_COLOR;
        this.ctx.beginPath();
        this.ctx.arc(center.x, center.y, Math.max(radius - 0.5, 0), 0, 2 * Math.PI);
        this.ctx.fillStyle = color;
        this.ctx.fill();
      },
      print: function(text, x, y, textAlign, textBaseline, fillStyle, font, boundingWidth, boundingHeight) {
        var afterMeasureBeforeDraw = arguments[9];
        var alsoStroke = arguments[10] !== (void 0) ? arguments[10] : false;
        this.ctx.font = font;
        var naiveWidth = this.ctx.measureText(text).width;
        var naiveHeight = this.ctx.measureText("0").width * 2.5;
        var scale = Math.min(Math.min(boundingWidth / naiveWidth, boundingHeight / naiveHeight), 1);
        if (afterMeasureBeforeDraw !== undefined) {
          afterMeasureBeforeDraw(naiveWidth * scale, naiveHeight * scale);
        }
        this.ctx.save();
        this.ctx.textAlign = textAlign;
        this.ctx.textBaseline = textBaseline;
        this.ctx.font = font;
        this.ctx.fillStyle = fillStyle;
        this.ctx.translate(x, y);
        this.ctx.scale(scale, scale);
        if (alsoStroke) {
          this.ctx.strokeText(text, 0, 0);
        }
        this.ctx.fillText(text, 0, 0);
        this.ctx.restore();
      },
      printParagraph: function(text, area) {
        var proportionalCenterOfAlignment = arguments[2] !== (void 0) ? arguments[2] : new Point(0, 0);
        var fontColor = arguments[3] !== (void 0) ? arguments[3] : Config.DEFAULT_TEXT_COLOR;
        var maxFontSize = arguments[4] !== (void 0) ? arguments[4] : Config.DEFAULT_FONT_SIZE;
        var fontFamily = arguments[5] !== (void 0) ? arguments[5] : Config.DEFAULT_FONT_FAMILY;
        var $__3 = this;
        var fontSize;
        var ascendingHeightOf = function(metric) {
          var d = metric.fontBoundingBoxAscent;
          return d === undefined ? fontSize * 0.75 : d;
        };
        var descendingHeightOf = function(metric) {
          var d = metric.fontBoundingBoxDescent;
          return d === undefined ? fontSize * 0.25 : d;
        };
        var heightOf = function(metric) {
          return ascendingHeightOf(metric) + descendingHeightOf(metric);
        };
        var lines;
        var measures;
        var height;
        var forcedLines = seq(text.split("\n"));
        for (var df = 0; ; df++) {
          fontSize = maxFontSize - df;
          this.ctx.font = fontSize + "px " + fontFamily;
          lines = forcedLines.flatMap(function(line) {
            return Util.breakLine(line, area.w, function(s) {
              return $__3.ctx.measureText(s).width;
            });
          }).toArray();
          measures = lines.map(function(e) {
            return $__3.ctx.measureText(e);
          });
          height = seq(measures.map(heightOf)).sum();
          if (height <= area.h || fontSize <= 4) {
            break;
          }
        }
        var f = function(offset, full, used, proportion) {
          return offset + (full - used) * proportion;
        };
        var fx = function(w) {
          return f(area.x, area.w, w, proportionalCenterOfAlignment.x);
        };
        var fy = function(h) {
          return f(area.y, area.h, h, proportionalCenterOfAlignment.y);
        };
        var y = fy(height);
        this.ctx.fillStyle = fontColor;
        var dy = 0;
        for (var i = 0; i < lines.length; i++) {
          dy += ascendingHeightOf(measures[i]);
          this.ctx.fillText(lines[i], fx(measures[i].width), y + dy);
          dy += descendingHeightOf(measures[i]);
        }
        var maxWidth = new Seq(measures).map(function(e) {
          return e.width;
        }).max(0);
        return new Rect(fx(maxWidth), y, maxWidth, height);
      },
      printLine: function(text, area) {
        var proportionalCenterOfHorizontalAlignment = arguments[2] !== (void 0) ? arguments[2] : 0;
        var fontColor = arguments[3] !== (void 0) ? arguments[3] : Config.DEFAULT_TEXT_COLOR;
        var maxFontSize = arguments[4] !== (void 0) ? arguments[4] : Config.DEFAULT_FONT_SIZE;
        var fontFamily = arguments[5] !== (void 0) ? arguments[5] : Config.DEFAULT_FONT_FAMILY;
        var proportionalCenterOfVerticalAlignment = arguments[6];
        var fontSize;
        var ascendingHeightOf = function(metric) {
          var d = metric.fontBoundingBoxAscent;
          return d === undefined ? fontSize * 0.75 : d;
        };
        var descendingHeightOf = function(metric) {
          var d = metric.fontBoundingBoxDescent;
          return d === undefined ? fontSize * 0.25 : d;
        };
        var heightOf = function(metric) {
          return ascendingHeightOf(metric) + descendingHeightOf(metric);
        };
        var measure;
        for (var df = 0; ; df++) {
          fontSize = maxFontSize - df;
          this.ctx.font = fontSize + "px " + fontFamily;
          measure = this.ctx.measureText(text);
          if ((measure.width <= area.w && heightOf(measure) <= area.h) || fontSize <= 4) {
            break;
          }
        }
        var h = heightOf(measure);
        var py = proportionalCenterOfVerticalAlignment === undefined ? ascendingHeightOf(measure) / h : proportionalCenterOfVerticalAlignment;
        var f = function(offset, full, used, proportion) {
          return offset + (full - used) * proportion;
        };
        var x = f(area.x, area.w, measure.width, proportionalCenterOfHorizontalAlignment);
        var y = f(area.y, area.h, h, py);
        this.ctx.fillStyle = fontColor;
        this.ctx.fillText(text, x, y + ascendingHeightOf(measure));
        return new Rect(x, y, measure.width, h);
      },
      strokePolygon: function(vertices) {
        var strokeColor = arguments[1] !== (void 0) ? arguments[1] : Config.DEFAULT_STROKE_COLOR;
        var strokeThickness = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_STROKE_THICKNESS;
        if (vertices.length === 0) {
          return;
        }
        var last = vertices[vertices.length - 1];
        this.ctx.beginPath();
        this.ctx.moveTo(last.x, last.y);
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (vertices)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var p = $__5.value;
            {
              this.ctx.lineTo(p.x, p.y);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = strokeThickness;
        this.ctx.stroke();
      },
      strokePath: function(vertices) {
        var strokeColor = arguments[1] !== (void 0) ? arguments[1] : Config.DEFAULT_STROKE_COLOR;
        var strokeThickness = arguments[2] !== (void 0) ? arguments[2] : Config.DEFAULT_STROKE_THICKNESS;
        if (vertices.length === 0) {
          return;
        }
        this.ctx.beginPath();
        this.ctx.moveTo(vertices[0].x, vertices[0].y);
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (vertices.slice(1))[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var p = $__5.value;
            {
              this.ctx.lineTo(p.x, p.y);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = strokeThickness;
        this.ctx.stroke();
      },
      fillPolygon: function(vertices, fillColor) {
        var last = vertices[vertices.length - 1];
        this.ctx.beginPath();
        this.ctx.moveTo(last.x, last.y);
        var $__7 = true;
        var $__8 = false;
        var $__9 = undefined;
        try {
          for (var $__5 = void 0,
              $__4 = (vertices)[Symbol.iterator](); !($__7 = ($__5 = $__4.next()).done); $__7 = true) {
            var p = $__5.value;
            {
              this.ctx.lineTo(p.x, p.y);
            }
          }
        } catch ($__10) {
          $__8 = true;
          $__9 = $__10;
        } finally {
          try {
            if (!$__7 && $__4.return != null) {
              $__4.return();
            }
          } finally {
            if ($__8) {
              throw $__9;
            }
          }
        }
        this.ctx.fillStyle = fillColor;
        this.ctx.fill();
      }
    }, {});
  }();
  var Tracer = function() {
    function Tracer(ctx) {
      this.ctx = ctx;
    }
    return ($traceurRuntime.createClass)(Tracer, {
      line: function(x1, y1, x2, y2) {
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
      },
      rect: function(x, y, w, h) {
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(x + w, y);
        this.ctx.lineTo(x + w, y + h);
        this.ctx.lineTo(x, y + h);
        this.ctx.lineTo(x, y);
      },
      circle: function(x, y, radius) {
        this.ctx.moveTo(x + radius, y);
        this.ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
      },
      ellipse: function(x, y, horizontal_radius, vertical_radius) {
        this.ctx.save();
        this.ctx.translate(x - horizontal_radius, y - vertical_radius);
        this.ctx.scale(horizontal_radius, vertical_radius);
        this.ctx.moveTo(2, 1);
        this.ctx.arc(1, 1, 1, 0, 2 * Math.PI, false);
        this.ctx.restore();
      },
      grid: function(x, y, w, h, numCols, numRows) {
        var dw = w / numCols;
        var dh = h / numRows;
        var x2 = x + numCols * dw;
        var y2 = y + numRows * dh;
        for (var c = 0; c <= numCols; c++) {
          this.ctx.moveTo(x + c * dw, y);
          this.ctx.lineTo(x + c * dw, y2);
        }
        for (var r = 0; r <= numRows; r++) {
          this.ctx.moveTo(x, y + r * dh);
          this.ctx.lineTo(x2, y + r * dh);
        }
      },
      polygon: function(interleavedCoordinates) {
        if (interleavedCoordinates.length === 0) {
          return;
        }
        var n = interleavedCoordinates.length;
        this.ctx.moveTo(interleavedCoordinates[n - 2], interleavedCoordinates[n - 1]);
        for (var i = 0; i < n; i += 2) {
          this.ctx.lineTo(interleavedCoordinates[i], interleavedCoordinates[i + 1]);
        }
      },
      arrowHead: function(x, y, radius, facingAngle, sweptAngle) {
        var a1 = facingAngle + sweptAngle / 2 + Math.PI;
        var a2 = facingAngle - sweptAngle / 2 + Math.PI;
        this.polygon([x + Math.cos(facingAngle) * radius, y + Math.sin(facingAngle) * radius, x + Math.cos(a1) * radius, y + Math.sin(a1) * radius, x + Math.cos(a2) * radius, y + Math.sin(a2) * radius]);
      }
    }, {});
  }();
  var TraceAction = function() {
    function TraceAction(ctx) {
      this.ctx = ctx;
    }
    return ($traceurRuntime.createClass)(TraceAction, {
      thenFill: function(fillStyle) {
        this.ctx.fillStyle = fillStyle;
        this.ctx.fill();
        return this;
      },
      thenStroke: function(strokeStyle) {
        var lineWidth = arguments[1] !== (void 0) ? arguments[1] : 1;
        this.ctx.strokeStyle = strokeStyle;
        this.ctx.lineWidth = lineWidth;
        this.ctx.stroke();
        return this;
      }
    }, {});
  }();
  return {get Painter() {
      return Painter;
    }};
});
//# sourceURL=src/draw/Painter.js
;$traceurRuntime.registerModule("src/draw/WidgetPainter.js", [], function() {
  "use strict";
  var __moduleName = "src/draw/WidgetPainter.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/draw/WidgetPainter.js")).Complex;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/draw/WidgetPainter.js")).Config;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/draw/WidgetPainter.js")).Format;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/draw/WidgetPainter.js")).Gate;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/draw/WidgetPainter.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/draw/WidgetPainter.js")).Matrix;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/Painter.js", "src/draw/WidgetPainter.js")).Painter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/draw/WidgetPainter.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/draw/WidgetPainter.js")).Rect;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/draw/WidgetPainter.js")).Seq;
  var drawCircuitTooltip = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/DisplayedCircuit.js", "src/draw/WidgetPainter.js")).drawCircuitTooltip;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/draw/WidgetPainter.js")).Util;
  var WidgetPainter = function() {
    function WidgetPainter() {}
    return ($traceurRuntime.createClass)(WidgetPainter, {}, {
      describeGateTransformations: function(matrix, format) {
        var n = matrix.height();
        var b = Math.round(Math.log2(n));
        return Seq.range(n).map(function(c) {
          var inputDescription = WidgetPainter.describeKet(b, c, 1, Format.SIMPLIFIED);
          var col = matrix.getColumn(c);
          if (col.every(function(e) {
            return e.isEqualTo(0);
          })) {
            return "discards " + inputDescription;
          } else if (Seq.range(n).every(function(r) {
            return col[r].isEqualTo(r === c ? 1 : 0);
          })) {
            if (format !== Format.CONSISTENT) {
              return "doesn't affect " + inputDescription;
            }
          } else if (Seq.range(n).every(function(r) {
            return r === c || col[r].isEqualTo(0);
          })) {
            return "phases " + inputDescription + " by " + col[c].toString(format);
          }
          var outputDescription = new Seq(col).mapWithIndex(function(e, c) {
            return WidgetPainter.describeKet(b, c, e, format);
          }).filter(function(e) {
            return e !== "";
          }).join(" + ").split(" + -").join(" - ").split(" + +").join(" + ");
          return 'transforms ' + inputDescription + ' into ' + outputDescription;
        }).toArray();
      },
      _paintGateTooltip_matrix: function(painter, gate, matrix, pad, dispSize, w, pushRect, nextY) {
        if (matrix === undefined) {
          return;
        }
        pushRect(new Rect(0, nextY(), 1, 0), pad * 2);
        pushRect(painter.printParagraph('As matrix:', new Rect(pad, nextY(), w, 18), new Point(0, 0), 'black', 12), 0);
        var matrixRect = new Rect(pad, nextY(), dispSize, dispSize);
        var matrixDescRect = new Rect(0, matrixRect.y, w - pad, dispSize).skipLeft(matrixRect.right() + pad);
        MathPainter.paintMatrix(painter, matrix, matrixRect, Config.OPERATION_FORE_COLOR, 'black', undefined, Config.OPERATION_BACK_COLOR, undefined, 'transparent');
        pushRect(matrixRect);
        var n = matrix.height();
        if (n <= 4) {
          var format = gate.stableDuration() < 0.2 ? Format.CONSISTENT : Format.SIMPLIFIED;
          var matDescs = WidgetPainter.describeGateTransformations(matrix, format);
          var rowHeight = matrixDescRect.h / n;
          for (var r = 0; r < n; r++) {
            pushRect(painter.printParagraph(matDescs[r], matrixDescRect.skipTop(r * rowHeight).takeTop(rowHeight), new Point(0, 0.5), 'black', 12));
          }
        }
      },
      _paintGateTooltip_rotation: function(painter, gate, matrix, pad, dispSize, w, pushRect, nextY) {
        if (matrix === undefined || matrix.width() !== 2 || !matrix.isUnitary(0.001)) {
          return;
        }
        pushRect(new Rect(0, nextY(), 1, 0), pad * 2);
        pushRect(painter.printParagraph('As rotation:', new Rect(pad, nextY(), w, 18), new Point(0, 0), 'black', 12), 0);
        var $__2 = matrix.qubitOperationToAngleAxisRotation(),
            angle = $__2.angle,
            axis = $__2.axis,
            phase = $__2.phase;
        var blochRect = new Rect(pad, nextY(), dispSize, dispSize);
        MathPainter.paintBlochSphereRotation(painter, matrix, blochRect, Config.OPERATION_BACK_COLOR, Config.OPERATION_FORE_COLOR);
        pushRect(blochRect);
        var format = gate.stableDuration() < 0.2 ? Format.CONSISTENT : Format.SIMPLIFIED;
        var rotDesc = new Seq([("rotates: " + format.formatFloat(angle * 180 / Math.PI) + "°"), ("around: " + WidgetPainter.describeAxis(axis, format)), '', ("hidden phase: exp(" + format.formatFloat(phase * 180 / Math.PI) + "°i)"), '']).join('\n');
        pushRect(painter.printParagraph(rotDesc, new Rect(0, blochRect.y, w - pad, dispSize).skipLeft(blochRect.right() + pad), new Point(0, 0.5), 'black', 12));
      },
      _paintGateTooltip_circuit: function(painter, nestedCircuit, pad, dispSize, w, pushRect, nextY, time) {
        if (nestedCircuit === undefined) {
          return;
        }
        var weight = nestedCircuit.gateWeight();
        pushRect(new Rect(0, nextY(), 1, 0), pad * 2);
        pushRect(painter.printParagraph(("As circuit (gate weight = " + weight + "):"), new Rect(pad, nextY(), w, 18), new Point(0, 0), 'black', 12), 0);
        var circuitRect = new Rect(pad, nextY(), w, dispSize);
        var $__2 = drawCircuitTooltip(painter, nestedCircuit, circuitRect, true, time),
            maxW = $__2.maxW,
            maxH = $__2.maxH;
        pushRect(circuitRect.withW(maxW).withH(maxH));
      },
      paintGateTooltipHelper: function(painter, w, gate, time) {
        var $__3,
            $__4,
            $__6,
            $__7;
        var $__2 = [4, 65],
            pad = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
            dispSize = ($__4 = $__3.next()).done ? void 0 : $__4.value;
        var $__5 = [0, pad],
            maxX = ($__6 = $__5[Symbol.iterator](), ($__7 = $__6.next()).done ? void 0 : $__7.value),
            maxY = ($__7 = $__6.next()).done ? void 0 : $__7.value;
        var pushRect = function(rect) {
          var actualPad = arguments[1] !== (void 0) ? arguments[1] : pad;
          maxY = Math.max(maxY, rect.bottom() + actualPad);
          maxX = Math.max(maxX, rect.right() + actualPad);
        };
        pushRect(painter.printLine(gate.name, new Rect(pad, maxY, w, 18), 0, "blue", 24));
        if (gate.blurb !== '') {
          pushRect(painter.printParagraph(gate.blurb, new Rect(pad, maxY, w, 50), new Point(0, 0), 'black', 14));
        }
        var matrix = gate.knownMatrixAt(time);
        if (gate.definitelyHasNoEffect()) {
          return {
            maxX: maxX,
            maxY: maxY
          };
        }
        WidgetPainter._paintGateTooltip_matrix(painter, gate, matrix, pad, dispSize, w, pushRect, function() {
          return maxY;
        });
        WidgetPainter._paintGateTooltip_rotation(painter, gate, matrix, pad, dispSize, w, pushRect, function() {
          return maxY;
        });
        WidgetPainter._paintGateTooltip_circuit(painter, gate.knownCircuitNested, pad, dispSize, w, pushRect, function() {
          return maxY;
        }, time);
        return {
          maxX: maxX,
          maxY: maxY
        };
      },
      paintGateTooltip: function(painter, area, gate, time) {
        var mayNeedToScale = arguments[4] !== (void 0) ? arguments[4] : true;
        painter.ctx.save();
        painter.ctx.translate(area.x, area.y);
        area = area.withX(0).withY(0);
        var scale = Math.min(area.w / 500, area.h / 300);
        if (mayNeedToScale && scale < 1) {
          painter.ctx.scale(scale, scale);
          area = area.withH(area.h / scale).withW(area.w / scale);
        }
        var w = area.w;
        var $__2 = WidgetPainter.paintGateTooltipHelper(painter, w, gate, time),
            maxX = $__2.maxX,
            maxY = $__2.maxY;
        var r = new Rect(0, 0, maxX, maxY);
        painter.fillRect(r, '#F9FFF9');
        painter.strokeRect(r, 'black');
        WidgetPainter.paintGateTooltipHelper(painter, w, gate, time);
        painter.ctx.restore();
        return {
          maxW: maxX,
          maxH: maxY
        };
      },
      describeKet: function(bitCount, bitMask, factor, format) {
        factor = Complex.from(factor);
        if (factor.isEqualTo(0)) {
          return "";
        }
        var scaleFactorDesc = factor.isEqualTo(1) ? "" : factor.isEqualTo(-1) ? "-" : factor.isEqualTo(Complex.I) ? "i" : factor.isEqualTo(Complex.I.times(-1)) ? "-i" : (factor.real === 0 || factor.imag === 0) && format !== Format.CONSISTENT ? factor.toString(format) : '(' + factor.toString(format) + ')·';
        var bitDesc = Util.bin(bitMask, bitCount);
        return scaleFactorDesc + '|' + bitDesc + '⟩';
      },
      describeAxis: function(unitAxis, format) {
        var max = new Seq(unitAxis).map(Math.abs).max();
        return new Seq(unitAxis).map(function(e) {
          return e / max;
        }).zip(["X", "Y", "Z"], function(val, name) {
          if (val === 0) {
            return "";
          }
          if (val === 1) {
            return name;
          }
          if (val === -1) {
            return "-" + name;
          }
          return format.formatFloat(val) + "·" + name;
        }).filter(function(e) {
          return e !== "";
        }).join(" + ").replace(" + -", " - ").replace(" + +", " + ");
      }
    });
  }();
  return {get WidgetPainter() {
      return WidgetPainter;
    }};
});
//# sourceURL=src/draw/WidgetPainter.js
;$traceurRuntime.registerModule("src/fallback.js", [], function() {
  "use strict";
  var __moduleName = "src/fallback.js";
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Describe.js", "src/fallback.js")).describe;
  var knownIssueRegexes = [];
  var isHooked = false;
  function hookErrorHandler() {
    isHooked = true;
    window.onerror = onErrorHandler;
  }
  function checkForKnownIssueHandler(subject, isKnownIssueUrl) {
    if (isKnownIssueUrl !== undefined) {
      return undefined;
    }
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (knownIssueRegexes)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var $__8 = $__2.value,
            regex = $__8.regex,
            handler = $__8.handler;
        {
          if (regex.test(subject)) {
            return handler;
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    return undefined;
  }
  var showErrorDiv_forced = function(callout, subject, body, isKnownIssueUrl) {
    document.getElementById('error-happened-div').innerText = callout;
    document.getElementById('error-message-div').innerText = subject;
    document.getElementById('error-description-div').innerText = body;
    document.getElementById('error-mailto-anchor').innerText = 'Email the issue to craig.gidney@gmail.com';
    document.getElementById('error-mailto-anchor').href = ['mailto:craig.gidney@gmail.com?subject=', encodeURIComponent('Quirk had an error: ' + subject), '&body=', encodeURIComponent('\n\n\n' + body)].join('');
    document.getElementById('error-github-anchor').href = ['https://github.com/Strilanc/Quirk/issues/new?title=', encodeURIComponent('Encountered error: ' + subject), '&body=', encodeURIComponent('\n\n\n' + body)].join('');
    document.getElementById('error-image-pre').src = takeScreenshotOfCanvas();
    setTimeout(function() {
      document.getElementById('error-image-post').src = takeScreenshotOfCanvas();
    }, 0);
    if (isKnownIssueUrl === undefined) {
      document.getElementById('error-report-div').style.display = 'block';
      document.getElementById('error-known-div').style.display = 'none';
    } else {
      document.getElementById('error-report-div').style.display = 'none';
      document.getElementById('error-known-div').style.display = 'block';
      document.getElementById('error-known-issue-anchor').href = isKnownIssueUrl;
    }
  };
  var _alreadySeenBodies = [];
  var _alreadySeenIdentifiers = [];
  var showErrorDiv = function(callout, subject, body, identifier) {
    var isKnownIssueUrl = arguments[4];
    var errDivStyle = document.getElementById('error-div').style;
    if (errDivStyle.opacity < 0.7) {
      _alreadySeenBodies = [];
      _alreadySeenIdentifiers = [];
    }
    errDivStyle.backgroundColor = '#FFA';
    errDivStyle.opacity = 1.0;
    errDivStyle.display = 'block';
    if (_alreadySeenBodies.indexOf(body) !== -1) {
      return;
    }
    _alreadySeenBodies.push(body);
    if (_alreadySeenIdentifiers.length > 0) {
      body += "\n\nCOVERED\n" + _alreadySeenIdentifiers.join("\n-------------\n");
    }
    if (_alreadySeenIdentifiers.indexOf(identifier) === -1) {
      _alreadySeenIdentifiers.push(identifier);
    }
    var handler = checkForKnownIssueHandler(subject, isKnownIssueUrl);
    if (handler !== undefined) {
      handler();
      return;
    }
    showErrorDiv_forced(callout, subject, body, isKnownIssueUrl);
  };
  var takeScreenshotOfCanvas = function() {
    var canvas = document.getElementById("drawCanvas");
    if (canvas === undefined) {
      return '#';
    }
    return canvas.toDataURL("image/png");
  };
  var notifyAboutRecoveryFromUnexpectedError = function(recovery, context, error) {
    if (!isHooked) {
      throw error;
    }
    console.error('Recovered from unexpected error', {
      recovery: recovery,
      context: context,
      error: error
    });
    var location = error.stack || "unknown";
    var msg = [recovery, '', 'URL', document.location, '', 'BROWSER', window.navigator.userAgent, window.navigator.appName, window.navigator.appVersion, '', 'RECOVERY DETAILS', describe(context), '', 'ERROR OBJECT', describe(error), '', 'ERROR LOCATION', simplifySrcUrls(location)].join('\n');
    showErrorDiv('Recovered from an error. :(', recovery + ' (' + (error.message || '') + ')', msg, "(Recovered) " + recovery + " @ " + location.substr(0, 200) + "[...]");
  };
  var simplifySrcUrls = function(textContainingUrls) {
    return textContainingUrls.replace(/http.+?\/src\.min\.js/g, 'src.min.js');
  };
  var notifyAboutKnownIssue = function(summary, url, regexes) {
    var handler = function() {
      return showErrorDiv('A known problem is happening. :(', summary, '', summary, url);
    };
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (regexes)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var regex = $__2.value;
        {
          knownIssueRegexes.push({
            regex: regex,
            handler: handler
          });
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    handler();
  };
  var drawErrorBox = function(msg) {
    var canvas = document.getElementById("drawCanvas");
    if (canvas === undefined) {
      return;
    }
    var ctx = canvas.getContext("2d");
    ctx.font = '12px monospace';
    var lines = msg.split("\n");
    var w = 0;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (lines)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var line = $__2.value;
        {
          w = Math.max(w, ctx.measureText(line).width);
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    var h = 12 * lines.length;
    var x = (canvas.clientWidth - w) / 2;
    var y = (canvas.clientHeight - h) / 2;
    ctx.fillStyle = 'white';
    ctx.globalAlpha = 0.9;
    ctx.fillRect(x - 10, y - 10, w + 20, h + 20);
    ctx.globalAlpha = 1.0;
    ctx.strokeStyle = 'red';
    ctx.strokeRect(x - 10, y - 10, w + 20, h + 20);
    ctx.fillStyle = 'red';
    var dy = 0;
    for (var i = 0; i < lines.length; i++) {
      dy += 3;
      ctx.fillText(lines[i], x, y + dy);
      dy += 9;
    }
  };
  function onErrorHandler(errorMsg, url, lineNumber, columnNumber, errorObj) {
    try {
      var location = simplifySrcUrls(((errorObj instanceof Object) ? errorObj.stack : undefined) || (url + ":" + lineNumber + ":" + columnNumber));
      var body = ['URL', document.location, '', 'BROWSER', window.navigator.userAgent, window.navigator.appName, window.navigator.appVersion, '', 'ERROR OBJECT', errorObj instanceof Object && errorObj.toString !== undefined ? errorObj.toString() : String(errorObj), '', 'ERROR LOCATION', simplifySrcUrls(location)].join('\n');
      showErrorDiv('An error happened. :(', errorMsg, body, "(Unexpected) " + errorMsg + " @ " + location.substr(0, 200) + "[...]");
      drawErrorBox(['An error is happening. :(', '', errorMsg, '', 'Scroll down for more information'].join('\n'));
    } catch (ex) {
      console.error("Caused an exception when handling unexpected error.", ex);
    }
    return false;
  }
  return {
    get hookErrorHandler() {
      return hookErrorHandler;
    },
    get notifyAboutRecoveryFromUnexpectedError() {
      return notifyAboutRecoveryFromUnexpectedError;
    },
    get onErrorHandler() {
      return onErrorHandler;
    },
    get notifyAboutKnownIssue() {
      return notifyAboutKnownIssue;
    }
  };
});
//# sourceURL=src/fallback.js
;$traceurRuntime.registerModule("src/gates/AllGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/AllGates.js";
  var ArithmeticGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ArithmeticGates.js", "src/gates/AllGates.js")).ArithmeticGates;
  var AmplitudeDisplayFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/AmplitudeDisplay.js", "src/gates/AllGates.js")).AmplitudeDisplayFamily;
  var BitCountGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/BitCountGates.js", "src/gates/AllGates.js")).BitCountGates;
  var BlochSphereDisplay = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/BlochSphereDisplay.js", "src/gates/AllGates.js")).BlochSphereDisplay;
  var ComparisonGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ComparisonGates.js", "src/gates/AllGates.js")).ComparisonGates;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Controls.js", "src/gates/AllGates.js")).Controls;
  var CountingGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/CountingGates.js", "src/gates/AllGates.js")).CountingGates;
  var CycleBitsGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/CycleBitsGates.js", "src/gates/AllGates.js")).CycleBitsGates;
  var DensityMatrixDisplayFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/DensityMatrixDisplay.js", "src/gates/AllGates.js")).DensityMatrixDisplayFamily;
  var ErrorInjectionGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Debug_ErrorInjectionGate.js", "src/gates/AllGates.js")).ErrorInjectionGate;
  var ExponentiatingGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ExponentiatingGates.js", "src/gates/AllGates.js")).ExponentiatingGates;
  var FourierTransformGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/FourierTransformGates.js", "src/gates/AllGates.js")).FourierTransformGates;
  var HalfTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/HalfTurnGates.js", "src/gates/AllGates.js")).HalfTurnGates;
  var IncrementGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/IncrementGates.js", "src/gates/AllGates.js")).IncrementGates;
  var InputGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/InputGates.js", "src/gates/AllGates.js")).InputGates;
  var InterleaveBitsGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/InterleaveBitsGates.js", "src/gates/AllGates.js")).InterleaveBitsGates;
  var MeasurementGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/MeasurementGate.js", "src/gates/AllGates.js")).MeasurementGate;
  var ModularIncrementGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularIncrementGates.js", "src/gates/AllGates.js")).ModularIncrementGates;
  var ModularAdditionGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularAdditionGates.js", "src/gates/AllGates.js")).ModularAdditionGates;
  var ModularMultiplicationGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularMultiplicationGates.js", "src/gates/AllGates.js")).ModularMultiplicationGates;
  var ModularMultiplyAccumulateGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularMultiplyAccumulateGates.js", "src/gates/AllGates.js")).ModularMultiplyAccumulateGates;
  var MultiplicationGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/MultiplicationGates.js", "src/gates/AllGates.js")).MultiplicationGates;
  var MultiplyAccumulateGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/MultiplyAccumulateGates.js", "src/gates/AllGates.js")).MultiplyAccumulateGates;
  var NeGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Joke_NeGate.js", "src/gates/AllGates.js")).NeGate;
  var ParametrizedRotationGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ParametrizedRotationGates.js", "src/gates/AllGates.js")).ParametrizedRotationGates;
  var PhaseGradientGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/PhaseGradientGates.js", "src/gates/AllGates.js")).PhaseGradientGates;
  var PivotFlipGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/PivotFlipGates.js", "src/gates/AllGates.js")).PivotFlipGates;
  var PostSelectionGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/PostSelectionGates.js", "src/gates/AllGates.js")).PostSelectionGates;
  var PoweringGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/PoweringGates.js", "src/gates/AllGates.js")).PoweringGates;
  var ProbabilityDisplayFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ProbabilityDisplay.js", "src/gates/AllGates.js")).ProbabilityDisplayFamily;
  var QuarterTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/QuarterTurnGates.js", "src/gates/AllGates.js")).QuarterTurnGates;
  var ReverseBitsGateFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ReverseBitsGate.js", "src/gates/AllGates.js")).ReverseBitsGateFamily;
  var SampleDisplayFamily = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/SampleDisplay.js", "src/gates/AllGates.js")).SampleDisplayFamily;
  var Detector = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Detector.js", "src/gates/AllGates.js")).Detector;
  var SpacerGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/SpacerGate.js", "src/gates/AllGates.js")).SpacerGate;
  var SwapGateHalf = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/SwapGateHalf.js", "src/gates/AllGates.js")).SwapGateHalf;
  var UniversalNotGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Impossible_UniversalNotGate.js", "src/gates/AllGates.js")).UniversalNotGate;
  var VariousXGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/VariousXGates.js", "src/gates/AllGates.js")).VariousXGates;
  var VariousYGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/VariousYGates.js", "src/gates/AllGates.js")).VariousYGates;
  var VariousZGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/VariousZGates.js", "src/gates/AllGates.js")).VariousZGates;
  var XorGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/XorGates.js", "src/gates/AllGates.js")).XorGates;
  var ZeroGate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Joke_ZeroGate.js", "src/gates/AllGates.js")).ZeroGate;
  var MysteryGateMaker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Joke_MysteryGate.js", "src/gates/AllGates.js")).MysteryGateMaker;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/gates/AllGates.js")).seq;
  var Gates = {};
  Gates.Special = {
    Measurement: MeasurementGate,
    SwapHalf: SwapGateHalf
  };
  Gates.Displays = {
    AmplitudeDisplayFamily: AmplitudeDisplayFamily,
    ProbabilityDisplayFamily: ProbabilityDisplayFamily,
    SampleDisplayFamily: SampleDisplayFamily,
    DensityMatrixDisplayFamily: DensityMatrixDisplayFamily,
    BlochSphereDisplay: BlochSphereDisplay
  };
  Gates.Arithmetic = ArithmeticGates;
  Gates.BitCountGates = BitCountGates;
  Gates.ComparisonGates = ComparisonGates;
  Gates.Controls = Controls;
  Gates.CountingGates = CountingGates;
  Gates.CycleBitsGates = CycleBitsGates;
  Gates.Displays.DensityMatrixDisplay = DensityMatrixDisplayFamily.ofSize(1);
  Gates.Displays.DensityMatrixDisplay2 = DensityMatrixDisplayFamily.ofSize(2);
  Gates.Displays.ChanceDisplay = Gates.Displays.ProbabilityDisplayFamily.ofSize(1);
  Gates.ErrorInjection = ErrorInjectionGate;
  Gates.Exponentiating = ExponentiatingGates;
  Gates.FourierTransformGates = FourierTransformGates;
  Gates.HalfTurns = HalfTurnGates;
  Gates.IncrementGates = IncrementGates;
  Gates.InputGates = InputGates;
  Gates.InterleaveBitsGates = InterleaveBitsGates;
  Gates.ModularIncrementGates = ModularIncrementGates;
  Gates.ModularAdditionGates = ModularAdditionGates;
  Gates.ModularMultiplicationGates = ModularMultiplicationGates;
  Gates.ModularMultiplyAccumulateGates = ModularMultiplyAccumulateGates;
  Gates.MultiplicationGates = MultiplicationGates;
  Gates.MultiplyAccumulateGates = MultiplyAccumulateGates;
  Gates.NeGate = NeGate;
  Gates.OtherX = VariousXGates;
  Gates.OtherY = VariousYGates;
  Gates.OtherZ = VariousZGates;
  Gates.ParametrizedRotationGates = ParametrizedRotationGates;
  Gates.PhaseGradientGates = PhaseGradientGates;
  Gates.PivotFlipGates = PivotFlipGates;
  Gates.PostSelectionGates = PostSelectionGates;
  Gates.Powering = PoweringGates;
  Gates.QuarterTurns = QuarterTurnGates;
  Gates.ReverseBitsGateFamily = ReverseBitsGateFamily;
  Gates.Detector = Detector;
  Gates.SpacerGate = SpacerGate;
  Gates.UniversalNot = UniversalNotGate;
  Gates.XorGates = XorGates;
  Gates.ZeroGate = ZeroGate;
  Gates.KnownToSerializer = $traceurRuntime.spread(Controls.all, InputGates.all, [MeasurementGate, Detector, SwapGateHalf, SpacerGate, UniversalNotGate, ErrorInjectionGate, ZeroGate, NeGate], AmplitudeDisplayFamily.all, ProbabilityDisplayFamily.all, SampleDisplayFamily.all, DensityMatrixDisplayFamily.all, [BlochSphereDisplay], ArithmeticGates.all, BitCountGates.all, ComparisonGates.all, CountingGates.all, CycleBitsGates.all, ExponentiatingGates.all, FourierTransformGates.all, HalfTurnGates.all, IncrementGates.all, InterleaveBitsGates.all, ModularAdditionGates.all, ModularIncrementGates.all, ModularMultiplicationGates.all, ModularMultiplyAccumulateGates.all, MultiplicationGates.all, MultiplyAccumulateGates.all, QuarterTurnGates.all, ParametrizedRotationGates.all, PhaseGradientGates.all, PivotFlipGates.all, PostSelectionGates.all, PoweringGates.all, ReverseBitsGateFamily.all, VariousXGates.all, VariousYGates.all, VariousZGates.all, XorGates.all);
  var gatesById = seq(Gates.KnownToSerializer).keyedBy(function(g) {
    return g.serializedId;
  });
  Gates.findKnownGateById = function(id, customGateSet) {
    return gatesById.has(id) ? gatesById.get(id) : customGateSet.findGateWithSerializedId(id);
  };
  Gates.TopToolboxGroups = [{
    hint: "Half Turns",
    gates: [HalfTurnGates.Z, SwapGateHalf, HalfTurnGates.Y, undefined, HalfTurnGates.X, HalfTurnGates.H]
  }];
  Gates.BottomToolboxGroups = [];
  return {get Gates() {
      return Gates;
    }};
});
//# sourceURL=src/gates/AllGates.js
;$traceurRuntime.registerModule("src/gates/AmplitudeDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/AmplitudeDisplay.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/AmplitudeDisplay.js")).Config;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitShaders.js", "src/gates/AmplitudeDisplay.js")).CircuitShaders;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/AmplitudeDisplay.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/AmplitudeDisplay.js")).GatePainting;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateShaders.js", "src/gates/AmplitudeDisplay.js")).GateShaders;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/gates/AmplitudeDisplay.js")).Format;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/gates/AmplitudeDisplay.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/AmplitudeDisplay.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/AmplitudeDisplay.js")).Point;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/AmplitudeDisplay.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/AmplitudeDisplay.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/gates/AmplitudeDisplay.js")).WglConfiguredShader;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/gates/AmplitudeDisplay.js")),
      Inputs = $__17.Inputs,
      Outputs = $__17.Outputs,
      currentShaderCoder = $__17.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__17.makePseudoShaderWithInputsAndOutputAndCode;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexturePool.js", "src/gates/AmplitudeDisplay.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTextureTrader.js", "src/gates/AmplitudeDisplay.js")).WglTextureTrader;
  function amplitudeDisplayStatTextures(stateKet, controls, rangeOffset, rangeLength) {
    var trader = new WglTextureTrader(stateKet);
    trader.dontDeallocCurrentTexture();
    var startingQubits = currentShaderCoder().vec2.arrayPowerSizeOfTexture(stateKet);
    var lostQubits = Util.numberOfSetBits(controls.inclusionMask);
    var lostHeadQubits = Util.numberOfSetBits(controls.inclusionMask & ((1 << rangeOffset) - 1));
    var involvedQubits = startingQubits - lostQubits;
    trader.shadeAndTrade(function(tex) {
      return CircuitShaders.controlSelect(controls, tex);
    }, WglTexturePool.takeVec2Tex(involvedQubits));
    trader.shadeAndTrade(function(tex) {
      return GateShaders.cycleAllBits(tex, lostHeadQubits - rangeOffset);
    });
    var ketJustAfterCycle = trader.dontDeallocCurrentTexture();
    trader.shadeAndTrade(amplitudesToPolarKets, WglTexturePool.takeVec4Tex(involvedQubits));
    spreadLengthAcrossPolarKets(trader, rangeLength);
    reduceToLongestPolarKet(trader, rangeLength);
    trader.shadeAndTrade(convertAwayFromPolar);
    var amps = trader.dontDeallocCurrentTexture();
    trader.shadeAndTrade(function(winningVectorKet) {
      return toRatiosVsRepresentative(ketJustAfterCycle, winningVectorKet);
    }, WglTexturePool.takeVec4Tex(involvedQubits));
    ketJustAfterCycle.deallocByDepositingInPool("ketJustAfterCycle in makeAmplitudeSpanPipeline");
    foldConsistentRatios(trader, rangeLength);
    signallingSumAll(trader);
    return [amps, trader.currentTexture];
  }
  function processOutputs(span, pixelGroups, circuitDefinition) {
    var $__2,
        $__3;
    var $__1 = pixelGroups,
        ketPixels = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
        consistentPixel = ($__3 = $__2.next()).done ? void 0 : $__3.value;
    var n = ketPixels.length >> 2;
    var w = n === 2 ? 2 : 1 << Math.floor(Math.round(Math.log2(n)) / 2);
    var h = n / w;
    var isPure = !isNaN(consistentPixel[0]) && consistentPixel[0] !== -666.0;
    var unity = ketPixels[2];
    if (!isPure) {
      return _processOutputs_probabilities(w, h, n, unity, ketPixels);
    }
    var phaseIndex = span === circuitDefinition.numWires ? undefined : _processOutputs_pickPhaseLockIndex(ketPixels);
    var phase = phaseIndex === undefined ? 0 : Math.atan2(ketPixels[phaseIndex * 4 + 1], ketPixels[phaseIndex * 4]);
    var c = Math.cos(phase);
    var s = -Math.sin(phase);
    var buf = new Float32Array(n * 2);
    var sqrtUnity = Math.sqrt(unity);
    for (var i = 0; i < n; i++) {
      var real = ketPixels[i * 4] / sqrtUnity;
      var imag = ketPixels[i * 4 + 1] / sqrtUnity;
      buf[i * 2] = real * c + imag * -s;
      buf[i * 2 + 1] = real * s + imag * c;
    }
    return {
      probabilities: undefined,
      superposition: new Matrix(w, h, buf),
      phaseLockIndex: phaseIndex
    };
  }
  function _processOutputs_pickPhaseLockIndex(ketPixels) {
    var result = 0;
    var best = 0;
    for (var k = 0; k < ketPixels.length; k += 4) {
      var r = ketPixels[k];
      var i = ketPixels[k + 1];
      var m = r * r + i * i;
      if (m > best * 10000) {
        best = m;
        result = k >> 2;
      }
    }
    return result;
  }
  function _processOutputs_probabilities(w, h, n, unity, ketPixels) {
    var pBuf = new Float32Array(n * 2);
    for (var k = 0; k < n; k++) {
      var r = ketPixels[k * 4];
      var i = ketPixels[k * 4 + 1];
      pBuf[k * 2] = Math.sqrt((r * r + i * i) / unity);
    }
    return {
      probabilities: new Matrix(w, h, pBuf),
      superposition: undefined,
      phaseLockIndex: undefined
    };
  }
  function amplitudesToPolarKets(input) {
    return AMPLITUDES_TO_POLAR_KETS_SHADER(input);
  }
  var AMPLITUDES_TO_POLAR_KETS_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec4(), "vec4 outputFor(float k) {\n        vec2 ri = read_input(k);\n        float mag = dot(ri, ri);\n        float phase = mag == 0.0 ? 0.0 : atan(ri.y, ri.x);\n        return vec4(mag, phase, mag, 0.0);\n    }");
  function spreadLengthAcrossPolarKets(textureTrader, includedQubitCount) {
    var $__4 = function(bit) {
      textureTrader.shadeAndTrade(function(inp) {
        return SPREAD_LENGTH_ACROSS_POLAR_KETS_SHADER(inp, WglArg.float('bit', 1 << bit));
      });
    };
    for (var bit = 0; bit < includedQubitCount; bit++) {
      $__4(bit);
    }
  }
  var SPREAD_LENGTH_ACROSS_POLAR_KETS_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4(), "\n    uniform float bit;\n\n    float xorBit(float v) {\n        float b = mod(floor(v/bit), 2.0);\n        float d = 1.0 - 2.0*b;\n        return v + bit*d;\n    }\n\n    vec4 outputFor(float k) {\n        float partner = xorBit(k);\n        vec4 v = read_input(k);\n        vec4 p = read_input(partner);\n        return vec4(v.x, v.y, v.z + p.z, 0.0);\n    }");
  function reduceToLongestPolarKet(textureTrader, includedQubitCount) {
    var curQubitCount = currentShaderCoder().vec4.arrayPowerSizeOfTexture(textureTrader.currentTexture);
    while (curQubitCount > includedQubitCount) {
      curQubitCount -= 1;
      textureTrader.shadeHalveAndTrade(function(inp) {
        return FOLD_REPRESENTATIVE_POLAR_KET_SHADER(inp, WglArg.float('offset', 1 << curQubitCount));
      });
    }
  }
  var FOLD_REPRESENTATIVE_POLAR_KET_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4(), "\n    uniform float offset;\n\n    vec4 outputFor(float k) {\n        vec4 p = read_input(k);\n        vec4 q = read_input(k + offset);\n        return vec4(\n            p.x + q.x,\n            // Bias towards p1 is to keep the choice stable in the face of uniform superpositions and noise.\n            p.z*1.001 >= q.z ? p.y : q.y,\n            p.z + q.z,\n            0.0);\n    }");
  function convertAwayFromPolar(input) {
    return CONVERT_AWAY_FROM_POLAR_SHADER(input);
  }
  var CONVERT_AWAY_FROM_POLAR_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4(), "\n    vec4 outputFor(float k) {\n        vec4 polar = read_input(k);\n        float mag = sqrt(polar.x);\n        return vec4(mag * cos(polar.y), mag * sin(polar.y), polar.z, 0.0);\n    }");
  var toRatiosVsRepresentative = function(ket, rep) {
    return TO_RATIOS_VS_REPRESENTATIVE_SHADER(ket, rep);
  };
  var TO_RATIOS_VS_REPRESENTATIVE_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('ket'), Inputs.vec4('rep')], Outputs.vec4(), "vec4 outputFor(float k) {\n        return vec4(read_ket(k), read_rep(mod(k, len_rep())).xy);\n    }");
  function foldConsistentRatios(textureTrader, includedQubitCount) {
    var curQubitCount = currentShaderCoder().vec4.arrayPowerSizeOfTexture(textureTrader.currentTexture);
    var remainingIncludedQubitCount = includedQubitCount;
    while (remainingIncludedQubitCount > 0) {
      remainingIncludedQubitCount -= 1;
      curQubitCount -= 1;
      textureTrader.shadeHalveAndTrade(function(inp) {
        return FOLD_CONSISTENT_RATIOS_SHADER(inp, WglArg.float('bit', 1 << remainingIncludedQubitCount));
      });
    }
  }
  var FOLD_CONSISTENT_RATIOS_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4(), "\n    uniform float bit;\n\n    vec2 mul(vec2 c1, vec2 c2) {\n        return vec2(c1.x*c2.x - c1.y*c2.y, c1.x*c2.y + c1.y*c2.x);\n    }\n    vec4 mergeRatios(vec4 a, vec4 b) {\n        vec2 c1 = mul(a.xy, b.zw);\n        vec2 c2 = mul(a.zw, b.xy);\n        vec2 d = c1 - c2;\n        float err = dot(d, d);\n        // The max up-scaling controls a tricky tradeoff between noisy false positives and blurry false negatives.\n        err /= max(0.00000000001, min(abs(dot(c1, c1)), abs(dot(c2,c2))));\n        float m1 = dot(a, a);\n        float m2 = dot(b, b);\n        return a.x == -666.0 || b.x == -666.0 || err > 0.001 ? vec4(-666.0, -666.0, -666.0, -666.0)\n            : m1 >= m2 ? a\n            : b;\n    }\n\n    vec4 outputFor(float k) {\n        float s1 = mod(k, bit) + floor(k/bit)*2.0*bit;\n        float s2 = s1 + bit;\n        vec4 v1 = read_input(s1);\n        vec4 v2 = read_input(s2);\n\n        return mergeRatios(v1, v2);\n    }");
  function signallingSumAll(textureTrader) {
    var curQubitCount = currentShaderCoder().vec4.arrayPowerSizeOfTexture(textureTrader.currentTexture);
    while (curQubitCount > 0) {
      curQubitCount -= 1;
      textureTrader.shadeHalveAndTrade(SIGNALLING_SUM_SHADER_VEC4);
    }
  }
  var SIGNALLING_SUM_SHADER_VEC4 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4(), "vec4 outputFor(float k) {\n        vec4 a = read_input(k);\n        vec4 b = read_input(k + len_output());\n        return a.x == -666.0 || b.x == -666.0 ? vec4(-666.0, -666.0, -666.0, -666.0) : a + b;\n    }");
  var AMPLITUDE_DRAWER_FROM_CUSTOM_STATS = GatePainting.makeDisplayDrawer(function(args) {
    var n = args.gate.height;
    var $__1 = args.customStats || {
      probabilities: undefined,
      superposition: (n === 1 ? Matrix.zero(2, 1) : Matrix.zero(1 << Math.floor(n / 2), 1 << Math.ceil(n / 2))).times(NaN),
      phaseLockIndex: undefined
    },
        probabilities = $__1.probabilities,
        superposition = $__1.superposition,
        phaseLockIndex = $__1.phaseLockIndex;
    var matrix = probabilities || superposition;
    var isIncoherent = superposition === undefined;
    var dw = args.rect.w - args.rect.h * matrix.width() / matrix.height();
    var drawRect = args.rect.skipLeft(dw / 2).skipRight(dw / 2);
    MathPainter.paintMatrix(args.painter, matrix, drawRect, Config.SUPERPOSITION_MID_COLOR, 'black', Config.SUPERPOSITION_FORE_COLOR, Config.SUPERPOSITION_BACK_COLOR, isIncoherent ? 'transparent' : 'black');
    var forceSign = function(v) {
      return (v >= 0 ? '+' : '') + v.toFixed(2);
    };
    if (isIncoherent) {
      MathPainter.paintMatrixTooltip(args.painter, matrix, drawRect, args.focusPoints, function(c, r) {
        return ("Chance of |" + Util.bin(r * matrix.width() + c, args.gate.height) + "⟩ [amplitude not defined]");
      }, function(c, r, v) {
        return ("raw: " + (v.norm2() * 100).toFixed(4) + "%, log: " + (Math.log10(v.norm2()) * 10).toFixed(1) + " dB");
      }, function(c, r, v) {
        return '[entangled with other qubits]';
      });
    } else {
      MathPainter.paintMatrixTooltip(args.painter, matrix, drawRect, args.focusPoints, function(c, r) {
        return ("Amplitude of |" + Util.bin(r * matrix.width() + c, args.gate.height) + "⟩");
      }, function(c, r, v) {
        return 'val:' + v.toString(new Format(false, 0, 5, ", "));
      }, function(c, r, v) {
        return ("mag²:" + (v.norm2() * 100).toFixed(4) + "%, phase:" + forceSign(v.phase() * 180 / Math.PI) + "°");
      });
      if (phaseLockIndex !== undefined) {
        var cw = drawRect.w / matrix.width();
        var rh = drawRect.h / matrix.height();
        var c = phaseLockIndex % matrix.width();
        var r = Math.floor(phaseLockIndex / matrix.width());
        var cx = drawRect.x + cw * (c + 0.5);
        var cy = drawRect.y + rh * (r + 0.5);
        args.painter.strokeLine(new Point(cx, cy), new Point(cx + cw / 2, cy), 'red', 2);
        args.painter.print('fixed', cx + 0.5 * cw, cy, 'right', 'bottom', 'red', '12px monospace', cw * 0.5, rh * 0.5);
      }
    }
    paintErrorIfPresent(args, isIncoherent);
  });
  function paintErrorIfPresent(args, isIncoherent) {
    var err = undefined;
    var $__1 = args.positionInCircuit,
        col = $__1.col,
        row = $__1.row;
    var measured = ((args.stats.circuitDefinition.colIsMeasuredMask(col) >> row) & ((1 << args.gate.height) - 1)) !== 0;
    if (isIncoherent) {
      err = 'incoherent';
    } else if (measured) {
      err = args.gate.width <= 2 ? '(w/ measure defer)' : '(assuming measurement deferred)';
    }
    if (err !== undefined) {
      args.painter.print(err, args.rect.x + args.rect.w / 2, args.rect.y + args.rect.h, 'center', 'hanging', 'red', '12px sans-serif', args.rect.w, args.rect.h, undefined);
    }
  }
  var AmplitudeDisplayFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("Amps" + span).setSymbol("Amps").setTitle("Amplitude Display").setBlurb("Shows the amplitudes of some wires, if separable.\nUse controls to see conditional amplitudes.").setWidth(span === 1 ? 2 : span % 2 === 0 ? span : Math.ceil(span / 2)).promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function(args) {
      return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
    }).setStatTexturesMaker(function(ctx) {
      return amplitudeDisplayStatTextures(ctx.stateTrader.currentTexture, ctx.controls, ctx.row, span);
    }).setStatPixelDataPostProcessor(function(val, def) {
      return processOutputs(span, val, def);
    }).setDrawer(AMPLITUDE_DRAWER_FROM_CUSTOM_STATS);
  });
  return {
    get AmplitudeDisplayFamily() {
      return AmplitudeDisplayFamily;
    },
    get amplitudesToPolarKets() {
      return amplitudesToPolarKets;
    },
    get convertAwayFromPolar() {
      return convertAwayFromPolar;
    },
    get amplitudeDisplayStatTextures() {
      return amplitudeDisplayStatTextures;
    },
    get reduceToLongestPolarKet() {
      return reduceToLongestPolarKet;
    },
    get foldConsistentRatios() {
      return foldConsistentRatios;
    },
    get spreadLengthAcrossPolarKets() {
      return spreadLengthAcrossPolarKets;
    },
    get signallingSumAll() {
      return signallingSumAll;
    },
    get toRatiosVsRepresentative() {
      return toRatiosVsRepresentative;
    }
  };
});
//# sourceURL=src/gates/AmplitudeDisplay.js
;$traceurRuntime.registerModule("src/gates/ArithmeticGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ArithmeticGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ArithmeticGates.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/ArithmeticGates.js")).GatePainting;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/ArithmeticGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/ArithmeticGates.js")).WglArg;
  var ArithmeticGates = {};
  var chunkedScaledAdditionPermutationMaker = function(span, factor) {
    return function(e) {
      var sa = Math.floor(span / 2);
      var sb = Math.ceil(span / 2);
      var a = e & ((1 << sa) - 1);
      var b = e >> sa;
      b += a * factor;
      b &= ((1 << sb) - 1);
      return a + (b << sa);
    };
  };
  var ADDITION_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float d = read_input_A();\n        d *= factor;\n        d = mod(d, span);\n        return mod(out_id + span - d, span);");
  ArithmeticGates.Legacy_AdditionFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("add" + span).setSymbol("b+=a").setTitle("Addition Gate").setBlurb("Adds a little-endian number into another.").setDrawer(GatePainting.SECTIONED_DRAWER_MAKER(["a", "b+=a"], [Math.floor(span / 2) / span])).setActualEffectToUpdateFunc(function(ctx) {
      return ArithmeticGates.PlusAFamily.ofSize(Math.ceil(span / 2)).customOperation(ctx.withRow(ctx.row + Math.floor(span / 2)).withInputSetToRange('A', ctx.row, Math.floor(span / 2)));
    }).setKnownEffectToPermutation(chunkedScaledAdditionPermutationMaker(span, 1));
  });
  ArithmeticGates.Legacy_SubtractionFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("sub" + span).setSymbol("b-=a").setTitle("Subtraction Gate").setBlurb("Subtracts a little-endian number from another.").setDrawer(GatePainting.SECTIONED_DRAWER_MAKER(["a", "b-=a"], [Math.floor(span / 2) / span])).setActualEffectToUpdateFunc(function(ctx) {
      return ArithmeticGates.MinusAFamily.ofSize(Math.ceil(span / 2)).customOperation(ctx.withRow(ctx.row + Math.floor(span / 2)).withInputSetToRange('A', ctx.row, Math.floor(span / 2)));
    }).setKnownEffectToPermutation(chunkedScaledAdditionPermutationMaker(span, -1));
  });
  ArithmeticGates.PlusAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+=A" + span).setSymbol("+A").setTitle("Addition Gate [input A]").setBlurb("Adds input A into the qubits covered by this gate.").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = ADDITION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(v, a) {
      return (v + a) & ((1 << span) - 1);
    });
  });
  ArithmeticGates.MinusAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("-=A" + span).setSymbol("−A").setTitle("Subtraction Gate [input A]").setBlurb("Subtracts input A out of the qubits covered by this gate.").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = ADDITION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(v, a) {
      return (v - a) & ((1 << span) - 1);
    });
  });
  ArithmeticGates.all = $traceurRuntime.spread(ArithmeticGates.Legacy_AdditionFamily.all, ArithmeticGates.Legacy_SubtractionFamily.all, ArithmeticGates.PlusAFamily.all, ArithmeticGates.MinusAFamily.all);
  return {get ArithmeticGates() {
      return ArithmeticGates;
    }};
});
//# sourceURL=src/gates/ArithmeticGates.js
;$traceurRuntime.registerModule("src/gates/BitCountGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/BitCountGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/BitCountGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/BitCountGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/BitCountGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/BitCountGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/BitCountGates.js")).WglArg;
  var BitCountGates = {};
  var POP_COUNT_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), ("\n        float d = read_input_A();\n        float popcnt = 0.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            popcnt += mod(d, 2.0);\n            d = floor(d / 2.0);\n        }\n        float offset = mod(popcnt * factor, span);\n        return mod(out_id + span - offset, span);"));
  BitCountGates.PlusBitCountAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedIdAndSymbol("+cntA" + span).setSymbol("+1s(A)").setTitle("Bit Count Gate").setBlurb("Counts the number of ON bits in input A and adds that into this output.").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = POP_COUNT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return (t + Util.numberOfSetBits(a)) & ((1 << span) - 1);
    });
  });
  BitCountGates.MinusBitCountAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedIdAndSymbol("-cntA" + span).setSymbol("-1s(A)").setTitle("Bit Un-Count Gate").setBlurb("Counts the number of ON bits in input A and subtracts that into this output.").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = POP_COUNT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return (t - Util.numberOfSetBits(a)) & ((1 << span) - 1);
    });
  });
  BitCountGates.all = $traceurRuntime.spread(BitCountGates.PlusBitCountAFamily.all, BitCountGates.MinusBitCountAFamily.all);
  return {get BitCountGates() {
      return BitCountGates;
    }};
});
//# sourceURL=src/gates/BitCountGates.js
;$traceurRuntime.registerModule("src/gates/BlochSphereDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/BlochSphereDisplay.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/BlochSphereDisplay.js")).Config;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/BlochSphereDisplay.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/BlochSphereDisplay.js")).GatePainting;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/gates/BlochSphereDisplay.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/BlochSphereDisplay.js")).Point;
  function _paintBlochSphereDisplay_tooltips(painter, drawArea, x, y, z, focusPoints) {
    var c = drawArea.center();
    var u = Math.min(drawArea.w, drawArea.h) / 2;
    if (focusPoints.every(function(pt) {
      return pt.distanceTo(c) >= u;
    })) {
      return;
    }
    var τ = Math.PI * 2;
    var deg = function(v) {
      return (v >= 0 ? '+' : '') + (v * 360 / τ).toFixed(2) + '°';
    };
    var forceSign = function(v) {
      return (v >= 0 ? '+' : '') + v.toFixed(4);
    };
    var d = Math.sqrt(x * x + y * y + z * z);
    var ϕ = Math.atan2(y, -x);
    var θ = Math.max(0, Math.PI / 2 - Math.atan2(-z, Math.sqrt(y * y + x * x)));
    painter.strokeCircle(c, u, 'orange', 2);
    MathPainter.paintDeferredValueTooltip(painter, c.x + u * Math.sqrt(0.5), c.y - u * Math.sqrt(0.5), 'Bloch sphere representation of local state', ("r:" + forceSign(d) + ", ϕ:" + deg(ϕ) + ", θ:" + deg(θ)), ("x:" + forceSign(-x) + ", y:" + forceSign(y) + ", z:" + forceSign(-z)));
  }
  function _paintBlochSphereDisplay_indicator(painter, x, y, z, drawArea, fillColor) {
    var c = drawArea.center();
    var u = Math.min(drawArea.w, drawArea.h) / 2;
    var $__7 = MathPainter.coordinateSystem(u),
        dx = $__7.dx,
        dy = $__7.dy,
        dz = $__7.dz;
    var p = c.plus(dx.times(x)).plus(dy.times(y)).plus(dz.times(z));
    var r = 3.8 / (1 + x / 6);
    painter.strokeLine(c, p, 'black', 1.5);
    painter.fillCircle(p, r, fillColor);
    painter.ctx.save();
    painter.ctx.globalAlpha *= Math.min(1, Math.max(0, 1 - x * x - y * y - z * z));
    painter.fillCircle(p, r, 'yellow');
    painter.ctx.restore();
    painter.strokeCircle(p, r, 'black');
    painter.ctx.save();
    painter.ctx.globalAlpha *= Math.min(1, Math.max(0, 0.5 + x * 5));
    painter.strokeLine(c, p, 'black', 2);
    painter.ctx.restore();
  }
  function paintBlochSphereDisplay(painter, qubitDensityMatrix, drawArea) {
    var $__9,
        $__10,
        $__11,
        $__12,
        $__13;
    var focusPoints = arguments[3] !== (void 0) ? arguments[3] : [];
    var backgroundColor = arguments[4] !== (void 0) ? arguments[4] : Config.DISPLAY_GATE_BACK_COLOR;
    var fillColor = arguments[5] !== (void 0) ? arguments[5] : Config.DISPLAY_GATE_FORE_COLOR;
    var c = drawArea.center();
    var u = Math.min(drawArea.w, drawArea.h) / 2;
    var $__7 = MathPainter.coordinateSystem(u),
        dx = $__7.dx,
        dy = $__7.dy,
        dz = $__7.dz;
    painter.fillCircle(c, u, backgroundColor);
    painter.trace(function(trace) {
      trace.circle(c.x, c.y, u);
      trace.ellipse(c.x, c.y, dy.x, dx.y);
      trace.ellipse(c.x, c.y, dx.x, dz.y);
      var $__3 = true;
      var $__4 = false;
      var $__5 = undefined;
      try {
        for (var $__1 = void 0,
            $__0 = ([dx, dy, dz])[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
          var d = $__1.value;
          {
            trace.line(c.x - d.x, c.y - d.y, c.x + d.x, c.y + d.y);
          }
        }
      } catch ($__6) {
        $__4 = true;
        $__5 = $__6;
      } finally {
        try {
          if (!$__3 && $__0.return != null) {
            $__0.return();
          }
        } finally {
          if ($__4) {
            throw $__5;
          }
        }
      }
    }).thenStroke('#BBB');
    var $__8 = [NaN, NaN, NaN],
        x = ($__9 = $__8[Symbol.iterator](), ($__10 = $__9.next()).done ? void 0 : $__10.value),
        y = ($__10 = $__9.next()).done ? void 0 : $__10.value,
        z = ($__10 = $__9.next()).done ? void 0 : $__10.value;
    if (qubitDensityMatrix.hasNaN()) {
      painter.printParagraph("NaN", drawArea, new Point(0.5, 0.5), 'red');
    } else {
      ($__11 = qubitDensityMatrix.qubitDensityMatrixToBlochVector(), x = ($__12 = $__11[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value), y = ($__13 = $__12.next()).done ? void 0 : $__13.value, z = ($__13 = $__12.next()).done ? void 0 : $__13.value, $__11);
      _paintBlochSphereDisplay_indicator(painter, x, y, z, drawArea, fillColor);
    }
    _paintBlochSphereDisplay_tooltips(painter, drawArea, x, y, z, focusPoints);
  }
  var BlochSphereDisplay = new GateBuilder().setSerializedIdAndSymbol("Bloch").setTitle("Bloch Sphere Display").setBlurb("Shows a wire's local state as a point on the Bloch Sphere.\nUse controls to see conditional states.").markAsDrawerNeedsSingleQubitDensityStats().setDrawer(GatePainting.makeDisplayDrawer(function(args) {
    var $__7 = args.positionInCircuit,
        row = $__7.row,
        col = $__7.col;
    var ρ = args.stats.qubitDensityMatrix(col, row);
    paintBlochSphereDisplay(args.painter, ρ, args.rect, args.focusPoints);
  })).promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function(args) {
    return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
  }).gate;
  return {
    get paintBlochSphereDisplay() {
      return paintBlochSphereDisplay;
    },
    get BlochSphereDisplay() {
      return BlochSphereDisplay;
    }
  };
});
//# sourceURL=src/gates/BlochSphereDisplay.js
;$traceurRuntime.registerModule("src/gates/ComparisonGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ComparisonGates.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ComparisonGates.js")).GateBuilder;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/ComparisonGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/gates/ComparisonGates.js")).WglConfiguredShader;
  var ComparisonGates = {};
  function customComparisonShader(compareCode) {
    var shader = ketShaderPermute(("\n            " + ketInputGateShaderCode('A') + "\n            " + ketInputGateShaderCode('B') + "\n        "), ("\n            float lhs = read_input_A();\n            float rhs = read_input_B();\n            return mod(out_id + ((" + compareCode + ") ? 1.0 : 0.0), 2.0);"));
    return function(ctx) {
      var $__1;
      return ($__1 = shader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, 1, ['A', 'B'])));
    };
  }
  ComparisonGates.ALessThanB = new GateBuilder().setSerializedId("^A<B").setSymbol("⊕A<B").setTitle("Less-Than Gate").setBlurb("Toggles a qubit if input A is less than input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs < rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a < b ? 1 : 0);
  }).gate;
  ComparisonGates.AGreaterThanB = new GateBuilder().setSerializedId("^A>B").setSymbol("⊕A>B").setTitle("Greater-Than Gate").setBlurb("Toggles a qubit if input A is greater than input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs > rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a > b ? 1 : 0);
  }).gate;
  ComparisonGates.ALessThanOrEqualToB = new GateBuilder().setSerializedId("^A<=B").setSymbol("⊕A≤B").setTitle("At-Most Gate").setBlurb("Toggles a qubit if input A is at most input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs <= rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a <= b ? 1 : 0);
  }).gate;
  ComparisonGates.AGreaterThanOrEqualToB = new GateBuilder().setSerializedId("^A>=B").setSymbol("⊕A≥B").setTitle("At-Least Gate").setBlurb("Toggles a qubit if input A is at least input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs >= rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a >= b ? 1 : 0);
  }).gate;
  ComparisonGates.AEqualToB = new GateBuilder().setSerializedId("^A=B").setSymbol("⊕A=B").setTitle("Equality Gate").setBlurb("Toggles a qubit if input A is equal to input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs == rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a === b ? 1 : 0);
  }).gate;
  ComparisonGates.ANotEqualToB = new GateBuilder().setSerializedId("^A!=B").setSymbol("⊕A≠B").setTitle("Inequality Gate").setBlurb("Toggles a qubit if input A isn't equal to input B.").setRequiredContextKeys("Input Range A", "Input Range B").setActualEffectToShaderProvider(customComparisonShader('lhs != rhs')).setKnownEffectToParametrizedPermutation(function(v, a, b) {
    return v ^ (a !== b ? 1 : 0);
  }).gate;
  ComparisonGates.all = [ComparisonGates.ALessThanB, ComparisonGates.AGreaterThanB, ComparisonGates.AEqualToB, ComparisonGates.ANotEqualToB, ComparisonGates.ALessThanOrEqualToB, ComparisonGates.AGreaterThanOrEqualToB];
  return {get ComparisonGates() {
      return ComparisonGates;
    }};
});
//# sourceURL=src/gates/ComparisonGates.js
;$traceurRuntime.registerModule("src/gates/Controls.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Controls.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/Controls.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/Controls.js")).GatePainting;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateShaders.js", "src/gates/Controls.js")).GateShaders;
  var HalfTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/HalfTurnGates.js", "src/gates/Controls.js")).HalfTurnGates;
  var QuarterTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/QuarterTurnGates.js", "src/gates/Controls.js")).QuarterTurnGates;
  var Controls = {};
  Controls.Control = new GateBuilder().setSerializedIdAndSymbol("•").setTitle("Control").setBlurb("Conditions on a qubit being ON.\nGates in the same column only apply to states meeting the condition.").promiseHasNoNetEffectOnStateVector().markAsControlExpecting(true).setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    args.painter.fillCircle(args.rect.center(), 5, "black");
  }).gate;
  Controls.AntiControl = new GateBuilder().setSerializedIdAndSymbol("◦").setTitle("Anti-Control").setBlurb("Conditions on a qubit being OFF.\nGates in the same column only apply to states meeting the condition.").promiseHasNoNetEffectOnStateVector().markAsControlExpecting(false).setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var p = args.rect.center();
    args.painter.fillCircle(p, 5);
    args.painter.strokeCircle(p, 5);
  }).gate;
  Controls.XAntiControl = new GateBuilder().setSerializedId("⊕").setSymbol("⊖").setTitle("X-Axis Anti-Control").setBlurb("Conditions on a qubit being ON+OFF.\n" + "Gates in the same column only apply to states meeting the condition.").markAsControlExpecting(false).setSetupCleanupEffectToUpdateFunc(HalfTurnGates.H.customOperation, HalfTurnGates.H.customOperation).setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var p = args.rect.center();
    args.painter.fillCircle(p, 5);
    args.painter.strokeCircle(p, 5);
    args.painter.strokeLine(p.offsetBy(-5, 0), p.offsetBy(+5, 0));
  }).gate;
  Controls.XControl = new GateBuilder().setSerializedId("⊖").setSymbol("⊕").setTitle("X-Axis Control").setBlurb("Conditions on a qubit being ON-OFF.\n" + "Gates in the same column only apply to states meeting the condition.").markAsControlExpecting(true).setSetupCleanupEffectToUpdateFunc(HalfTurnGates.H.customOperation, HalfTurnGates.H.customOperation).setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var p = args.rect.center();
    args.painter.fillCircle(p, 5);
    args.painter.strokeCircle(p, 5);
    args.painter.strokeLine(p.offsetBy(0, -5), p.offsetBy(0, +5));
    args.painter.strokeLine(p.offsetBy(-5, 0), p.offsetBy(+5, 0));
  }).gate;
  Controls.YAntiControl = new GateBuilder().setSerializedId("⊗").setSymbol("(/)").setTitle("Y-Axis Anti-Control").setBlurb("Conditions on a qubit being ON+iOFF.\n" + "Gates in the same column only apply to states meeting the condition.").markAsControlExpecting(false).setSetupCleanupEffectToUpdateFunc(function(ctx) {
    return GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXForward._knownMatrix);
  }, function(ctx) {
    return GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXBackward._knownMatrix);
  }).setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var p = args.rect.center();
    args.painter.fillCircle(p, 5);
    args.painter.strokeCircle(p, 5);
    var r = 5 * Math.sqrt(0.5) * 1.1;
    args.painter.strokeLine(p.offsetBy(+r, -r), p.offsetBy(-r, +r));
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.paintOutline(args);
    }
  }).gate;
  Controls.YControl = new GateBuilder().setSerializedId("(/)").setSymbol("⊗").setTitle("Y-Axis Control").setBlurb("Conditions on a qubit being ON-iOFF.\n" + "Gates in the same column only apply to states meeting the condition.").markAsControlExpecting(true).setSetupCleanupEffectToUpdateFunc(function(ctx) {
    return GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXForward._knownMatrix);
  }, function(ctx) {
    return GateShaders.applyMatrixOperation(ctx, QuarterTurnGates.SqrtXBackward._knownMatrix);
  }).setActualEffectToUpdateFunc(function() {}).promiseEffectIsStable().setDrawer(function(ctx) {
    if (ctx.isInToolbox || ctx.isHighlighted) {
      GatePainting.paintBackground(ctx);
      GatePainting.paintOutline(ctx);
    }
    var p = ctx.rect.center();
    ctx.painter.fillCircle(p, 5);
    ctx.painter.strokeCircle(p, 5);
    var r = 5 * Math.sqrt(0.5);
    ctx.painter.strokeLine(p.offsetBy(+r, +r), p.offsetBy(-r, -r));
    ctx.painter.strokeLine(p.offsetBy(+r, -r), p.offsetBy(-r, +r));
    if (ctx.isInToolbox || ctx.isHighlighted) {
      GatePainting.paintOutline(ctx);
    }
  }).gate;
  Controls.all = [Controls.Control, Controls.AntiControl, Controls.XAntiControl, Controls.XControl, Controls.YAntiControl, Controls.YControl];
  return {get Controls() {
      return Controls;
    }};
});
//# sourceURL=src/gates/Controls.js
;$traceurRuntime.registerModule("src/gates/CountingGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/CountingGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/CountingGates.js")).Config;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/CountingGates.js")),
      Gate = $__7.Gate,
      GateBuilder = $__7.GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/CountingGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/CountingGates.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/CountingGates.js")).Point;
  var ketArgs = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/CountingGates.js")).ketArgs;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/CountingGates.js")).WglArg;
  var offsetShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/IncrementGates.js", "src/gates/CountingGates.js")).offsetShader;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/CycleBitsGates.js", "src/gates/CountingGates.js")),
      makeCycleBitsPermutation = $__14.makeCycleBitsPermutation,
      cycleBitsShader = $__14.cycleBitsShader;
  var CountingGates = {};
  var staircaseCurve = function(steps) {
    steps = Math.min(128, steps);
    var curve = [];
    for (var i = 0; i < steps; i++) {
      var x = i / steps;
      var y = i / (steps - 1);
      if (steps < 128) {
        curve.push(new Point(x, y));
      }
      curve.push(new Point(x + 1 / steps, y));
    }
    return curve;
  };
  var STAIRCASE_DRAWER = function(timeOffset, steps) {
    var flip = arguments[2] !== (void 0) ? arguments[2] : false;
    return function(args) {
      var $__4,
          $__5;
      var $__1,
          $__2,
          $__3;
      GatePainting.MAKE_HIGHLIGHTED_DRAWER(Config.TIME_DEPENDENT_HIGHLIGHT_COLOR)(args);
      if (args.isInToolbox && !args.isHighlighted) {
        return;
      }
      var t = (args.stats.time + timeOffset) % 1;
      var yOn = args.rect.y + 3;
      var yNeutral = args.rect.bottom();
      var yOff = args.rect.bottom() - 3;
      if (!flip) {
        ($__1 = [yOff, yOn], yOn = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value), yOff = ($__3 = $__2.next()).done ? void 0 : $__3.value, $__1);
        yNeutral = args.rect.y;
      }
      var xi = args.rect.x;
      var xf = args.rect.right();
      var xt = function(p) {
        return Math.min(Math.max(xi + (xf - xi) * p, xi), xf);
      };
      var yt = function(p) {
        return yOff + (yOn - yOff) * p;
      };
      var curve = [];
      curve.push(new Point(xi, yNeutral));
      ($__4 = curve).push.apply($__4, $traceurRuntime.spread(staircaseCurve(steps).map(function(p) {
        return new Point(xt(p.x - t), yt(p.y));
      })));
      ($__5 = curve).push.apply($__5, $traceurRuntime.spread(staircaseCurve(steps).map(function(p) {
        return new Point(xt(p.x + 1 - t), yt(p.y));
      })));
      curve.push(new Point(xf, yNeutral));
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.3;
      args.painter.fillPolygon(curve, 'yellow');
      for (var i = 1; i < curve.length - 2; i++) {
        args.painter.strokeLine(curve[i], curve[i + 1], 'black');
      }
      if (steps === 2 && t < 0.5) {
        args.painter.fillRect(args.rect, 'white');
        args.painter.fillRect(args.rect, 'white');
        args.painter.fillRect(args.rect, 'white');
      }
      args.painter.ctx.restore();
    };
  };
  function offsetPermutation(time, factor, span, state) {
    var offset = Math.floor(time * (1 << span)) * factor;
    return (state + offset) & ((1 << span) - 1);
  }
  function bitOffsetPermutation(time, factor, span, state) {
    var offset = Math.floor(time * span) * factor;
    return makeCycleBitsPermutation(offset, span)(state);
  }
  CountingGates.ClockPulseGate = new GateBuilder().setSerializedIdAndSymbol("X^⌈t⌉").setTitle("Clock Pulse Gate").setBlurb("Xors a square wave into the target wire.").setDrawer(STAIRCASE_DRAWER(0, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return (t % 1) < 0.5 ? Matrix.identity(2) : Matrix.PAULI_X;
  }).promiseEffectOnlyPermutesAndPhases().gate;
  CountingGates.QuarterPhaseClockPulseGate = new GateBuilder().setSerializedIdAndSymbol("X^⌈t-¼⌉").setTitle("Clock Pulse Gate (Quarter Phase)").setBlurb("Xors a quarter-phased square wave into the target wire.").setDrawer(STAIRCASE_DRAWER(0.75, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return ((t + 0.75) % 1) < 0.5 ? Matrix.identity(2) : Matrix.PAULI_X;
  }).promiseEffectOnlyPermutesAndPhases().gate;
  CountingGates.CountingFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("Counting" + span).setSymbol("+⌈t⌉").setTitle("Counting Gate").setBlurb("Adds an increasing little-endian count into a block of qubits.").setDrawer(STAIRCASE_DRAWER(0, 1 << span)).setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = offsetShader).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("amount", Math.floor(ctx.time * (1 << span)))]));
    }).setKnownEffectToTimeVaryingPermutation(function(t, i) {
      return offsetPermutation(t, +1, span, i);
    });
  });
  CountingGates.UncountingFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("Uncounting" + span).setSymbol("-⌈t⌉").setTitle("Down Counting Gate").setBlurb("Subtracts an increasing little-endian count from a block of qubits.").setDrawer(STAIRCASE_DRAWER(0, 1 << span, true)).setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = offsetShader).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("amount", -Math.floor(ctx.time * (1 << span)))]));
    }).setKnownEffectToTimeVaryingPermutation(function(t, i) {
      return offsetPermutation(t, -1, span, i);
    });
  });
  CountingGates.RightShiftRotatingFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId(">>t" + span).setSymbol("↟⌈t⌉").setTitle("Right-Shift Cycling Gate").setBlurb("Right-rotates a block of bits by more and more.").setDrawer(STAIRCASE_DRAWER(0, span, true)).setActualEffectToShaderProvider(function(ctx) {
      return cycleBitsShader(ctx, span, -Math.floor(ctx.time * span));
    }).setKnownEffectToTimeVaryingPermutation(function(t, i) {
      return bitOffsetPermutation(t, -1, span, i);
    });
  });
  CountingGates.LeftShiftRotatingFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("<<t" + span).setSymbol("↡⌈t⌉").setTitle("Left-Shift Cycling Gate").setBlurb("Left-rotates a block of bits by more and more.").setDrawer(STAIRCASE_DRAWER(0, span)).setActualEffectToShaderProvider(function(ctx) {
      return cycleBitsShader(ctx, span, Math.floor(ctx.time * span));
    }).setKnownEffectToTimeVaryingPermutation(function(t, i) {
      return bitOffsetPermutation(t, +1, span, i);
    });
  });
  CountingGates.all = $traceurRuntime.spread([CountingGates.ClockPulseGate, CountingGates.QuarterPhaseClockPulseGate], CountingGates.CountingFamily.all, CountingGates.UncountingFamily.all, CountingGates.RightShiftRotatingFamily.all, CountingGates.LeftShiftRotatingFamily.all);
  return {get CountingGates() {
      return CountingGates;
    }};
});
//# sourceURL=src/gates/CountingGates.js
;$traceurRuntime.registerModule("src/gates/CycleBitsGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/CycleBitsGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/CycleBitsGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/CycleBitsGates.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/CycleBitsGates.js")).GatePainting;
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/CycleBitsGates.js")),
      ketArgs = $__5.ketArgs,
      ketShaderPermute = $__5.ketShaderPermute;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/CycleBitsGates.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/CycleBitsGates.js")).Point;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/CycleBitsGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/CycleBitsGates.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/gates/CycleBitsGates.js")).WglConfiguredShader;
  var CycleBitsGates = {};
  var cycleBitsShader = function(ctx, qubitSpan, shiftAmount) {
    var $__1;
    return ($__1 = CYCLE_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, qubitSpan), [WglArg.float("amount", 1 << Util.properMod(-shiftAmount, qubitSpan))]));
  };
  var CYCLE_SHADER = ketShaderPermute('uniform float amount;', 'out_id *= amount; return mod(out_id, span) + floor(out_id / span);');
  var makeCycleBitsPermutation = function(shift, span) {
    return function(e) {
      shift = Util.properMod(shift, span);
      return ((e << shift) & ((1 << span) - 1)) | (e >> (span - shift));
    };
  };
  var makeCycleBitsMatrix = function(shift, span) {
    return Matrix.generateTransition(1 << span, makeCycleBitsPermutation(shift, span));
  };
  var cyclePainter = function(reverse) {
    return function(args) {
      if (args.positionInCircuit !== undefined) {
        GatePainting.PERMUTATION_DRAWER(args);
        return;
      }
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
      GatePainting.paintResizeTab(args);
      var x1 = args.rect.x + 6;
      var x2 = args.rect.right() - 6;
      var y = args.rect.center().y - Config.GATE_RADIUS + 6;
      var dh = (Config.GATE_RADIUS - 6) * 2 / 2;
      for (var i = 0; i < 3; i++) {
        var j = (i + (reverse ? 2 : 1)) % 3;
        var y1 = y + i * dh;
        var y2 = y + j * dh;
        args.painter.strokePath([new Point(x1, y1), new Point(x1 + 8, y1), new Point(x2 - 8, y2), new Point(x2, y2)]);
      }
    };
  };
  CycleBitsGates.CycleBitsFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("<<" + span).setSymbol("<<<").setTitle("Left Rotate").setBlurb("Rotates bits downward.").setDrawer(cyclePainter(false)).setTooltipMatrixFunc(function() {
      return makeCycleBitsMatrix(1, span);
    }).setActualEffectToShaderProvider(function(ctx) {
      return cycleBitsShader(ctx, span, +1);
    }).setKnownEffectToBitPermutation(function(i) {
      return (i + 1) % span;
    });
  });
  CycleBitsGates.ReverseCycleBitsFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId(">>" + span).setSymbol(">>>").setTitle("Right Rotate").setBlurb("Rotates bits upward.").setDrawer(cyclePainter(true)).setTooltipMatrixFunc(function() {
      return makeCycleBitsMatrix(-1, span);
    }).setActualEffectToShaderProvider(function(ctx) {
      return cycleBitsShader(ctx, span, -1);
    }).setKnownEffectToBitPermutation(function(i) {
      return (i + span - 1) % span;
    });
  });
  CycleBitsGates.all = $traceurRuntime.spread(CycleBitsGates.CycleBitsFamily.all, CycleBitsGates.ReverseCycleBitsFamily.all);
  return {
    get CycleBitsGates() {
      return CycleBitsGates;
    },
    get cycleBitsShader() {
      return cycleBitsShader;
    },
    get makeCycleBitsPermutation() {
      return makeCycleBitsPermutation;
    }
  };
});
//# sourceURL=src/gates/CycleBitsGates.js
;$traceurRuntime.registerModule("src/gates/Debug_ErrorInjectionGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Debug_ErrorInjectionGate.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/gates/Debug_ErrorInjectionGate.js")).DetailedError;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/Debug_ErrorInjectionGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/Debug_ErrorInjectionGate.js")).GatePainting;
  var ErrorInjectionGate = new GateBuilder().setSerializedId("__error__").setSymbol("ERR!").setTitle("Error Injection Gate").setBlurb("Throws an exception during circuit stat computations, for testing error paths.").setDrawer(GatePainting.MAKE_HIGHLIGHTED_DRAWER('red', 'red')).setActualEffectToUpdateFunc(function(ctx) {
    throw new DetailedError("Applied an Error Injection Gate", {qubit: ctx.row});
  }).promiseEffectIsStable().gate;
  return {get ErrorInjectionGate() {
      return ErrorInjectionGate;
    }};
});
//# sourceURL=src/gates/Debug_ErrorInjectionGate.js
;$traceurRuntime.registerModule("src/gates/DensityMatrixDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/DensityMatrixDisplay.js";
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitShaders.js", "src/gates/DensityMatrixDisplay.js")).CircuitShaders;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/DensityMatrixDisplay.js")),
      Gate = $__3.Gate,
      GateBuilder = $__3.GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/DensityMatrixDisplay.js")).GatePainting;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateShaders.js", "src/gates/DensityMatrixDisplay.js")).GateShaders;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/gates/DensityMatrixDisplay.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/DensityMatrixDisplay.js")).Matrix;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/Shaders.js", "src/gates/DensityMatrixDisplay.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/DensityMatrixDisplay.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/DensityMatrixDisplay.js")).WglArg;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/gates/DensityMatrixDisplay.js")).WglConfiguredShader;
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/gates/DensityMatrixDisplay.js")),
      Inputs = $__12.Inputs,
      Outputs = $__12.Outputs,
      currentShaderCoder = $__12.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__12.makePseudoShaderWithInputsAndOutputAndCode;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexturePool.js", "src/gates/DensityMatrixDisplay.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTextureTrader.js", "src/gates/DensityMatrixDisplay.js")).WglTextureTrader;
  function densityDisplayStatTexture(inp, qubitCount, controls, rangeOffset, rangeLength) {
    var trader = new WglTextureTrader(inp);
    trader.dontDeallocCurrentTexture();
    var startingQubits = currentShaderCoder().vec2.arrayPowerSizeOfTexture(inp);
    var lostQubits = Util.numberOfSetBits(controls.inclusionMask);
    var lostHeadQubits = Util.numberOfSetBits(controls.inclusionMask & ((1 << rangeOffset) - 1));
    trader.shadeAndTrade(function(ket) {
      return CircuitShaders.controlSelect(controls, ket);
    }, WglTexturePool.takeVec2Tex(startingQubits - lostQubits));
    trader.shadeAndTrade(function(ket) {
      return GateShaders.cycleAllBits(ket, lostHeadQubits - rangeOffset);
    });
    var n = qubitCount - lostQubits + rangeLength;
    trader.shadeAndTrade(function(e) {
      return amplitudesToCouplings(e, rangeLength);
    }, WglTexturePool.takeVec2Tex(n));
    while (n > 2 * rangeLength) {
      n--;
      trader.shadeHalveAndTrade(Shaders.sumFoldVec2);
    }
    if (currentShaderCoder().vec2.needRearrangingToBeInVec4Format) {
      trader.shadeHalveAndTrade(Shaders.packVec2IntoVec4);
    }
    return trader.currentTexture;
  }
  var amplitudesToCouplings = function(inputTexture, qubitSpan) {
    return AMPLITUDES_TO_DENSITIES_SHADER(inputTexture, WglArg.float('qubitSpan', 1 << qubitSpan));
  };
  var AMPLITUDES_TO_DENSITIES_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), "\n    uniform float qubitSpan;\n\n    vec2 outputFor(float k) {\n        float k_ket = mod(k, qubitSpan);\n        float k_bra = mod(floor(k / qubitSpan), qubitSpan);\n        float k_rest = floor(k / qubitSpan / qubitSpan);\n        float offset = k_rest*qubitSpan;\n\n        vec2 ampKet = read_input(k_ket + offset);\n        vec2 ampBra = read_input(k_bra + offset);\n        float r = dot(ampKet, ampBra);\n        float i = dot(ampKet, vec2(-ampBra.y, ampBra.x));\n\n        return vec2(r, i);\n    }");
  function decohereMeasuredBitsInDensityMatrix(densityMatrix, isMeasuredMask) {
    if (isMeasuredMask === 0) {
      return densityMatrix;
    }
    var buf = new Float32Array(densityMatrix.rawBuffer());
    var n = densityMatrix.width();
    for (var row = 0; row < n; row++) {
      for (var col = 0; col < n; col++) {
        if (((row ^ col) & isMeasuredMask) !== 0) {
          var k = (row * n + col) * 2;
          buf[k] = 0;
          buf[k + 1] = 0;
        }
      }
    }
    return new Matrix(n, n, buf);
  }
  function densityPixelsToMatrix(pixels, circuitDefinition, col, row) {
    var n = pixels.length >> 1;
    var d = Math.round(Math.sqrt(n));
    var unity = 0;
    for (var i = 0; i < d; i++) {
      unity += pixels[2 * i * (d + 1)];
    }
    if (isNaN(unity) || unity < 0.000001) {
      return Matrix.zero(d, d).times(NaN);
    }
    for (var i$__1 = 0; i$__1 < pixels.length; i$__1++) {
      pixels[i$__1] /= unity;
    }
    var isMeasuredMask = circuitDefinition.colIsMeasuredMask(col) >> row;
    return decohereMeasuredBitsInDensityMatrix(new Matrix(d, d, pixels), isMeasuredMask);
  }
  function densityMatrixDisplayMaker_shared(builder) {
    return builder.setSymbol("Density").setTitle("Density Matrix Display").setBlurb("Shows the density matrix of the local mixed state of some wires.\n" + "Use controls to see conditional states.").promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function(args) {
      return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
    });
  }
  function singleDensityMatrixDisplayMaker(builder) {
    return densityMatrixDisplayMaker_shared(builder).setSerializedId("Density").markAsDrawerNeedsSingleQubitDensityStats().setDrawer(GatePainting.makeDisplayDrawer(function(args) {
      var $__0 = args.positionInCircuit,
          col = $__0.col,
          row = $__0.row;
      var ρ = args.stats.qubitDensityMatrix(col, row);
      MathPainter.paintDensityMatrix(args.painter, ρ, args.rect, args.focusPoints);
    }));
  }
  function largeDensityMatrixDisplayMaker(span, builder) {
    return densityMatrixDisplayMaker_shared(builder).setSerializedId("Density" + span).setWidth(span).setDrawer(DENSITY_MATRIX_DRAWER_FROM_CUSTOM_STATS).setStatTexturesMaker(function(ctx) {
      return densityDisplayStatTexture(ctx.stateTrader.currentTexture, ctx.wireCount, ctx.controls, ctx.row, span);
    }).setStatPixelDataPostProcessor(densityPixelsToMatrix);
  }
  var DENSITY_MATRIX_DRAWER_FROM_CUSTOM_STATS = GatePainting.makeDisplayDrawer(function(args) {
    var n = args.gate.height;
    var ρ = args.customStats || Matrix.zero(1 << n, 1 << n).times(NaN);
    MathPainter.paintDensityMatrix(args.painter, ρ, args.rect, args.focusPoints);
  });
  var DensityMatrixDisplayFamily = Gate.buildFamily(1, 8, function(span, builder) {
    return span === 1 ? singleDensityMatrixDisplayMaker(builder) : largeDensityMatrixDisplayMaker(span, builder);
  });
  return {
    get DensityMatrixDisplayFamily() {
      return DensityMatrixDisplayFamily;
    },
    get amplitudesToCouplings() {
      return amplitudesToCouplings;
    }
  };
});
//# sourceURL=src/gates/DensityMatrixDisplay.js
;$traceurRuntime.registerModule("src/gates/Detector.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Detector.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/Detector.js")).GateBuilder;
  var amplitudesToProbabilities = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ProbabilityDisplay.js", "src/gates/Detector.js")).amplitudesToProbabilities;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexturePool.js", "src/gates/Detector.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTextureTrader.js", "src/gates/Detector.js")).WglTextureTrader;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/Shaders.js", "src/gates/Detector.js")).Shaders;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/gates/Detector.js")),
      currentShaderCoder = $__6.currentShaderCoder,
      Inputs = $__6.Inputs;
  var CircuitShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitShaders.js", "src/gates/Detector.js")).CircuitShaders;
  var Controls = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Controls.js", "src/gates/Detector.js")).Controls;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/Detector.js")).WglArg;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/Detector.js")).Config;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/Detector.js")).GatePainting;
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/gates/Detector.js")),
      makePseudoShaderWithInputsAndOutputAndCode = $__12.makePseudoShaderWithInputsAndOutputAndCode,
      Outputs = $__12.Outputs;
  function controlMaskTex(ctx, controls) {
    var powerSize = currentShaderCoder().vec2.arrayPowerSizeOfTexture(ctx.stateTrader.currentTexture);
    return CircuitShaders.controlMask(controls).toBoolTexture(powerSize);
  }
  function textureWithTotalWeightMatchingGivenControls(ketTexture, controlMaskTex) {
    var forStats = arguments[2] !== (void 0) ? arguments[2] : false;
    var powerSize = currentShaderCoder().vec2.arrayPowerSizeOfTexture(ketTexture);
    var trader = new WglTextureTrader(ketTexture);
    trader.dontDeallocCurrentTexture();
    trader.shadeAndTrade(function(tex) {
      return amplitudesToProbabilities(tex, controlMaskTex);
    }, WglTexturePool.takeVecFloatTex(powerSize));
    var n = currentShaderCoder().vec2.arrayPowerSizeOfTexture(ketTexture);
    while (n > 0) {
      n -= 1;
      trader.shadeHalveAndTrade(Shaders.sumFoldFloat);
    }
    trader.shadeAndTrade(Shaders.packFloatIntoVec4, WglTexturePool.takeVec4Tex(0));
    return trader.currentTexture;
  }
  function detectorStatTexture(ctx) {
    var mask = controlMaskTex(ctx, ctx.controls.and(Controls.bit(ctx.row, true)));
    try {
      return textureWithTotalWeightMatchingGivenControls(ctx.stateTrader.currentTexture, mask, true);
    } finally {
      mask.deallocByDepositingInPool('textureWithTotalWeightMatchingPositiveMeasurement:mask');
    }
  }
  var detectorShader = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('total_weight'), Inputs.float('detection_weight'), Inputs.bool('classification'), Inputs.vec2('ket')], Outputs.vec2(), "\n        uniform float rnd;\n    \n        vec2 outputFor(float k) {\n            float detectChance = read_detection_weight(0.0) / read_total_weight(0.0);\n            float detection_type = float(rnd < detectChance);\n            float own_type = read_classification(k);\n            return read_ket(k) * float(detection_type == own_type);\n        }\n    ");
  function sampleMeasure(ctx) {
    var maskAll = controlMaskTex(ctx, Controls.NONE);
    var maskMatch = controlMaskTex(ctx, ctx.controls.and(Controls.bit(ctx.row, true)));
    var weightAll = textureWithTotalWeightMatchingGivenControls(ctx.stateTrader.currentTexture, maskAll);
    var weightMatch = textureWithTotalWeightMatchingGivenControls(ctx.stateTrader.currentTexture, maskMatch);
    ctx.applyOperation(detectorShader(weightAll, weightMatch, maskMatch, ctx.stateTrader.currentTexture, WglArg.float('rnd', Math.random())));
    weightMatch.deallocByDepositingInPool();
    weightAll.deallocByDepositingInPool();
    maskMatch.deallocByDepositingInPool();
    maskAll.deallocByDepositingInPool();
  }
  function drawDetector(args) {
    if (args.isHighlighted || args.isInToolbox) {
      args.painter.fillRect(args.rect, args.isHighlighted ? Config.HIGHLIGHTED_GATE_FILL_COLOR : Config.TIME_DEPENDENT_HIGHLIGHT_COLOR);
      GatePainting.paintOutline(args);
    }
    var τ = Math.PI * 2;
    var r = args.rect.w * 0.4;
    var $__0 = args.rect.center(),
        x = $__0.x,
        y = $__0.y;
    x -= r * 0.5;
    x += 0.5;
    y += 0.5;
    args.painter.trace(function(trace) {
      trace.ctx.arc(x, y, r, τ * 3 / 4, τ / 4);
      trace.ctx.lineTo(x, y - r - 1);
    }).thenStroke('black', 2).thenFill(Config.TIME_DEPENDENT_HIGHLIGHT_COLOR);
    var clicked = args.customStats;
    if (clicked) {
      args.painter.ctx.save();
      args.painter.ctx.translate(args.rect.center().x, args.rect.center().y);
      args.painter.ctx.rotate(τ / 8);
      args.painter.ctx.strokeStyle = 'white';
      args.painter.ctx.lineWidth = 2;
      args.painter.print('*click*', 0, 0, 'center', 'middle', 'black', 'bold 16px sans-serif', args.rect.w * 1.4, args.rect.h * 1.4, undefined, true);
      args.painter.ctx.restore();
    }
  }
  var Detector = new GateBuilder().setSerializedIdAndSymbol('Detector').setTitle('Detector').setBlurb('Makes a *click* when the target qubit is ON and all controls are satisfied.\n' + 'Measures whether to click, samples the result, then post-selects on it.').setDrawer(drawDetector).promiseEffectIsDiagonal().markAsReachingOtherWires().setActualEffectToUpdateFunc(sampleMeasure).setStatTexturesMaker(detectorStatTexture).setStatPixelDataPostProcessor(function(pixels, circuit, row, col) {
    return pixels[0] > 0;
  }).gate;
  return {get Detector() {
      return Detector;
    }};
});
//# sourceURL=src/gates/Detector.js
;$traceurRuntime.registerModule("src/gates/ExponentiatingGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ExponentiatingGates.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ExponentiatingGates.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/ExponentiatingGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/ExponentiatingGates.js")).Matrix;
  var ExponentiatingGates = {};
  var τ = Math.PI * 2;
  var XExp = function(t) {
    var c = Math.cos(τ * t);
    var s = Math.sin(τ * t);
    return new Matrix(2, 2, new Float32Array([c, 0, 0, -s, 0, -s, c, 0]));
  };
  var YExp = function(t) {
    var c = Math.cos(τ * t);
    var s = Math.sin(τ * t);
    return new Matrix(2, 2, new Float32Array([c, 0, -s, 0, s, 0, c, 0]));
  };
  var ZExp = function(t) {
    var c = Math.cos(τ * t);
    var s = Math.sin(τ * t);
    return new Matrix(2, 2, new Float32Array([c, -s, 0, 0, 0, 0, c, s]));
  };
  ExponentiatingGates.XForward = new GateBuilder().setSerializedIdAndSymbol("e^-iXt").setTitle("X-Exponentiating Gate (forward)").setBlurb("Right-hand rotation around the X axis.\nPasses through ±iX instead of X.").setDrawer(GatePainting.makeCycleDrawer(1, 1, 2)).setEffectToTimeVaryingMatrix(XExp).promiseEffectIsUnitary().gate;
  ExponentiatingGates.XBackward = new GateBuilder().setSerializedIdAndSymbol("e^iXt").setTitle("X-Exponentiating Gate (backward)").setBlurb("Left-hand rotation around the X axis.\nPasses through ±iX instead of X.").setDrawer(GatePainting.makeCycleDrawer(-1, 1, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return XExp(-t);
  }).promiseEffectIsUnitary().gate;
  ExponentiatingGates.YForward = new GateBuilder().setSerializedIdAndSymbol("e^-iYt").setTitle("Y-Exponentiating Gate (forward)").setBlurb("Right-hand rotation around the Y axis.\nPasses through ±iY instead of Y.").setDrawer(GatePainting.makeCycleDrawer(0.5, 1, 2)).setEffectToTimeVaryingMatrix(YExp).promiseEffectIsUnitary().gate;
  ExponentiatingGates.YBackward = new GateBuilder().setSerializedIdAndSymbol("e^iYt").setTitle("Y-Exponentiating Gate (backward)").setBlurb("Left-hand rotation around the Y axis.\nPasses through ±iY instead of Y.").setDrawer(GatePainting.makeCycleDrawer(-0.5, 1, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return YExp(-t);
  }).promiseEffectIsUnitary().gate;
  ExponentiatingGates.ZForward = new GateBuilder().setSerializedIdAndSymbol("e^-iZt").setTitle("Z-Exponentiating Gate (forward)").setBlurb("Right-hand rotation around the Z axis.\nPasses through ±iZ instead of Z.").setDrawer(GatePainting.makeCycleDrawer(-1, -0.5, 2)).setEffectToTimeVaryingMatrix(ZExp).promiseEffectOnlyPhases().gate;
  ExponentiatingGates.ZBackward = new GateBuilder().setSerializedIdAndSymbol("e^iZt").setTitle("Z-Exponentiating Gate (backward)").setBlurb("Left-hand rotation around the Z axis.\nPasses through ±iZ instead of Z.").setDrawer(GatePainting.makeCycleDrawer(1, -0.5, 2)).setEffectToTimeVaryingMatrix(function(t) {
    return ZExp(-t);
  }).promiseEffectOnlyPhases().gate;
  ExponentiatingGates.all = [ExponentiatingGates.XBackward, ExponentiatingGates.YBackward, ExponentiatingGates.ZBackward, ExponentiatingGates.XForward, ExponentiatingGates.YForward, ExponentiatingGates.ZForward];
  return {get ExponentiatingGates() {
      return ExponentiatingGates;
    }};
});
//# sourceURL=src/gates/ExponentiatingGates.js
;$traceurRuntime.registerModule("src/gates/FourierTransformGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/FourierTransformGates.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/gates/FourierTransformGates.js")).Complex;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/FourierTransformGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/FourierTransformGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPhase = $__4.ketShaderPhase;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/FourierTransformGates.js")).Matrix;
  var HalfTurnGates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/HalfTurnGates.js", "src/gates/FourierTransformGates.js")).HalfTurnGates;
  var reverseShaderForSize = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ReverseBitsGate.js", "src/gates/FourierTransformGates.js")).reverseShaderForSize;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/FourierTransformGates.js")).WglArg;
  function applyControlledPhaseGradient(ctx, qubitSpan) {
    var $__1;
    var factor = arguments[2] !== (void 0) ? arguments[2] : 1;
    ctx.applyOperation(($__1 = CONTROLLED_PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, qubitSpan), [WglArg.float("factor", factor)])));
  }
  var CONTROLLED_PHASE_GRADIENT_SHADER = ketShaderPhase('uniform float factor;', "\n        float hold = floor(out_id * 2.0 / span);\n        float step = mod(out_id, span / 2.0);\n        return hold * step * factor * 6.2831853071795864769 / span;\n    ");
  var FOURIER_TRANSFORM_MATRIX_MAKER = function(span) {
    return Matrix.generate(1 << span, 1 << span, function(r, c) {
      return Complex.polar(Math.pow(0.5, span / 2), Math.PI * 2 * r * c / (1 << span));
    });
  };
  var INVERSE_FOURIER_TRANSFORM_MATRIX_MAKER = function(span) {
    return FOURIER_TRANSFORM_MATRIX_MAKER(span).adjoint();
  };
  var FourierTransformGates = {};
  function applyForwardGradientShaders(ctx, span) {
    if (span > 1) {
      ctx.applyOperation(reverseShaderForSize(span));
    }
    for (var i = 0; i < span; i++) {
      if (i > 0) {
        applyControlledPhaseGradient(ctx, i + 1, +1);
      }
      HalfTurnGates.H.customOperation(ctx.withRow(ctx.row + i));
    }
  }
  function applyBackwardGradientShaders(ctx, span) {
    for (var i = span - 1; i >= 0; i--) {
      HalfTurnGates.H.customOperation(ctx.withRow(ctx.row + i));
      if (i > 0) {
        applyControlledPhaseGradient(ctx, i + 1, -1);
      }
    }
    if (span > 1) {
      ctx.applyOperation(reverseShaderForSize(span));
    }
  }
  FourierTransformGates.FourierTransformFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("QFT" + span).setSymbol("QFT").setTitle("Fourier Transform Gate").setBlurb("Transforms to/from phase frequency space.").setActualEffectToUpdateFunc(function(ctx) {
      return applyForwardGradientShaders(ctx, span);
    }).promiseEffectIsUnitary().setTooltipMatrixFunc(function() {
      return FOURIER_TRANSFORM_MATRIX_MAKER(span);
    });
  });
  FourierTransformGates.InverseFourierTransformFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("QFT†" + span).setSymbol("QFT^†").setTitle("Inverse Fourier Transform Gate").setBlurb("Transforms from/to phase frequency space.").setActualEffectToUpdateFunc(function(ctx) {
      return applyBackwardGradientShaders(ctx, span);
    }).promiseEffectIsUnitary().setTooltipMatrixFunc(function() {
      return INVERSE_FOURIER_TRANSFORM_MATRIX_MAKER(span);
    });
  });
  FourierTransformGates.all = $traceurRuntime.spread(FourierTransformGates.FourierTransformFamily.all, FourierTransformGates.InverseFourierTransformFamily.all);
  return {
    get applyControlledPhaseGradient() {
      return applyControlledPhaseGradient;
    },
    get FourierTransformGates() {
      return FourierTransformGates;
    }
  };
});
//# sourceURL=src/gates/FourierTransformGates.js
;$traceurRuntime.registerModule("src/gates/HalfTurnGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/HalfTurnGates.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/HalfTurnGates.js")),
      Gate = $__2.Gate,
      GateBuilder = $__2.GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/HalfTurnGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/HalfTurnGates.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/HalfTurnGates.js")).Point;
  var $__6 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/HalfTurnGates.js")),
      ketArgs = $__6.ketArgs,
      ketShader = $__6.ketShader,
      ketShaderPermute = $__6.ketShaderPermute;
  var HalfTurnGates = {};
  function NOT_DRAWER(args) {
    if (args.isHighlighted) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    if (args.positionInCircuit === undefined) {
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
    }
    var drawArea = args.rect.scaledOutwardBy(0.6);
    args.painter.fillCircle(drawArea.center(), drawArea.w / 2);
    args.painter.strokeCircle(drawArea.center(), drawArea.w / 2);
    var hasSingleWireControl = args.positionInCircuit !== undefined && args.stats.circuitDefinition.colHasSingleWireControl(args.positionInCircuit.col);
    var hasDoubleWireControl = args.positionInCircuit !== undefined && args.stats.circuitDefinition.colHasDoubleWireControl(args.positionInCircuit.col);
    if (hasSingleWireControl || !hasDoubleWireControl) {
      args.painter.strokeLine(drawArea.topCenter(), drawArea.bottomCenter());
    }
    if (hasDoubleWireControl) {
      args.painter.strokeLine(drawArea.topCenter().offsetBy(-1, 0), drawArea.bottomCenter().offsetBy(-1, 0));
      args.painter.strokeLine(drawArea.topCenter().offsetBy(+1, 0), drawArea.bottomCenter().offsetBy(+1, 0));
    }
    var isMeasured = args.positionInCircuit !== undefined && args.stats.circuitDefinition.locIsMeasured(new Point(args.positionInCircuit.col, args.positionInCircuit.row));
    if (isMeasured) {
      args.painter.strokeLine(drawArea.centerLeft().offsetBy(0, -1), drawArea.centerRight().offsetBy(0, -1));
      args.painter.strokeLine(drawArea.centerLeft().offsetBy(0, +1), drawArea.centerRight().offsetBy(0, +1));
    } else {
      args.painter.strokeLine(drawArea.centerLeft(), drawArea.centerRight());
    }
  }
  var xShader = ketShaderPermute('', 'return 1.0-out_id;', 1);
  HalfTurnGates.X = new GateBuilder().setSerializedIdAndSymbol("X").setTitle("Pauli X Gate").setBlurb("The NOT gate.\nToggles between ON and OFF.").setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = xShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx)));
  }).setKnownEffectToMatrix(Matrix.PAULI_X).gate;
  var yShader = ketShader('', 'vec2 v = inp(1.0-out_id); return (out_id*2.0 - 1.0)*vec2(-v.y, v.x);', 1);
  HalfTurnGates.Y = new GateBuilder().setSerializedIdAndSymbol("Y").setTitle("Pauli Y Gate").setBlurb("A combination of the X and Z gates.").setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = yShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx)));
  }).setKnownEffectToMatrix(Matrix.PAULI_Y).gate;
  var zShader = ketShader('', 'return amp*(1.0 - out_id*2.0);', 1);
  HalfTurnGates.Z = new GateBuilder().setSerializedIdAndSymbol("Z").setTitle("Pauli Z Gate").setBlurb("The phase flip gate.\nNegates phases when the qubit is ON.").setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = zShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx)));
  }).setKnownEffectToMatrix(Matrix.PAULI_Z).gate;
  var hShader = ketShader('', 'return 0.7071067811865476*(amp*(1.0-2.0*out_id) + inp(1.0-out_id));', 1);
  HalfTurnGates.H = new GateBuilder().setSerializedIdAndSymbol("H").setTitle("Hadamard Gate").setBlurb("Creates simple superpositions.\n" + "Maps ON to ON + OFF.\n" + "Maps OFF to ON - OFF.").setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = hShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx)));
  }).setKnownEffectToMatrix(Matrix.HADAMARD).gate;
  HalfTurnGates.all = [HalfTurnGates.X, HalfTurnGates.Y, HalfTurnGates.Z, HalfTurnGates.H];
  return {get HalfTurnGates() {
      return HalfTurnGates;
    }};
});
//# sourceURL=src/gates/HalfTurnGates.js
;$traceurRuntime.registerModule("src/gates/Impossible_UniversalNotGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Impossible_UniversalNotGate.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/Impossible_UniversalNotGate.js")).GateBuilder;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/Impossible_UniversalNotGate.js")),
      ketArgs = $__2.ketArgs,
      ketShader = $__2.ketShader;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/gates/Impossible_UniversalNotGate.js")).WglConfiguredShader;
  var universalNot = function(ctx) {
    var $__0;
    return ($__0 = UNIVERSAL_NOT_SHADER).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx)));
  };
  var UNIVERSAL_NOT_SHADER = ketShader('', 'vec2 other = inp(1.0 - out_id); return vec2(other.x, -other.y) * (1.0 - 2.0 * out_id);', 1);
  var UniversalNotGate = new GateBuilder().setSerializedId("__unstable__UniversalNot").setSymbol("UniNot").setTitle("Universal Not Gate").setBlurb("Mirrors through the origin of the Bloch sphere.\nImpossible in practice.").setActualEffectToShaderProvider(universalNot).promiseEffectIsStable().gate;
  return {
    get universalNot() {
      return universalNot;
    },
    get UniversalNotGate() {
      return UniversalNotGate;
    }
  };
});
//# sourceURL=src/gates/Impossible_UniversalNotGate.js
;$traceurRuntime.registerModule("src/gates/IncrementGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/IncrementGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/IncrementGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/IncrementGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/IncrementGates.js")).WglArg;
  var IncrementGates = {};
  var offsetShader = ketShaderPermute('uniform float amount;', 'return mod(out_id - amount + span, span);');
  IncrementGates.IncrementFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("inc" + span).setSymbol("+1").setTitle("Increment Gate").setBlurb("Adds 1 to the little-endian number represented by a block of qubits.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = offsetShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("amount", +1)]));
    }).setKnownEffectToPermutation(function(t) {
      return (t + 1) & ((1 << span) - 1);
    });
  });
  IncrementGates.DecrementFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("dec" + span).setSymbol("−1").setTitle("Decrement Gate").setBlurb("Subtracts 1 from the little-endian number represented by a block of qubits.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = offsetShader).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("amount", -1)]));
    }).setKnownEffectToPermutation(function(t) {
      return (t - 1) & ((1 << span) - 1);
    });
  });
  IncrementGates.all = $traceurRuntime.spread(IncrementGates.IncrementFamily.all, IncrementGates.DecrementFamily.all);
  return {
    get IncrementGates() {
      return IncrementGates;
    },
    get offsetShader() {
      return offsetShader;
    }
  };
});
//# sourceURL=src/gates/IncrementGates.js
;$traceurRuntime.registerModule("src/gates/InputGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/InputGates.js";
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/InputGates.js")),
      Gate = $__3.Gate,
      GateBuilder = $__3.GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/InputGates.js")).GatePainting;
  var reverseShaderForSize = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ReverseBitsGate.js", "src/gates/InputGates.js")).reverseShaderForSize;
  var InputGates = {};
  function drawInputGate(args, key, reverse) {
    GatePainting.paintBackground(args, '#DDD', '#DDD');
    if (args.isInToolbox) {
      GatePainting.paintOutline(args);
    } else {
      args.painter.strokeRect(args.rect, '#888');
    }
    GatePainting.paintResizeTab(args);
    var $__2 = args.rect.center(),
        x = $__2.x,
        y = $__2.y;
    args.painter.print('input', x, y - 2, 'center', 'bottom', 'black', '16px sans-serif', args.rect.w - 2, args.rect.h / 2);
    args.painter.print(key + (reverse ? '[::-1]' : ''), x, y + 2, 'center', 'top', 'black', '16px sans-serif', args.rect.w - 2, args.rect.h / 2);
  }
  var makeInputGate = function(key, reverse) {
    return Gate.buildFamily(1, 16, function(span, builder) {
      return builder.setSerializedId((reverse ? 'rev' : '') + ("input" + key + span)).setSymbol((reverse ? 'rev ' : '') + ("input " + key)).setTitle(("Input Gate [" + key + "]") + (reverse ? ' [reversed]' : '')).setBlurb(("Temporarily uses some qubits as input " + key + (reverse ? ', in big-endian order' : '') + ".")).setDrawer(function(args) {
        return drawInputGate(args, key, reverse);
      }).promiseHasNoNetEffectOnStateVector().markAsNotInterestedInControls().setSetupCleanupEffectsToShaderProviders(reverse && span > 1 ? reverseShaderForSize(span) : undefined, reverse && span > 1 ? reverseShaderForSize(span) : undefined).setContextProvider(function(qubitIndex) {
        return [{
          key: ("Input Range " + key),
          val: {
            offset: qubitIndex,
            length: span
          }
        }];
      });
    });
  };
  var makeSetInputGate = function(key) {
    return new GateBuilder().setSerializedIdAndSymbol(("set" + key)).setTitle(("Set Default " + key)).setBlurb(("Sets a default value for input " + key + ", for when an inline input isn't given.")).setWidth(2).setHeight(2).promiseHasNoNetEffectOnStateVector().markAsNotInterestedInControls().markAsReachingOtherWires().setStickyContextProvider(function(qubitIndex, gate) {
      return [{
        key: ("Input Default " + key),
        val: gate.param,
        sticky: true
      }];
    }).setDrawer(function(args) {
      GatePainting.paintLocationIndependentFrame(args, '#EEE', '#EEE');
      if (args.isInToolbox) {
        GatePainting.paintGateSymbol(args, (key + "=#\ndefault"));
      } else {
        GatePainting.paintGateSymbol(args, (key + "=" + args.gate.param));
      }
      GatePainting.paintGateButton(args);
    }).setOnClickGateFunc(function(oldGate) {
      var txt = prompt(("Enter new fallback value for input " + key + " (between 0 and 65535)."), '' + oldGate.param);
      if (txt === null || txt.trim() === '') {
        return oldGate;
      }
      var val = parseInt(txt);
      if (!Number.isInteger(val) || val < 0 || val >= 1 << 16) {
        alert(("'" + txt + "' isn't an integer between 0 and 65535. Keeping " + oldGate.param + "."));
        return oldGate;
      }
      return oldGate.withParam(val);
    }).gate.withParam(2);
  };
  InputGates.InputAFamily = makeInputGate('A', false);
  InputGates.InputBFamily = makeInputGate('B', false);
  InputGates.InputRFamily = makeInputGate('R', false);
  InputGates.InputRevAFamily = makeInputGate('A', true);
  InputGates.InputRevBFamily = makeInputGate('B', true);
  InputGates.SetA = makeSetInputGate('A');
  InputGates.SetB = makeSetInputGate('B');
  InputGates.SetR = makeSetInputGate('R');
  InputGates.Letters = ["A", "B", "R"];
  InputGates.all = $traceurRuntime.spread(InputGates.InputAFamily.all, InputGates.InputBFamily.all, InputGates.InputRFamily.all, InputGates.InputRevAFamily.all, InputGates.InputRevBFamily.all, [InputGates.SetA, InputGates.SetB, InputGates.SetR]);
  return {get InputGates() {
      return InputGates;
    }};
});
//# sourceURL=src/gates/InputGates.js
;$traceurRuntime.registerModule("src/gates/InterleaveBitsGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/InterleaveBitsGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/InterleaveBitsGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/InterleaveBitsGates.js")).Gate;
  var $__7 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/InterleaveBitsGates.js")),
      ketArgs = $__7.ketArgs,
      ketShaderPermute = $__7.ketShaderPermute;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/InterleaveBitsGates.js")).GatePainting;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/InterleaveBitsGates.js")).Point;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/gates/InterleaveBitsGates.js")).Seq;
  var InterleaveBitsGates = {};
  function interleaveBit(bit, len) {
    var h = Math.ceil(len / 2);
    var group = Math.floor(bit / h);
    var stride = bit % h;
    return stride * 2 + group;
  }
  function deinterleaveBit(bit, len) {
    var h = Math.ceil(len / 2);
    var stride = Math.floor(bit / 2);
    var group = bit % 2;
    return stride + group * h;
  }
  function shaderFromBitPermutation(span, bitPermutation) {
    var bitMoveLines = [];
    for (var i = 0; i < span; i++) {
      bitMoveLines.push(("r += mod(floor(out_id / " + (1 << bitPermutation(i, span)) + ".0), 2.0) * " + (1 << i) + ".0;"));
    }
    return ketShaderPermute('', ("\n            float r = 0.0;\n            " + bitMoveLines.join("\n            ") + "\n            return r;\n        "), span);
  }
  var _interleaveShadersForSize = Seq.range(Config.MAX_WIRE_COUNT + 1).skip(2).toMap(function(k) {
    return k;
  }, function(k) {
    return shaderFromBitPermutation(k, interleaveBit);
  });
  var _deinterleaveShadersForSize = Seq.range(Config.MAX_WIRE_COUNT + 1).skip(2).toMap(function(k) {
    return k;
  }, function(k) {
    return shaderFromBitPermutation(k, deinterleaveBit);
  });
  var interleavePainter = function(reverse) {
    return function(args) {
      var $__2,
          $__3;
      if (args.positionInCircuit !== undefined) {
        GatePainting.PERMUTATION_DRAWER(args);
        return;
      }
      GatePainting.paintBackground(args);
      GatePainting.paintOutline(args);
      GatePainting.paintResizeTab(args);
      var x1 = args.rect.x + 6;
      var x2 = args.rect.right() - 6;
      var y = args.rect.center().y - Config.GATE_RADIUS + 6;
      var dh = ((Config.GATE_RADIUS - 6) * 2 - 14) / 5;
      for (var i = 0; i < 6; i++) {
        var j = interleaveBit(i, 6);
        var yi = y + i * dh + Math.floor(i / 3) * 14;
        var yj = y + j * dh + Math.floor(j / 2) * 7;
        var $__1 = reverse ? [yj, yi] : [yi, yj],
            y1 = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
            y2 = ($__3 = $__2.next()).done ? void 0 : $__3.value;
        args.painter.strokePath([new Point(x1, y1), new Point(x1 + 8, y1), new Point(x2 - 8, y2), new Point(x2, y2)]);
      }
    };
  };
  InterleaveBitsGates.InterleaveBitsGateFamily = Gate.buildFamily(4, 16, function(span, builder) {
    return builder.setSerializedId("weave" + span).setSymbol("Interleave").setTitle("Interleave").setBlurb("Re-orders blocks of bits into stripes of bits.").setWidth(span <= 8 ? 1 : 2).setDrawer(interleavePainter(false)).setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = _interleaveShadersForSize.get(span)).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span)));
    }).setKnownEffectToBitPermutation(function(b) {
      return interleaveBit(b, span);
    });
  });
  InterleaveBitsGates.DeinterleaveBitsGateFamily = Gate.buildFamily(4, 16, function(span, builder) {
    return builder.setSerializedId("split" + span).setSymbol("Deinterleave").setTitle("Deinterleave").setBlurb("Re-orders stripes of bits into blocks of bits.").setWidth(span <= 8 ? 1 : 2).setDrawer(interleavePainter(true)).setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = _deinterleaveShadersForSize.get(span)).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span)));
    }).setKnownEffectToBitPermutation(function(b) {
      return deinterleaveBit(b, span);
    });
  });
  InterleaveBitsGates.all = $traceurRuntime.spread(InterleaveBitsGates.InterleaveBitsGateFamily.all, InterleaveBitsGates.DeinterleaveBitsGateFamily.all);
  return {
    get InterleaveBitsGates() {
      return InterleaveBitsGates;
    },
    get interleaveBit() {
      return interleaveBit;
    },
    get deinterleaveBit() {
      return deinterleaveBit;
    },
    get shaderFromBitPermutation() {
      return shaderFromBitPermutation;
    }
  };
});
//# sourceURL=src/gates/InterleaveBitsGates.js
;$traceurRuntime.registerModule("src/gates/Joke_MysteryGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Joke_MysteryGate.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/gates/Joke_MysteryGate.js")).Complex;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/Joke_MysteryGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/Joke_MysteryGate.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/Joke_MysteryGate.js")).Matrix;
  var MysteryGateSymbol = "?";
  var MysteryGateMakerWithMatrix = function(matrix) {
    return new GateBuilder().setSerializedIdAndSymbol(MysteryGateSymbol).setTitle("Mystery Gate").setBlurb("Different every time.\n(Use shift+drag to copy circuit gates.)").setDrawer(GatePainting.MATRIX_SYMBOL_DRAWER_EXCEPT_IN_TOOLBOX).setKnownEffectToMatrix(matrix).gate;
  };
  var MysteryGateMaker = function() {
    return MysteryGateMakerWithMatrix(Matrix.square(new Complex(Math.random() - 0.5, Math.random() - 0.5), new Complex(Math.random() - 0.5, Math.random() - 0.5), new Complex(Math.random() - 0.5, Math.random() - 0.5), new Complex(Math.random() - 0.5, Math.random() - 0.5)).closestUnitary(0.00001));
  };
  return {
    get MysteryGateSymbol() {
      return MysteryGateSymbol;
    },
    get MysteryGateMaker() {
      return MysteryGateMaker;
    },
    get MysteryGateMakerWithMatrix() {
      return MysteryGateMakerWithMatrix;
    }
  };
});
//# sourceURL=src/gates/Joke_MysteryGate.js
;$traceurRuntime.registerModule("src/gates/Joke_NeGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Joke_NeGate.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/Joke_NeGate.js")).GateBuilder;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/Joke_NeGate.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/Joke_NeGate.js")).Point;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/Joke_NeGate.js")).GatePainting;
  var NeGate = new GateBuilder().setSerializedId("NeGate").setTitle("Ne-Gate").setBlurb("Negates all amplitudes.").setDrawer(function(args) {
    GatePainting.paintLocationIndependentFrame(args);
    var $__0 = args.rect.center(),
        x = $__0.x,
        y = $__0.y;
    args.painter.strokeLine(new Point(x - 6, y), new Point(x + 6, y), 'black', 2);
  }).setKnownEffectToMatrix(Matrix.square(-1, 0, 0, -1)).gate;
  return {get NeGate() {
      return NeGate;
    }};
});
//# sourceURL=src/gates/Joke_NeGate.js
;$traceurRuntime.registerModule("src/gates/Joke_ZeroGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/Joke_ZeroGate.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/Joke_ZeroGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/Joke_ZeroGate.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/Joke_ZeroGate.js")).Matrix;
  var ZeroGate = new GateBuilder().setSerializedIdAndSymbol("0").setTitle("Zero Gate").setBlurb("Destroys the universe.").setDrawer(GatePainting.makeLocationIndependentGateDrawer('#666')).setKnownEffectToMatrix(Matrix.square(0, 0, 0, 0)).gate;
  return {get ZeroGate() {
      return ZeroGate;
    }};
});
//# sourceURL=src/gates/Joke_ZeroGate.js
;$traceurRuntime.registerModule("src/gates/MeasurementGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/MeasurementGate.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/MeasurementGate.js")).Config;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/MeasurementGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/MeasurementGate.js")).GatePainting;
  function drawMeasurementGate(args) {
    var $__2,
        $__3,
        $__5,
        $__6;
    var backColor = Config.GATE_FILL_COLOR;
    if (args.isHighlighted) {
      backColor = Config.HIGHLIGHTED_GATE_FILL_COLOR;
    }
    args.painter.fillRect(args.rect, backColor);
    GatePainting.paintOutline(args);
    var τ = Math.PI * 2;
    var r = args.rect.w * 0.4;
    var $__0 = args.rect.center(),
        x = $__0.x,
        y = $__0.y;
    y += r * 0.6;
    var a = -τ / 6;
    var $__1 = [Math.cos(a) * r * 1.5, Math.sin(a) * r * 1.5],
        c = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
        s = ($__3 = $__2.next()).done ? void 0 : $__3.value;
    var $__4 = [x + c, y + s],
        p = ($__5 = $__4[Symbol.iterator](), ($__6 = $__5.next()).done ? void 0 : $__6.value),
        q = ($__6 = $__5.next()).done ? void 0 : $__6.value;
    args.painter.trace(function(trace) {
      trace.ctx.arc(x, y, r, τ / 2, τ);
      trace.line(x, y, p, q);
    }).thenStroke('black');
    args.painter.trace(function(trace) {
      return trace.arrowHead(p, q, r * 0.3, a, τ / 4);
    }).thenFill('black');
  }
  var MeasurementGate = new GateBuilder().setSerializedIdAndSymbol("Measure").setTitle("Measurement Gate").setBlurb("Measures whether a qubit is ON or OFF, without conditioning on the result.").promiseHasNoNetEffectOnStateVector().setDrawer(drawMeasurementGate).setExtraDisableReasonFinder(function(args) {
    if (args.isNested) {
      return "can't\nnest\nmeasure\n(sorry)";
    }
    var isMeasured = (args.measuredMask & (1 << args.outerRow)) !== 0;
    if (args.innerColumn.hasControl() && !isMeasured) {
      return "can't\ncontrol\n(sorry)";
    }
    return undefined;
  }).gate;
  return {get MeasurementGate() {
      return MeasurementGate;
    }};
});
//# sourceURL=src/gates/MeasurementGate.js
;$traceurRuntime.registerModule("src/gates/ModularAdditionGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ModularAdditionGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ModularAdditionGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/ModularAdditionGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/ModularAdditionGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/ModularAdditionGates.js")).WglArg;
  var modulusTooBigChecker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularIncrementGates.js", "src/gates/ModularAdditionGates.js")).modulusTooBigChecker;
  var ModularAdditionGates = {};
  var MODULAR_ADDITION_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('R') + "\n    "), "\n        float r = read_input_R();\n        if (out_id >= r) {\n            return out_id;\n        }\n        float d = read_input_A();\n        d *= factor;\n        d = mod(d, r);\n        float result = mod(out_id + r - d, r);\n\n        // Despite sanity, I consistently get result=33 instead of result=0 when out_id=0, d=0, r=33.\n        // HACK: Fix it by hand.\n        if (result >= r) {\n            result -= r;\n        }\n\n        return result;\n    ");
  ModularAdditionGates.PlusAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+AmodR" + span).setSymbol("+A\nmod R").setTitle("Modular Addition Gate").setBlurb("Adds input A into the target, mod input R.\nOnly affects values below R.").setRequiredContextKeys("Input Range A", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_ADDITION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'R']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, r) {
      return t < r ? (t + a) % r : t;
    });
  });
  ModularAdditionGates.MinusAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("-AmodR" + span).setSymbol("−A\nmod R").setTitle("Modular Subtraction Gate").setBlurb("Subtracts input A out of the target, mod input R.\nOnly affects values below R.").setRequiredContextKeys("Input Range A", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_ADDITION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'R']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, r) {
      return t < r ? Util.properMod(t - a, r) : t;
    });
  });
  ModularAdditionGates.all = $traceurRuntime.spread(ModularAdditionGates.PlusAModRFamily.all, ModularAdditionGates.MinusAModRFamily.all);
  return {get ModularAdditionGates() {
      return ModularAdditionGates;
    }};
});
//# sourceURL=src/gates/ModularAdditionGates.js
;$traceurRuntime.registerModule("src/gates/ModularIncrementGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ModularIncrementGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ModularIncrementGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/ModularIncrementGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/ModularIncrementGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/ModularIncrementGates.js")).WglArg;
  var ModularIncrementGates = {};
  var modulusTooBigChecker = function(inputKey, span) {
    var modName = arguments[2] !== (void 0) ? arguments[2] : 'mod';
    return function(args) {
      var r = args.context.get('Input Range ' + inputKey);
      var d = args.context.get('Input Default ' + inputKey);
      if (r !== undefined && r.length > span) {
        return (modName + "\ntoo\nbig");
      }
      if (r === undefined && d !== undefined && d > 1 << span) {
        return (modName + "\ntoo\nbig");
      }
      return undefined;
    };
  };
  var MODULAR_INCREMENT_SHADER = ketShaderPermute(("\n        uniform float amount;\n        " + ketInputGateShaderCode('R') + "\n    "), "\n        float r = read_input_R();\n        return out_id >= r\n            ? out_id\n            // HACK: sometimes mod(value-equal-to-r, r) returns r instead of 0. The perturbation works around it.\n            : floor(mod(out_id + r - amount, r - 0.000001));");
  ModularIncrementGates.IncrementModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("incmodR" + span).setSymbol("+1\nmod R").setTitle("Modular Increment Gate").setBlurb("Adds 1 into the target, but wraps R-1 to 0.\n" + "Only affects values less than R.").setRequiredContextKeys("Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_INCREMENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['R']), [WglArg.float("amount", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return t < a ? (t + 1) % a : t;
    });
  });
  ModularIncrementGates.DecrementModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("decmodR" + span).setSymbol("−1\nmod R").setTitle("Modular Decrement Gate").setBlurb("Subtracts 1 out of the target, but wraps 0 to R-1.\n" + "Only affects values less than R.").setRequiredContextKeys("Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_INCREMENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['R']), [WglArg.float("amount", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return t < a ? Util.properMod(t - 1, a) : t;
    });
  });
  ModularIncrementGates.all = $traceurRuntime.spread(ModularIncrementGates.IncrementModRFamily.all, ModularIncrementGates.DecrementModRFamily.all);
  return {
    get ModularIncrementGates() {
      return ModularIncrementGates;
    },
    get modulusTooBigChecker() {
      return modulusTooBigChecker;
    }
  };
});
//# sourceURL=src/gates/ModularIncrementGates.js
;$traceurRuntime.registerModule("src/gates/ModularMultiplicationGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ModularMultiplicationGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/ModularMultiplicationGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ModularMultiplicationGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/ModularMultiplicationGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var modulusTooBigChecker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularIncrementGates.js", "src/gates/ModularMultiplicationGates.js")).modulusTooBigChecker;
  var BIG_MUL_MOD_SHADER_CODE = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/MultiplyAccumulateGates.js", "src/gates/ModularMultiplicationGates.js")).BIG_MUL_MOD_SHADER_CODE;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/ModularMultiplicationGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/ModularMultiplicationGates.js")).WglArg;
  var ModularMultiplicationGates = {};
  var MODULAR_INVERSE_SHADER_CODE = ("\n    vec2 _mod_mul_step(vec2 v, float q) {\n        return vec2(v.y - q * v.x, v.x);\n    }\n    \n    " + BIG_MUL_MOD_SHADER_CODE + "\n\n    float modular_multiplicative_inverse(float value, float modulus) {\n        vec2 s = vec2(0.0, 1.0);\n        vec2 t = vec2(1.0, 0.0);\n        vec2 r = vec2(modulus, value);\n        float q;\n        // For values up to x, a number of iterations n satisfying phi^n > x should be sufficient.\n        for (int repeat = 0; repeat < " + Math.ceil(Config.MAX_WIRE_COUNT / (Math.log2(1 + Math.sqrt(5)) - 1)) + "; repeat++) {\n            if (r.x != 0.0) {\n                q = floor(r.y / r.x);\n                r = _mod_mul_step(r, q);\n                s = _mod_mul_step(s, q);\n                t = _mod_mul_step(t, q);\n            }\n        }\n        if (r.y != 1.0) {\n            return -1.0;\n        }\n        return mod(mod(s.y, modulus) + modulus, modulus);\n    }\n");
  var POW_MOD_SHADER_CODE = ("\n    " + MODULAR_INVERSE_SHADER_CODE + "\n\n    float pow_mod(float base, float exponent, float modulus) {\n        float base_inverse = modular_multiplicative_inverse(base, modulus);\n        if (base_inverse == -1.0) {\n            return -1.0;\n        }\n\n        if (exponent < 0.0) {\n            base = base_inverse;\n            exponent = -exponent;\n        }\n\n        float f = 1.0;\n        for (int k = 0; k < " + Config.MAX_WIRE_COUNT + "; k++) {\n            if (mod(exponent, 2.0) == 1.0) {\n                exponent -= 1.0;\n                f = big_mul_mod(f, base, modulus);\n            }\n            base = big_mul_mod(base, base, modulus);\n            exponent /= 2.0;\n        }\n        return f;\n    }\n");
  function modularMultiply(val, factor, modulus) {
    if (val >= modulus) {
      return val;
    }
    factor = Util.properMod(factor, modulus);
    if (factor === 0 || Util.extended_gcd(factor, modulus).gcd !== 1) {
      return val;
    }
    return (val * factor) % modulus;
  }
  function modularUnmultiply(val, factor, modulus) {
    if (val >= modulus) {
      return val;
    }
    factor = Util.properMod(factor, modulus);
    if (factor === 0) {
      return val;
    }
    var inverse_factor = Util.modular_multiplicative_inverse(factor, modulus);
    if (inverse_factor === undefined) {
      return val;
    }
    return (val * inverse_factor) % modulus;
  }
  function modularPowerMultiply(val, base, exponent, modulus) {
    if (val >= modulus) {
      return val;
    }
    base = Util.properMod(base, modulus);
    var inverse = Util.modular_multiplicative_inverse(base, modulus);
    if (inverse === undefined) {
      return val;
    }
    if (exponent < 0) {
      exponent = -exponent;
      base = inverse;
    }
    while (exponent > 0) {
      if ((exponent & 1) !== 0) {
        val = (val * base) % modulus;
      }
      base = (base * base) % modulus;
      exponent >>= 1;
    }
    return val;
  }
  var MODULAR_MULTIPLICATION_SHADER = ketShaderPermute(("\n        " + MODULAR_INVERSE_SHADER_CODE + "\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('R') + "\n    "), "\n        float input_a = read_input_A();\n        float modulus = read_input_R();\n        input_a = mod(input_a, modulus);\n        float v = modular_multiplicative_inverse(input_a, modulus);\n        if (v == -1.0 || out_id >= modulus) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, v, modulus);\n    ");
  var MODULAR_INVERSE_MULTIPLICATION_SHADER = ketShaderPermute(("\n        " + MODULAR_INVERSE_SHADER_CODE + "\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('R') + "\n    "), "\n        float input_a = read_input_A();\n        float modulus = read_input_R();\n        input_a = mod(input_a, modulus);\n        if (modular_multiplicative_inverse(input_a, modulus) == -1.0 || out_id >= modulus) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, input_a, modulus);\n    ");
  var MODULAR_POWER_MULTIPLICATION_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('B') + "\n        " + ketInputGateShaderCode('R') + "\n        " + POW_MOD_SHADER_CODE + "\n    "), "\n        float exponent = -read_input_A() * factor;\n        float base = read_input_B();\n        float modulus = read_input_R();\n        float f = pow_mod(base, exponent, modulus);\n        if (f == -1.0 || out_id >= modulus) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, f, modulus);\n    ");
  ModularMultiplicationGates.TimesAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("*AmodR" + span).setSymbol("×A\nmod R").setTitle("Modular Multiplication Gate").setBlurb("Multiplies the target by input A mod input R.\n" + "Only affects values less than R.\n" + "No effect if the multiplication would be irreversible.").setRequiredContextKeys("Input Range A", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'R'])));
    }).setKnownEffectToParametrizedPermutation(modularMultiply);
  });
  ModularMultiplicationGates.TimesAModRInverseFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("/AmodR" + span).setSymbol("×A^-1\nmod R").setTitle("Modular Division Gate").setBlurb("Inverse-multiplies the target by input A mod input R.\n" + "Only affects values less than R.\n" + "No effect if the multiplication would be irreversible.").setRequiredContextKeys("Input Range A", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_INVERSE_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'R'])));
    }).setKnownEffectToParametrizedPermutation(modularUnmultiply);
  });
  ModularMultiplicationGates.TimesBToTheAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("*BToAmodR" + span).setSymbol("×B^A\nmod R").setTitle("Modular Power Multiplication Gate").setBlurb("Multiplies the target by input B raised to the input A mod input R.\n" + "Only affects values less than R.\n" + "No effect if the multiplication would be irreversible.").setRequiredContextKeys("Input Range A", "Input Range B", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_POWER_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B', 'R']), [WglArg.float('factor', +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b, r) {
      return modularPowerMultiply(t, b, a, r);
    });
  });
  ModularMultiplicationGates.TimesInverseBToTheAModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("/BToAmodR" + span).setSymbol("×B^-A\nmod R").setTitle("Modular Power Division Gate").setBlurb("Inverse-multiplies the target by input B raised to the input A mod input R.\n" + "Only affects values less than R.\n" + "No effect if the multiplication would be irreversible.").setRequiredContextKeys("Input Range A", "Input Range B", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_POWER_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B', 'R']), [WglArg.float('factor', -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b, r) {
      return modularPowerMultiply(t, b, -a, r);
    });
  });
  ModularMultiplicationGates.all = $traceurRuntime.spread(ModularMultiplicationGates.TimesAModRFamily.all, ModularMultiplicationGates.TimesAModRInverseFamily.all, ModularMultiplicationGates.TimesBToTheAModRFamily.all, ModularMultiplicationGates.TimesInverseBToTheAModRFamily.all);
  return {
    get ModularMultiplicationGates() {
      return ModularMultiplicationGates;
    },
    get MODULAR_INVERSE_SHADER_CODE() {
      return MODULAR_INVERSE_SHADER_CODE;
    },
    get POW_MOD_SHADER_CODE() {
      return POW_MOD_SHADER_CODE;
    },
    get modularMultiply() {
      return modularMultiply;
    },
    get modularUnmultiply() {
      return modularUnmultiply;
    },
    get modularPowerMultiply() {
      return modularPowerMultiply;
    }
  };
});
//# sourceURL=src/gates/ModularMultiplicationGates.js
;$traceurRuntime.registerModule("src/gates/ModularMultiplyAccumulateGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ModularMultiplyAccumulateGates.js";
  var BIG_MUL_MOD_SHADER_CODE = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/MultiplyAccumulateGates.js", "src/gates/ModularMultiplyAccumulateGates.js")).BIG_MUL_MOD_SHADER_CODE;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ModularMultiplyAccumulateGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/ModularMultiplyAccumulateGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var modulusTooBigChecker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularIncrementGates.js", "src/gates/ModularMultiplyAccumulateGates.js")).modulusTooBigChecker;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/ModularMultiplyAccumulateGates.js")).Util;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/ModularMultiplyAccumulateGates.js")).WglArg;
  var ModularMultiplyAccumulateGates = {};
  var MODULAR_MULTIPLY_ACCUMULATE_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('B') + "\n        " + ketInputGateShaderCode('R') + "\n        " + BIG_MUL_MOD_SHADER_CODE + "\n    "), "\n        float r = read_input_R();\n        float a = read_input_A();\n        float b = read_input_B();\n\n        float d = big_mul_mod(factor * a, b, r);\n\n        float in_id = mod(out_id - d, r);\n        if (in_id < 0.0) {\n            in_id += r;\n        }\n        if (in_id >= r) {\n            in_id -= r;\n        }\n\n        return out_id >= r ? out_id : in_id;\n    ");
  ModularMultiplyAccumulateGates.PlusABModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+ABmodR" + span).setSymbol("+AB\nmod R").setTitle("Modular Multiply-Add Gate").setBlurb("Adds input A times input B into the target, mod input R.\nOnly affects values below R.").setRequiredContextKeys("Input Range A", "Input Range B", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_MULTIPLY_ACCUMULATE_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B', 'R']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b, r) {
      return t < r ? (t + a * b) % r : t;
    });
  });
  ModularMultiplyAccumulateGates.MinusABModRFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("-ABmodR" + span).setSymbol("−AB\nmod R").setTitle("Modular Multiply-Subtract Gate").setBlurb("Subtracts input A times input B out of the target, mod input R.\nOnly affects values below R.").setRequiredContextKeys("Input Range A", "Input Range B", "Input Range R").setExtraDisableReasonFinder(modulusTooBigChecker("R", span)).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MODULAR_MULTIPLY_ACCUMULATE_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B', 'R']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b, r) {
      return t < r ? Util.properMod(t - a * b, r) : t;
    });
  });
  ModularMultiplyAccumulateGates.all = $traceurRuntime.spread(ModularMultiplyAccumulateGates.PlusABModRFamily.all, ModularMultiplyAccumulateGates.MinusABModRFamily.all);
  return {get ModularMultiplyAccumulateGates() {
      return ModularMultiplyAccumulateGates;
    }};
});
//# sourceURL=src/gates/ModularMultiplyAccumulateGates.js
;$traceurRuntime.registerModule("src/gates/MultiplicationGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/MultiplicationGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/MultiplicationGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/MultiplicationGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularMultiplicationGates.js", "src/gates/MultiplicationGates.js")),
      modularMultiply = $__4.modularMultiply,
      modularUnmultiply = $__4.modularUnmultiply,
      MODULAR_INVERSE_SHADER_CODE = $__4.MODULAR_INVERSE_SHADER_CODE;
  var MultiplicationGates = {};
  var MULTIPLICATION_SHADER = ketShaderPermute(("\n        " + MODULAR_INVERSE_SHADER_CODE + "\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float input_a = read_input_A();\n        input_a = mod(input_a, span);\n        float v = modular_multiplicative_inverse(input_a, span);\n        if (v == -1.0) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, v, span);\n    ");
  var INVERSE_MULTIPLICATION_SHADER = ketShaderPermute(("\n        " + MODULAR_INVERSE_SHADER_CODE + "\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float input_a = read_input_A();\n        input_a = mod(input_a, span);\n        if (modular_multiplicative_inverse(input_a, span) == -1.0) {\n            return out_id;\n        }\n        return big_mul_mod(out_id, input_a, span);\n    ");
  MultiplicationGates.TimesAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("*A" + span).setSymbol("×A").setTitle("Multiplication Gate").setBlurb("Multiplies the target by input A.\n" + "No effect if the input is even (would be irreversible).").setRequiredContextKeys("Input Range A").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A'])));
    }).setKnownEffectToParametrizedPermutation(function(x, a) {
      return modularMultiply(x, a, 1 << span);
    });
  });
  MultiplicationGates.TimesAInverseFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("/A" + span).setSymbol("×A^-1").setTitle("Inverse Multiplication Gate").setBlurb("Inverse-multiplies the target by input A (modulo 2^n).\n" + "No effect if the input is even (would be irreversible).").setRequiredContextKeys("Input Range A").setKnownEffectToParametrizedPermutation(function(x, a) {
      return modularUnmultiply(x, a, 1 << span);
    }).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = INVERSE_MULTIPLICATION_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A'])));
    });
  });
  MultiplicationGates.all = $traceurRuntime.spread(MultiplicationGates.TimesAFamily.all, MultiplicationGates.TimesAInverseFamily.all);
  return {
    get MultiplicationGates() {
      return MultiplicationGates;
    },
    get MODULAR_INVERSE_SHADER_CODE() {
      return MODULAR_INVERSE_SHADER_CODE;
    }
  };
});
//# sourceURL=src/gates/MultiplicationGates.js
;$traceurRuntime.registerModule("src/gates/MultiplyAccumulateGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/MultiplyAccumulateGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/MultiplyAccumulateGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/MultiplyAccumulateGates.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/MultiplyAccumulateGates.js")).GatePainting;
  var $__8 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/MultiplyAccumulateGates.js")),
      ketArgs = $__8.ketArgs,
      ketShaderPermute = $__8.ketShaderPermute,
      ketInputGateShaderCode = $__8.ketInputGateShaderCode;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/MultiplyAccumulateGates.js")).WglArg;
  var MultiplyAccumulateGates = {};
  var sectionSizes = function(totalSize) {
    var c = Math.ceil(totalSize / 2);
    var b = Math.ceil((totalSize - c) / 2);
    var a = Math.max(totalSize - c - b, 1);
    return [a, b, totalSize - a - b];
  };
  var makeScaledMultiplyAddPermutation = function(span, scaleFactor) {
    return function(e) {
      var $__2,
          $__3;
      var $__1 = sectionSizes(span),
          sa = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
          sb = ($__3 = $__2.next()).done ? void 0 : $__3.value,
          sc = ($__3 = $__2.next()).done ? void 0 : $__3.value;
      var a = e & ((1 << sa) - 1);
      var b = (e >> sa) & ((1 << sb) - 1);
      var c = e >> (sa + sb);
      c += a * b * scaleFactor;
      c &= ((1 << sc) - 1);
      return a | (b << sa) | (c << (sa + sb));
    };
  };
  var MUL_STEP = 6;
  var BIG_MUL_MOD_SHADER_CODE = ("\n    // Avoids large multiplications that lose precision.\n    float big_mul_mod(float b, float f, float modulus) {\n        float t = 0.0;\n        float r;\n        for (int k = 0; k < " + Math.ceil(Config.MAX_WIRE_COUNT / MUL_STEP) + "; k++) {\n            r = mod(f, " + (1 << MUL_STEP) + ".0);\n            f -= r;\n            t = mod(t + b*r, modulus);\n            b = mod(b * " + (1 << MUL_STEP) + ".0, modulus);\n            f /= " + (1 << MUL_STEP) + ".0;\n        }\n        return t;\n    }\n");
  var MULTIPLY_ACCUMULATE_SHADER = ketShaderPermute(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n        " + ketInputGateShaderCode('B') + "\n        " + BIG_MUL_MOD_SHADER_CODE + "\n    "), "\n        float d1 = read_input_A();\n        float d2 = read_input_B();\n        float d = mod(big_mul_mod(d1, d2, span)*factor, span);\n        return mod(out_id + span - d, span);");
  MultiplyAccumulateGates.Legacy_MultiplyAddFamily = Gate.buildFamily(3, 16, function(span, builder) {
    return builder.setSerializedId("c+=ab" + span).setSymbol("c+=ab").setTitle("Multiply-Add Gate").setBlurb("Adds the product of two numbers into a third.").setDrawer(GatePainting.SECTIONED_DRAWER_MAKER(["a", "b", "c+=ab"], sectionSizes(span).slice(0, 2).map(function(e) {
      return e / span;
    }))).setActualEffectToUpdateFunc(function(ctx) {
      var $__2,
          $__3;
      var $__1 = sectionSizes(span),
          a = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
          b = ($__3 = $__2.next()).done ? void 0 : $__3.value,
          c = ($__3 = $__2.next()).done ? void 0 : $__3.value;
      return MultiplyAccumulateGates.MultiplyAddInputsFamily.ofSize(c).customOperation(ctx.withRow(ctx.row + a + b).withInputSetToRange('A', ctx.row, a).withInputSetToRange('B', ctx.row + a, b));
    }).setKnownEffectToPermutation(makeScaledMultiplyAddPermutation(span, +1));
  });
  MultiplyAccumulateGates.Legacy_MultiplySubtractFamily = Gate.buildFamily(3, 16, function(span, builder) {
    return builder.setSerializedId("c-=ab" + span).setSymbol("c-=ab").setTitle("Multiply-Subtract Gate").setBlurb("Subtracts the product of two numbers from a third.").setDrawer(GatePainting.SECTIONED_DRAWER_MAKER(["a", "b", "c-=ab"], sectionSizes(span).slice(0, 2).map(function(e) {
      return e / span;
    }))).setActualEffectToUpdateFunc(function(ctx) {
      var $__2,
          $__3;
      var $__1 = sectionSizes(span),
          a = ($__2 = $__1[Symbol.iterator](), ($__3 = $__2.next()).done ? void 0 : $__3.value),
          b = ($__3 = $__2.next()).done ? void 0 : $__3.value,
          c = ($__3 = $__2.next()).done ? void 0 : $__3.value;
      return MultiplyAccumulateGates.MultiplySubtractInputsFamily.ofSize(c).customOperation(ctx.withRow(ctx.row + a + b).withInputSetToRange('A', ctx.row, a).withInputSetToRange('B', ctx.row + a, b));
    }).setKnownEffectToPermutation(makeScaledMultiplyAddPermutation(span, -1));
  });
  MultiplyAccumulateGates.MultiplyAddInputsFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+=AB" + span).setSymbol("+AB").setTitle("Multiply-Add Gate [Inputs A, B]").setBlurb("Adds the product of inputs A and B into the qubits covered by this gate.").setRequiredContextKeys('Input Range A', 'Input Range B').setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = MULTIPLY_ACCUMULATE_SHADER).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B']), [WglArg.float("factor", +1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b) {
      return (t + a * b) & ((1 << span) - 1);
    });
  });
  MultiplyAccumulateGates.MultiplySubtractInputsFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("-=AB" + span).setSymbol("−AB").setTitle("Multiply-Subtract Gate [Inputs A, B]").setBlurb("Subtracts the product of inputs A and B out of the qubits covered by this gate.").setRequiredContextKeys('Input Range A', 'Input Range B').setActualEffectToShaderProvider(function(ctx) {
      var $__4;
      return ($__4 = MULTIPLY_ACCUMULATE_SHADER).withArgs.apply($__4, $traceurRuntime.spread(ketArgs(ctx, span, ['A', 'B']), [WglArg.float("factor", -1)]));
    }).setKnownEffectToParametrizedPermutation(function(t, a, b) {
      return (t - a * b) & ((1 << span) - 1);
    });
  });
  MultiplyAccumulateGates.SquareAddInputFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("+=AA" + span).setSymbol("+A^2").setTitle("Square-Add Gate [Input A]").setBlurb("Adds the square of input A into the qubits covered by this gate.").setRequiredContextKeys('Input Range A').setActualEffectToUpdateFunc(function(ctx) {
      return MultiplyAccumulateGates.MultiplyAddInputsFamily.ofSize(span).customOperation(ctx.withInputSetToOtherInput('B', 'A'));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return (t + a * a) & ((1 << span) - 1);
    });
  });
  MultiplyAccumulateGates.SquareSubtractInputFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("-=AA" + span).setSymbol("-A^2").setTitle("Square-Subtract Gate [Input A]").setBlurb("Subtracts the square of input A out of the qubits covered by this gate.").setRequiredContextKeys('Input Range A').setActualEffectToUpdateFunc(function(ctx) {
      return MultiplyAccumulateGates.MultiplySubtractInputsFamily.ofSize(span).customOperation(ctx.withInputSetToOtherInput('B', 'A'));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return (t - a * a) & ((1 << span) - 1);
    });
  });
  MultiplyAccumulateGates.all = $traceurRuntime.spread(MultiplyAccumulateGates.Legacy_MultiplyAddFamily.all, MultiplyAccumulateGates.Legacy_MultiplySubtractFamily.all, MultiplyAccumulateGates.MultiplyAddInputsFamily.all, MultiplyAccumulateGates.MultiplySubtractInputsFamily.all, MultiplyAccumulateGates.SquareAddInputFamily.all, MultiplyAccumulateGates.SquareSubtractInputFamily.all);
  return {
    get MultiplyAccumulateGates() {
      return MultiplyAccumulateGates;
    },
    get BIG_MUL_MOD_SHADER_CODE() {
      return BIG_MUL_MOD_SHADER_CODE;
    },
    get MUL_STEP() {
      return MUL_STEP;
    }
  };
});
//# sourceURL=src/gates/MultiplyAccumulateGates.js
;$traceurRuntime.registerModule("src/gates/ParametrizedRotationGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ParametrizedRotationGates.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ParametrizedRotationGates.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/ParametrizedRotationGates.js")).GatePainting;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/ParametrizedRotationGates.js")),
      ketArgs = $__4.ketArgs,
      ketShader = $__4.ketShader,
      ketShaderPhase = $__4.ketShaderPhase,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/ParametrizedRotationGates.js")).WglArg;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/ParametrizedRotationGates.js")).Util;
  var ParametrizedRotationGates = {};
  function exponent_to_A_len_painter(args) {
    var v = args.getGateContext('Input Range A');
    var denom_exponent = v === undefined ? 'ⁿ' : Util.digits_to_superscript_digits('' + v.length);
    var symbol = args.gate.symbol.replace('ⁿ', denom_exponent);
    GatePainting.paintBackground(args);
    GatePainting.paintOutline(args);
    GatePainting.paintGateSymbol(args, symbol);
  }
  var X_TO_A_SHADER = ketShader(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float angle = read_input_A() * factor / _gen_input_span_A;\n        float c = cos(angle) * 0.5;\n        float s = sin(angle) * 0.5;\n        vec2 u = vec2(0.5 + c, s);\n        vec2 v = vec2(0.5 - c, -s);\n        // multiply state by the matrix [[u, v], [v, u]]\n        vec2 amp2 = inp(1.0-out_id);\n        return cmul(u, amp) + cmul(v, amp2);\n    ");
  var Y_TO_A_SHADER = ketShader(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float angle = read_input_A() * factor / _gen_input_span_A;\n        float c = cos(angle) * 0.5;\n        float s = sin(angle) * 0.5;\n        vec2 u = vec2(c + 0.5, s);\n        vec2 v = vec2(s, 0.5 - c);\n        // multiply state by the matrix [[u, v], [-v, u]]\n        vec2 amp2 = inp(1.0-out_id);\n        vec2 vs = v * (-1.0 + 2.0 * out_id);\n        return cmul(u, amp) + cmul(vs, amp2);\n    ");
  var Z_TO_A_SHADER = ketShaderPhase(("\n        uniform float factor;\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        return read_input_A() * out_id * factor / _gen_input_span_A;\n    ");
  ParametrizedRotationGates.XToA = new GateBuilder().setSerializedId("X^(A/2^n)").setSymbol("X^A/2ⁿ").setTitle("Parametrized X Gate").setBlurb("Rotates the target by input A / 2ⁿ'th of a half turn around the X axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = X_TO_A_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', Math.PI)]));
  }).promiseEffectIsStable().promiseEffectIsUnitary().gate;
  ParametrizedRotationGates.XToMinusA = new GateBuilder().setSerializedId("X^(-A/2^n)").setSymbol("X^-A/2ⁿ").setTitle("Parametrized -X Gate").setBlurb("Counter-rotates the target by input A / 2ⁿ'th of a half turn around the X axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = X_TO_A_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', -Math.PI)]));
  }).promiseEffectIsStable().promiseEffectIsUnitary().gate;
  ParametrizedRotationGates.YToA = new GateBuilder().setSerializedId("Y^(A/2^n)").setSymbol("Y^A/2ⁿ").setTitle("Parametrized Y Gate").setBlurb("Rotates the target by input A / 2ⁿ'th of a half turn around the Y axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = Y_TO_A_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', Math.PI)]));
  }).promiseEffectIsStable().promiseEffectIsUnitary().gate;
  ParametrizedRotationGates.YToMinusA = new GateBuilder().setSerializedId("Y^(-A/2^n)").setSymbol("Y^-A/2ⁿ").setTitle("Parametrized -Y Gate").setBlurb("Counter-rotates the target by input A / 2ⁿ'th of a half turn around the Y axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = Y_TO_A_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', -Math.PI)]));
  }).promiseEffectIsStable().promiseEffectIsUnitary().gate;
  ParametrizedRotationGates.ZToA = new GateBuilder().setSerializedId("Z^(A/2^n)").setSymbol("Z^A/2ⁿ").setTitle("Parametrized Z Gate").setBlurb("Rotates the target by input A / 2ⁿ'th of a half turn around the Z axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = Z_TO_A_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', Math.PI)]));
  }).promiseEffectIsStable().promiseEffectOnlyPhases().gate;
  ParametrizedRotationGates.ZToMinusA = new GateBuilder().setSerializedId("Z^(-A/2^n)").setSymbol("Z^-A/2ⁿ").setTitle("Parametrized -Z Gate").setBlurb("Counter-rotates the target by input A / 2ⁿ'th of a half turn around the Z axis.\n" + "n is the number of qubits in input A.").setRequiredContextKeys('Input NO_DEFAULT Range A').setDrawer(exponent_to_A_len_painter).setActualEffectToShaderProvider(function(ctx) {
    var $__1;
    return ($__1 = Z_TO_A_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, 1, ['A']), [WglArg.float('factor', -Math.PI)]));
  }).promiseEffectIsStable().promiseEffectOnlyPhases().gate;
  ParametrizedRotationGates.all = [ParametrizedRotationGates.XToA, ParametrizedRotationGates.XToMinusA, ParametrizedRotationGates.YToA, ParametrizedRotationGates.YToMinusA, ParametrizedRotationGates.ZToA, ParametrizedRotationGates.ZToMinusA];
  return {get ParametrizedRotationGates() {
      return ParametrizedRotationGates;
    }};
});
//# sourceURL=src/gates/ParametrizedRotationGates.js
;$traceurRuntime.registerModule("src/gates/PhaseGradientGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/PhaseGradientGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/PhaseGradientGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/PhaseGradientGates.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/PhaseGradientGates.js")).GatePainting;
  var $__5 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/PhaseGradientGates.js")),
      ketArgs = $__5.ketArgs,
      ketShaderPhase = $__5.ketShaderPhase;
  var MUL_STEP = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/MultiplyAccumulateGates.js", "src/gates/PhaseGradientGates.js")).MUL_STEP;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/gates/PhaseGradientGates.js")).WglArg;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/PhaseGradientGates.js")).Matrix;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/gates/PhaseGradientGates.js")).Complex;
  var PHASE_GRADIENT_SHADER = ketShaderPhase(("\n        uniform float factor;\n\n        /// Scales an angle by an integer factor.\n        /// Performs the multiplication gradually, to avoid losing precision.\n        float angle_mul(float base_angle, float whole_factor) {\n            float result = 0.0;\n            for (int k = 0; k < " + Math.ceil(Config.MAX_WIRE_COUNT / MUL_STEP) + "; k++) {\n                result += base_angle * mod(whole_factor, " + (1 << MUL_STEP) + ".0);\n                result = mod(result, 6.283185307179586476925286766559);\n                whole_factor = floor(whole_factor / " + (1 << MUL_STEP) + ".0);\n                base_angle = mod(base_angle * " + (1 << MUL_STEP) + ".0, 6.283185307179586476925286766559);\n            }\n            return result;\n        }\n    "), "\n        return angle_mul(factor, out_id);\n    ");
  var PhaseGradientGates = {};
  PhaseGradientGates.PhaseGradientFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("PhaseGradient" + span).setSymbol("Grad^½").setTitle("Half Gradient Gate").setBlurb("Phases the target by an amount proportional its value.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("factor", Math.PI / (1 << span))]));
    }).setKnownEffectToPhaser(function(k) {
      return k / (2 << span);
    });
  });
  PhaseGradientGates.PhaseDegradientFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("PhaseUngradient" + span).setSymbol("Grad^-½").setTitle("Inverse Half Gradient Gate").setBlurb("Counter-phases the target by an amount proportional its value.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("factor", -Math.PI / (1 << span))]));
    }).setKnownEffectToPhaser(function(k) {
      return -k / (2 << span);
    });
  });
  PhaseGradientGates.DynamicPhaseGradientFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("grad^t" + span).setSymbol("Grad^t").setTitle("Cycling Gradient Gate").setBlurb("Phases the target by a cycling amount proportional its value.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("factor", ctx.time * Math.PI * 2)]));
    }).setEffectToTimeVaryingMatrix(function(t) {
      return Matrix.generateDiagonal(1 << span, function(k) {
        return Complex.polar(1, t * 2 * Math.PI * k);
      });
    }).promiseEffectOnlyPhases().setDrawer(GatePainting.makeCycleDrawer(-1, -1, 1, -Math.PI / 2));
  });
  PhaseGradientGates.DynamicPhaseDegradientFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("grad^-t" + span).setSymbol("Grad^-t").setTitle("Inverse Cycling Gradient Gate").setBlurb("Counter-phases the target by a cycling amount proportional its value.").setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PHASE_GRADIENT_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span), [WglArg.float("factor", -ctx.time * Math.PI * 2)]));
    }).setEffectToTimeVaryingMatrix(function(t) {
      return Matrix.generateDiagonal(1 << span, function(k) {
        return Complex.polar(1, t * 2 * Math.PI * -k);
      });
    }).promiseEffectOnlyPhases().setDrawer(GatePainting.makeCycleDrawer(1, -1, 1, Math.PI / 2));
  });
  PhaseGradientGates.all = $traceurRuntime.spread(PhaseGradientGates.PhaseGradientFamily.all, PhaseGradientGates.PhaseDegradientFamily.all, PhaseGradientGates.DynamicPhaseGradientFamily.all, PhaseGradientGates.DynamicPhaseDegradientFamily.all);
  return {
    get PhaseGradientGates() {
      return PhaseGradientGates;
    },
    get PHASE_GRADIENT_SHADER() {
      return PHASE_GRADIENT_SHADER;
    }
  };
});
//# sourceURL=src/gates/PhaseGradientGates.js
;$traceurRuntime.registerModule("src/gates/PivotFlipGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/PivotFlipGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/PivotFlipGates.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/PivotFlipGates.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute,
      ketInputGateShaderCode = $__3.ketInputGateShaderCode;
  var modulusTooBigChecker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ModularIncrementGates.js", "src/gates/PivotFlipGates.js")).modulusTooBigChecker;
  var PivotFlipGates = {};
  var PIVOT_FLIP_SHADER = ketShaderPermute(("\n        " + ketInputGateShaderCode('A') + "\n    "), "\n        float a = read_input_A();\n        return out_id >= a ? out_id : a - out_id - 1.0;\n    ");
  PivotFlipGates.FlipUnderA = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId('Flip<A' + span).setSymbol('Flip\n< A').setTitle('Pivot-Flip Gate').setBlurb('Reverses the order of states below the pivot value.').setRequiredContextKeys('Input Range A').setExtraDisableReasonFinder(modulusTooBigChecker('A', span, 'pivot')).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = PIVOT_FLIP_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A'])));
    }).setKnownEffectToParametrizedPermutation(function(t, a) {
      return t >= a ? t : a - t - 1;
    });
  });
  PivotFlipGates.all = $traceurRuntime.spread(PivotFlipGates.FlipUnderA.all);
  return {get PivotFlipGates() {
      return PivotFlipGates;
    }};
});
//# sourceURL=src/gates/PivotFlipGates.js
;$traceurRuntime.registerModule("src/gates/PostSelectionGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/PostSelectionGates.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/gates/PostSelectionGates.js")).Complex;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/PostSelectionGates.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/PostSelectionGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/PostSelectionGates.js")).Matrix;
  var PostSelectionGates = {};
  var POST_SELECT_DRAWER = function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.DEFAULT_DRAWER(args);
    } else {
      args.painter.fillRect(args.rect, 'white');
      GatePainting.paintGateSymbol(args);
    }
    if (!args.isInToolbox) {
      var $__1 = args.rect,
          x = $__1.x,
          y = $__1.y,
          w = $__1.w,
          h = $__1.h;
      args.painter.print("post-", x + w / 2, y, 'center', 'hanging', 'red', '10px sans-serif', w, h / 2);
      args.painter.print("select", x + w / 2, y + h, 'center', 'bottom', 'red', '10px sans-serif', w, h / 2);
    }
  };
  PostSelectionGates.PostSelectOff = new GateBuilder().setSerializedIdAndSymbol("|0⟩⟨0|").setTitle("Postselect Off").setBlurb("Keeps OFF states, discards/retries ON states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, 0, 0, 0)).gate;
  PostSelectionGates.PostSelectOn = new GateBuilder().setSerializedIdAndSymbol("|1⟩⟨1|").setTitle("Postselect On").setBlurb("Keeps On states, discards/retries Off states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(0, 0, 0, 1)).gate;
  PostSelectionGates.PostSelectAntiX = new GateBuilder().setSerializedId("|+⟩⟨+|").setSymbol("|⊖⟩⟨⊖|").setTitle("Postselect X-Off").setBlurb("Keeps ON+OFF states, discards/retries ON-OFF states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, 1, 1, 1).times(0.5)).gate;
  PostSelectionGates.PostSelectX = new GateBuilder().setSerializedId("|-⟩⟨-|").setSymbol("|⊕⟩⟨⊕|").setTitle("Postselect X-On").setBlurb("Keeps ON-OFF states, discards/retries ON+OFF states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, -1, -1, 1).times(0.5)).gate;
  PostSelectionGates.PostSelectAntiY = new GateBuilder().setSerializedId("|X⟩⟨X|").setSymbol("|⊘⟩⟨⊘|").setTitle("Postselect Y-Off").setBlurb("Keeps ON+iOFF states, discards ON-iOFF states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, Complex.I.neg(), Complex.I, 1).times(0.5)).gate;
  PostSelectionGates.PostSelectY = new GateBuilder().setSerializedId("|/⟩⟨/|").setSymbol("|⊗⟩⟨⊗|").setTitle("Postselect Y-On").setBlurb("Keeps ON-iOFF states, discards/retries ON+iOFF states.").setDrawer(POST_SELECT_DRAWER).setKnownEffectToMatrix(Matrix.square(1, Complex.I, Complex.I.neg(), 1).times(0.5)).gate;
  PostSelectionGates.all = [PostSelectionGates.PostSelectOff, PostSelectionGates.PostSelectOn, PostSelectionGates.PostSelectAntiX, PostSelectionGates.PostSelectX, PostSelectionGates.PostSelectAntiY, PostSelectionGates.PostSelectY];
  return {get PostSelectionGates() {
      return PostSelectionGates;
    }};
});
//# sourceURL=src/gates/PostSelectionGates.js
;$traceurRuntime.registerModule("src/gates/PoweringGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/PoweringGates.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/PoweringGates.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/PoweringGates.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/PoweringGates.js")).Matrix;
  var PoweringGates = {};
  var τ = Math.PI * 2;
  var XPow = function(t) {
    var c = Math.cos(τ * t) / 2;
    var s = Math.sin(τ * t) / 2;
    return new Matrix(2, 2, new Float32Array([0.5 + c, s, 0.5 - c, -s, 0.5 - c, -s, 0.5 + c, s]));
  };
  var YPow = function(t) {
    var c = Math.cos(τ * t) / 2;
    var s = Math.sin(τ * t) / 2;
    return new Matrix(2, 2, new Float32Array([0.5 + c, s, -s, c - 0.5, s, 0.5 - c, 0.5 + c, s]));
  };
  var ZPow = function(t) {
    var c = Math.cos(τ * t);
    var s = Math.sin(τ * t);
    return new Matrix(2, 2, new Float32Array([1, 0, 0, 0, 0, 0, c, s]));
  };
  PoweringGates.XForward = new GateBuilder().setSerializedIdAndSymbol("X^t").setTitle("X-Raising Gate (forward)").setBlurb("Right-handed cycle from no-op to X.").setDrawer(GatePainting.makeCycleDrawer(1, 1)).setEffectToTimeVaryingMatrix(XPow).promiseEffectIsUnitary().gate;
  PoweringGates.XBackward = new GateBuilder().setSerializedIdAndSymbol("X^-t").setTitle("X-Raising Gate (backward)").setBlurb("Left-handed cycle from no-op to X.").setDrawer(GatePainting.makeCycleDrawer(-1, 1)).setEffectToTimeVaryingMatrix(function(t) {
    return XPow(-t);
  }).promiseEffectIsUnitary().gate;
  PoweringGates.YForward = new GateBuilder().setSerializedIdAndSymbol("Y^t").setTitle("Y-Raising Gate (forward)").setBlurb("Right-handed cycle from no-op to Y.").setDrawer(GatePainting.makeCycleDrawer(0.5, 1)).setEffectToTimeVaryingMatrix(YPow).promiseEffectIsUnitary().gate;
  PoweringGates.YBackward = new GateBuilder().setSerializedIdAndSymbol("Y^-t").setTitle("Y-Raising Gate (backward)").setBlurb("Left-handed cycle from no-op to Y.").setDrawer(GatePainting.makeCycleDrawer(-0.5, 1)).setEffectToTimeVaryingMatrix(function(t) {
    return YPow(-t);
  }).promiseEffectIsUnitary().gate;
  PoweringGates.ZForward = new GateBuilder().setSerializedIdAndSymbol("Z^t").setTitle("Z-Raising Gate (forward)").setBlurb("Right-handed cycle from no-op to Z.").setDrawer(GatePainting.makeCycleDrawer(-1, -0.5)).setEffectToTimeVaryingMatrix(ZPow).promiseEffectOnlyPhases().gate;
  PoweringGates.ZBackward = new GateBuilder().setSerializedIdAndSymbol("Z^-t").setTitle("Z-Raising Gate (backward)").setBlurb("Left-handed cycle from no-op to Z.").setDrawer(GatePainting.makeCycleDrawer(1, -0.5)).setEffectToTimeVaryingMatrix(function(t) {
    return ZPow(-t);
  }).promiseEffectOnlyPhases().gate;
  PoweringGates.all = [PoweringGates.XForward, PoweringGates.YForward, PoweringGates.ZForward, PoweringGates.XBackward, PoweringGates.YBackward, PoweringGates.ZBackward];
  return {get PoweringGates() {
      return PoweringGates;
    }};
});
//# sourceURL=src/gates/PoweringGates.js
;$traceurRuntime.registerModule("src/gates/ProbabilityDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ProbabilityDisplay.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/ProbabilityDisplay.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ProbabilityDisplay.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/ProbabilityDisplay.js")).GatePainting;
  var GateShaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateShaders.js", "src/gates/ProbabilityDisplay.js")).GateShaders;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/gates/ProbabilityDisplay.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/ProbabilityDisplay.js")).Matrix;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/ProbabilityDisplay.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/gates/ProbabilityDisplay.js")).Rect;
  var Shaders = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/Shaders.js", "src/gates/ProbabilityDisplay.js")).Shaders;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/ProbabilityDisplay.js")).Util;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/gates/ProbabilityDisplay.js")).WglConfiguredShader;
  var $__20 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/gates/ProbabilityDisplay.js")),
      Inputs = $__20.Inputs,
      Outputs = $__20.Outputs,
      currentShaderCoder = $__20.currentShaderCoder,
      makePseudoShaderWithInputsAndOutputAndCode = $__20.makePseudoShaderWithInputsAndOutputAndCode;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexturePool.js", "src/gates/ProbabilityDisplay.js")).WglTexturePool;
  var WglTextureTrader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTextureTrader.js", "src/gates/ProbabilityDisplay.js")).WglTextureTrader;
  function probabilityStatTexture(ketTexture, controlTexture, rangeOffset, rangeLength) {
    var trader = new WglTextureTrader(ketTexture);
    trader.dontDeallocCurrentTexture();
    var n = currentShaderCoder().vec2.arrayPowerSizeOfTexture(ketTexture);
    trader.shadeAndTrade(function(tex) {
      return amplitudesToProbabilities(tex, controlTexture);
    }, WglTexturePool.takeVecFloatTex(n));
    trader.shadeAndTrade(function(tex) {
      return GateShaders.cycleAllBitsFloat(tex, -rangeOffset);
    });
    while (n > rangeLength) {
      n -= 1;
      trader.shadeHalveAndTrade(Shaders.sumFoldFloat);
    }
    if (currentShaderCoder().float.needRearrangingToBeInVec4Format) {
      trader.shadeQuarterAndTrade(Shaders.packFloatIntoVec4);
    }
    return trader.currentTexture;
  }
  var amplitudesToProbabilities = function(inputTexture, controlTex) {
    return AMPLITUDES_TO_PROBABILITIES_SHADER(inputTexture, controlTex);
  };
  var AMPLITUDES_TO_PROBABILITIES_SHADER = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input'), Inputs.bool('control')], Outputs.float(), "float outputFor(float k) {\n        vec2 amp = read_input(k);\n        return dot(amp, amp) * read_control(k);\n    }");
  function probabilityPixelsToColumnVector(pixels, span) {
    var n = 1 << span;
    var unity = 0;
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (pixels)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var e = $__1.value;
        {
          unity += e;
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
    if (isNaN(unity) || unity < 0.000001) {
      return Matrix.zero(1, n).times(NaN);
    }
    var buf = new Float32Array(n * 2);
    for (var i = 0; i < n; i++) {
      buf[i * 2] = pixels[i] / unity;
    }
    return new Matrix(1, n, buf);
  }
  function _paintMultiProbabilityDisplay_grid(args) {
    var $__7 = args,
        painter = $__7.painter,
        $__8 = $__7.rect,
        x = $__8.x,
        y = $__8.y,
        w = $__8.w,
        h = $__8.h;
    var n = 1 << args.gate.height;
    var d = h / n;
    painter.fillRect(args.rect, Config.DISPLAY_GATE_BACK_COLOR);
    if (d < 1) {
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.2;
      painter.fillRect(args.rect, 'lightgray');
      args.painter.ctx.restore();
      return;
    }
    var r = args.gate.height - 5;
    painter.trace(function(tracer) {
      for (var i = 1; i < n; i++) {
        tracer.line(x, y + d * i, x + w, y + d * i);
      }
    }).thenStroke('lightgray', r <= 0 ? 1 : 1 / r);
    painter.strokeRect(args.rect, 'lightgray');
  }
  function _paintMultiProbabilityDisplay_probabilityBars(args) {
    var $__7 = args,
        painter = $__7.painter,
        $__8 = $__7.rect,
        x = $__8.x,
        y = $__8.y,
        w = $__8.w,
        h = $__8.h,
        probabilities = $__7.customStats;
    var n = 1 << args.gate.height;
    var d = h / n;
    var e = Math.max(d, 1);
    painter.ctx.save();
    painter.ctx.beginPath();
    painter.ctx.moveTo(x, y);
    for (var i = 0; i < n; i++) {
      var p = probabilities.rawBuffer()[i * 2];
      var px = x + w * p;
      var py = y + d * i;
      painter.ctx.lineTo(px, py);
      painter.ctx.lineTo(px, py + e);
    }
    painter.ctx.lineTo(x, y + h);
    painter.ctx.lineTo(x, y);
    painter.ctx.strokeStyle = 'gray';
    painter.ctx.lineWidth = 1;
    painter.ctx.stroke();
    painter.ctx.fillStyle = Config.DISPLAY_GATE_FORE_COLOR;
    painter.ctx.fill();
    painter.ctx.restore();
  }
  function _paintMultiProbabilityDisplay_logarithmHints(args) {
    var $__7 = args,
        painter = $__7.painter,
        $__8 = $__7.rect,
        x = $__8.x,
        y = $__8.y,
        w = $__8.w,
        h = $__8.h,
        probabilities = $__7.customStats;
    var n = 1 << args.gate.height;
    var d = h / n;
    var e = Math.max(d, 1);
    painter.ctx.save();
    painter.ctx.beginPath();
    painter.ctx.moveTo(x, y);
    var s = 1 / (4 + Math.max(8, args.gate.height));
    for (var i = 0; i < n; i++) {
      var p = probabilities.rawBuffer()[i * 2];
      var px = x + w * Math.min(1, Math.max(0, 1 + Math.log(p) * s));
      var py = y + d * i;
      painter.ctx.lineTo(px, py);
      painter.ctx.lineTo(px, py + e);
    }
    painter.ctx.lineTo(x, y + h);
    painter.ctx.lineWidth = 1;
    painter.ctx.strokeStyle = '#CCC';
    painter.ctx.stroke();
    painter.ctx.restore();
  }
  function _paintMultiProbabilityDisplay_tooltips(args) {
    var $__7 = args,
        painter = $__7.painter,
        $__8 = $__7.rect,
        x = $__8.x,
        y = $__8.y,
        w = $__8.w,
        h = $__8.h,
        probabilities = $__7.customStats;
    var n = 1 << args.gate.height;
    var d = h / n;
    var $__3 = true;
    var $__4 = false;
    var $__5 = undefined;
    try {
      for (var $__1 = void 0,
          $__0 = (args.focusPoints)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
        var pt = $__1.value;
        {
          var k = Math.floor((pt.y - y) / d);
          if (args.rect.containsPoint(pt) && k >= 0 && k < n) {
            var p = probabilities === undefined ? NaN : probabilities.rawBuffer()[k * 2];
            painter.strokeRect(new Rect(x, y + k * d, w, d), 'orange', 2);
            MathPainter.paintDeferredValueTooltip(painter, x + w, y + k * d, ("Chance of |" + Util.bin(k, args.gate.height) + "⟩ if measured"), 'raw: ' + (p * 100).toFixed(4) + "%", 'log: ' + (Math.log10(p) * 10).toFixed(1) + " dB");
          }
        }
      }
    } catch ($__6) {
      $__4 = true;
      $__5 = $__6;
    } finally {
      try {
        if (!$__3 && $__0.return != null) {
          $__0.return();
        }
      } finally {
        if ($__4) {
          throw $__5;
        }
      }
    }
  }
  function _paintMultiProbabilityDisplay_probabilityTexts(args) {
    var $__7 = args,
        painter = $__7.painter,
        $__8 = $__7.rect,
        x = $__8.x,
        y = $__8.y,
        w = $__8.w,
        h = $__8.h,
        probabilities = $__7.customStats;
    var d = h / probabilities.height();
    for (var i = 0; i < probabilities.height(); i++) {
      var p = probabilities.rawBuffer()[i * 2];
      painter.print((p * 100).toFixed(1) + "%", x + w - 2, y + d * (i + 0.5), 'right', 'middle', 'black', '8pt monospace', w - 4, d);
    }
  }
  function paintMultiProbabilityDisplay(args) {
    _paintMultiProbabilityDisplay_grid(args);
    var probabilities = args.customStats;
    var noData = probabilities === undefined || probabilities.hasNaN();
    if (noData) {
      args.painter.printParagraph("NaN", args.rect, new Point(0.5, 0.5), 'red');
    } else {
      var textFits = args.rect.h / probabilities.height() > 8;
      if (!textFits) {
        _paintMultiProbabilityDisplay_logarithmHints(args);
      }
      _paintMultiProbabilityDisplay_probabilityBars(args);
      if (textFits) {
        _paintMultiProbabilityDisplay_probabilityTexts(args);
      }
    }
    _paintMultiProbabilityDisplay_tooltips(args);
  }
  function shared_chanceGateMaker(builder) {
    return builder.setSymbol("Chance").setTitle("Probability Display").setBlurb("Shows chances of outcomes if a measurement was performed.\n" + "Use controls to see conditional probabilities.").promiseHasNoNetEffectOnStateVector().setExtraDisableReasonFinder(function(args) {
      return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
    });
  }
  function multiChanceGateMaker(span, builder) {
    return shared_chanceGateMaker(builder).setSerializedId("Chance" + span).setStatTexturesMaker(function(ctx) {
      return probabilityStatTexture(ctx.stateTrader.currentTexture, ctx.controlsTexture, ctx.row, span);
    }).setStatPixelDataPostProcessor(function(pixels) {
      return probabilityPixelsToColumnVector(pixels, span);
    }).setDrawer(GatePainting.makeDisplayDrawer(paintMultiProbabilityDisplay));
  }
  function singleChangeGateMaker(builder) {
    return shared_chanceGateMaker(builder).setSerializedId("Chance").markAsDrawerNeedsSingleQubitDensityStats().setDrawer(GatePainting.makeDisplayDrawer(function(args) {
      var $__7 = args.positionInCircuit,
          row = $__7.row,
          col = $__7.col;
      MathPainter.paintProbabilityBox(args.painter, args.stats.controlledWireProbabilityJustAfter(row, col), args.rect, args.focusPoints);
    }));
  }
  var ProbabilityDisplayFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return span === 1 ? singleChangeGateMaker(builder) : multiChanceGateMaker(span, builder);
  });
  return {
    get ProbabilityDisplayFamily() {
      return ProbabilityDisplayFamily;
    },
    get probabilityStatTexture() {
      return probabilityStatTexture;
    },
    get probabilityPixelsToColumnVector() {
      return probabilityPixelsToColumnVector;
    },
    get amplitudesToProbabilities() {
      return amplitudesToProbabilities;
    }
  };
});
//# sourceURL=src/gates/ProbabilityDisplay.js
;$traceurRuntime.registerModule("src/gates/QuarterTurnGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/QuarterTurnGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/QuarterTurnGates.js")).Gate;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/QuarterTurnGates.js")).Matrix;
  var QuarterTurnGates = {};
  QuarterTurnGates.SqrtXForward = Gate.fromKnownMatrix("X^½", Matrix.fromPauliRotation(0.25, 0, 0), "√X Gate", "Principle square root of Not.");
  QuarterTurnGates.SqrtXBackward = Gate.fromKnownMatrix("X^-½", Matrix.fromPauliRotation(0.75, 0, 0), "X^-½ Gate", "Adjoint square root of Not.");
  QuarterTurnGates.SqrtYForward = Gate.fromKnownMatrix("Y^½", Matrix.fromPauliRotation(0, 0.25, 0), "√Y Gate", "Principle square root of Y.");
  QuarterTurnGates.SqrtYBackward = Gate.fromKnownMatrix("Y^-½", Matrix.fromPauliRotation(0, 0.75, 0), "Y^-½ Gate", "Adjoint square root of Y.");
  QuarterTurnGates.SqrtZForward = Gate.fromKnownMatrix("Z^½", Matrix.fromPauliRotation(0, 0, 0.25), "√Z Gate", "Principle square root of Z.\nAlso known as the 'S' gate.");
  QuarterTurnGates.SqrtZBackward = Gate.fromKnownMatrix("Z^-½", Matrix.fromPauliRotation(0, 0, 0.75), "Z^-½ Gate", "Adjoint square root of Z.");
  QuarterTurnGates.all = [QuarterTurnGates.SqrtXForward, QuarterTurnGates.SqrtYForward, QuarterTurnGates.SqrtZForward, QuarterTurnGates.SqrtXBackward, QuarterTurnGates.SqrtYBackward, QuarterTurnGates.SqrtZBackward];
  return {get QuarterTurnGates() {
      return QuarterTurnGates;
    }};
});
//# sourceURL=src/gates/QuarterTurnGates.js
;$traceurRuntime.registerModule("src/gates/ReverseBitsGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/ReverseBitsGate.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/ReverseBitsGate.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/ReverseBitsGate.js")).Gate;
  var $__3 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/ReverseBitsGate.js")),
      ketArgs = $__3.ketArgs,
      ketShaderPermute = $__3.ketShaderPermute;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/gates/ReverseBitsGate.js")).Seq;
  var _generateReverseShaderForSize = function(span) {
    return span < 2 ? undefined : ketShaderPermute('', ("\n        float rev = 0.0;\n        for (int k = 0; k < " + span + "; k++) {\n            rev *= 2.0;\n            rev += mod(out_id, 2.0);\n            out_id = floor(out_id*0.5);\n        }\n        return rev;\n    "), span);
  };
  var reverseShaders = Seq.range(Config.MAX_WIRE_COUNT + 1).map(_generateReverseShaderForSize).toArray();
  var reverseShaderForSize = function(span) {
    return function(ctx) {
      var $__0;
      return ($__0 = reverseShaders[span]).withArgs.apply($__0, $traceurRuntime.spread(ketArgs(ctx, span)));
    };
  };
  var ReverseBitsGateFamily = Gate.buildFamily(2, 16, function(span, builder) {
    return builder.setSerializedId("rev" + span).setSymbol("Reverse").setTitle("Reverse Order").setBlurb("Swaps bits into the opposite order.").setKnownEffectToBitPermutation(function(i) {
      return span - 1 - i;
    }).setActualEffectToShaderProvider(reverseShaderForSize(span));
  });
  return {
    get ReverseBitsGateFamily() {
      return ReverseBitsGateFamily;
    },
    get reverseShaderForSize() {
      return reverseShaderForSize;
    }
  };
});
//# sourceURL=src/gates/ReverseBitsGate.js
;$traceurRuntime.registerModule("src/gates/SampleDisplay.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/SampleDisplay.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/SampleDisplay.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/SampleDisplay.js")).Gate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/SampleDisplay.js")).GatePainting;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/gates/SampleDisplay.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/gates/SampleDisplay.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/gates/SampleDisplay.js")).Rect;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/gates/SampleDisplay.js")).Util;
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/ProbabilityDisplay.js", "src/gates/SampleDisplay.js")),
      probabilityStatTexture = $__18.probabilityStatTexture,
      probabilityPixelsToColumnVector = $__18.probabilityPixelsToColumnVector;
  function sampleFromDistribution(args) {
    var probabilities = args.customStats;
    var buf = probabilities.rawBuffer();
    var r = args.painter.rng.random();
    var n = probabilities.height();
    for (var i = 0; ; i++) {
      var p = buf[i * 2];
      r -= p;
      if (i === n - 1 || r < 0.00001) {
        return {
          i: i,
          p: p
        };
      }
    }
  }
  function _paintSampleDisplay_result(args) {
    var $__8 = args,
        painter = $__8.painter,
        $__9 = $__8.rect,
        x = $__9.x,
        y = $__9.y,
        w = $__9.w,
        h = $__9.h;
    var d = Config.WIRE_SPACING;
    var startY = y + h / 2 - d * args.gate.height / 2;
    var $__10 = sampleFromDistribution(args),
        sample = $__10.i,
        p = $__10.p;
    for (var i = 0; i < args.gate.height; i++) {
      var bit = ((sample >> i) & 1) !== 0;
      if (bit) {
        painter.fillRect(new Rect(x, startY + d * i + 5, w, d - 10), Config.OPERATION_FORE_COLOR);
      }
      painter.print(bit ? 'on' : 'off', x + w / 2, startY + d * (i + 0.5), 'center', 'middle', 'black', '16px sans-serif', w, d);
    }
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (args.focusPoints)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var pt = $__2.value;
        {
          var k = Math.floor((pt.y - y) * 2 / d) / 2;
          if (args.rect.containsPoint(pt)) {
            MathPainter.paintDeferredValueTooltip(painter, x + w, y + k * d, ("Sampled |" + Util.bin(sample, args.gate.height) + "⟩"), ("decimal: |" + sample + "⟩"), "chance: " + (p * 100).toFixed(4) + "%", Config.OPERATION_BACK_COLOR);
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
  }
  function paintSampleDisplay(args) {
    args.painter.fillRect(args.rect, Config.OPERATION_BACK_COLOR);
    var probabilities = args.customStats;
    var noData = probabilities === undefined || probabilities.hasNaN();
    if (noData) {
      args.painter.printParagraph("NaN", args.rect, new Point(0.5, 0.5), 'red');
    } else {
      _paintSampleDisplay_result(args);
    }
    args.painter.strokeRect(args.rect, 'lightgray');
  }
  var SampleDisplayFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("Sample" + span).setSymbol("Sample").setTitle("Sampled Results Display").setBlurb("Shows a random sample of possible measurement outcomes.\nUse controls to see conditional samples.").setStatTexturesMaker(function(ctx) {
      return probabilityStatTexture(ctx.stateTrader.currentTexture, ctx.controlsTexture, ctx.row, span);
    }).setStatPixelDataPostProcessor(function(e) {
      return probabilityPixelsToColumnVector(e, span);
    }).promiseHasNoNetEffectOnStateVectorButStillRequiresDynamicRedraw().setDrawer(GatePainting.makeDisplayDrawer(paintSampleDisplay)).setExtraDisableReasonFinder(function(args) {
      return args.isNested ? "can't\nnest\ndisplays\n(sorry)" : undefined;
    });
  });
  return {get SampleDisplayFamily() {
      return SampleDisplayFamily;
    }};
});
//# sourceURL=src/gates/SampleDisplay.js
;$traceurRuntime.registerModule("src/gates/SpacerGate.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/SpacerGate.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/SpacerGate.js")).Config;
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/SpacerGate.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/SpacerGate.js")).GatePainting;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/gates/SpacerGate.js")).Rect;
  var SpacerGate = new GateBuilder().setSerializedIdAndSymbol("…").setTitle("Spacer").setBlurb("A gate with no effect.").markAsNotInterestedInControls().promiseHasNoNetEffectOnStateVector().setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      var backColor = Config.GATE_FILL_COLOR;
      if (args.isHighlighted) {
        backColor = Config.HIGHLIGHTED_GATE_FILL_COLOR;
      }
      args.painter.fillRect(args.rect, backColor);
      GatePainting.paintOutline(args);
    } else {
      var $__0 = args.rect.center(),
          x = $__0.x,
          y = $__0.y;
      var r = new Rect(x - 14, y - 2, 28, 4);
      args.painter.fillRect(r, Config.BACKGROUND_COLOR_CIRCUIT);
    }
    args.painter.fillCircle(args.rect.center().offsetBy(7, 0), 2, "black");
    args.painter.fillCircle(args.rect.center(), 2, "black");
    args.painter.fillCircle(args.rect.center().offsetBy(-7, 0), 2, "black");
  }).gate;
  return {get SpacerGate() {
      return SpacerGate;
    }};
});
//# sourceURL=src/gates/SpacerGate.js
;$traceurRuntime.registerModule("src/gates/SwapGateHalf.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/SwapGateHalf.js";
  var GateBuilder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/SwapGateHalf.js")).GateBuilder;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/gates/SwapGateHalf.js")).GatePainting;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/SwapGateHalf.js")).Matrix;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/gates/SwapGateHalf.js")).Rect;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/gates/SwapGateHalf.js")).Seq;
  var SwapGateHalf = new GateBuilder().setSerializedIdAndSymbol("Swap").setTitle("Swap Gate [Half]").setBlurb("Swaps the values of two qubits.\n(Place two in the same column.)").setKnownEffectToMatrix(Matrix.square(1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1)).setDrawer(function(args) {
    if (args.isInToolbox || args.isHighlighted) {
      GatePainting.DEFAULT_DRAWER(args);
      return;
    }
    var swapRect = Rect.centeredSquareWithRadius(args.rect.center(), args.rect.w / 6);
    args.painter.strokeLine(swapRect.topLeft(), swapRect.bottomRight());
    args.painter.strokeLine(swapRect.topRight(), swapRect.bottomLeft());
  }).setExtraDisableReasonFinder(function(args) {
    var col = args.innerColumn;
    var swapRows = Seq.range(col.gates.length).filter(function(row) {
      return col.gates[row] === SwapGateHalf;
    });
    var n = swapRows.count();
    if (n === 1) {
      return "need\nother\nswap";
    }
    if (n > 2) {
      return "too\nmany\nswap";
    }
    var affectsMeasured = swapRows.any(function(r) {
      return (args.measuredMask & (1 << r)) !== 0;
    });
    var affectsUnmeasured = swapRows.any(function(r) {
      return (args.measuredMask & (1 << r)) === 0;
    });
    if (affectsMeasured && col.hasCoherentControl(args.measuredMask)) {
      return "no\nremix\n(sorry)";
    }
    if (affectsMeasured && affectsUnmeasured && col.hasControl()) {
      return "no\nremix\n(sorry)";
    }
    return undefined;
  }).gate;
  return {get SwapGateHalf() {
      return SwapGateHalf;
    }};
});
//# sourceURL=src/gates/SwapGateHalf.js
;$traceurRuntime.registerModule("src/gates/VariousXGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/VariousXGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/VariousXGates.js")).Gate;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/VariousXGates.js")).Matrix;
  var VariousXGates = {};
  VariousXGates.X3 = Gate.fromKnownMatrix("X^⅓", Matrix.fromPauliRotation(1 / 6, 0, 0), "X^⅓ Gate", "Principle third root of X.");
  VariousXGates.X3i = Gate.fromKnownMatrix("X^-⅓", Matrix.fromPauliRotation(-1 / 6, 0, 0), "X^-⅓ Gate", "Adjoint third root of X.");
  VariousXGates.X4 = Gate.fromKnownMatrix("X^¼", Matrix.fromPauliRotation(1 / 8, 0, 0), "X^¼ Gate", "Principle fourth root of X.");
  VariousXGates.X4i = Gate.fromKnownMatrix("X^-¼", Matrix.fromPauliRotation(-1 / 8, 0, 0), "X^-¼ Gate", "Adjoint fourth root of X.");
  VariousXGates.X8 = Gate.fromKnownMatrix("X^⅛", Matrix.fromPauliRotation(1 / 16, 0, 0), "X^⅛ Gate", "Principle eighth root of X.");
  VariousXGates.X8i = Gate.fromKnownMatrix("X^-⅛", Matrix.fromPauliRotation(-1 / 16, 0, 0), "X^-⅛ Gate", "Adjoint eighth root of X.");
  VariousXGates.X16 = Gate.fromKnownMatrix("X^⅟₁₆", Matrix.fromPauliRotation(1 / 32, 0, 0), "X^⅟₁₆ Gate", "Principle sixteenth root of X.");
  VariousXGates.X16i = Gate.fromKnownMatrix("X^-⅟₁₆", Matrix.fromPauliRotation(-1 / 32, 0, 0), "X^-⅟₁₆ Gate", "Adjoint sixteenth root of X.");
  VariousXGates.X32 = Gate.fromKnownMatrix("X^⅟₃₂", Matrix.fromPauliRotation(1 / 64, 0, 0), "X^⅟₃₂ Gate", "Principle 32'nd root of X.");
  VariousXGates.X32i = Gate.fromKnownMatrix("X^-⅟₃₂", Matrix.fromPauliRotation(-1 / 64, 0, 0), "X^-⅟₃₂ Gate", "Adjoint 32'nd root of X.");
  VariousXGates.all = [VariousXGates.X3, VariousXGates.X4, VariousXGates.X8, VariousXGates.X16, VariousXGates.X32, VariousXGates.X3i, VariousXGates.X4i, VariousXGates.X8i, VariousXGates.X16i, VariousXGates.X32i];
  return {get VariousXGates() {
      return VariousXGates;
    }};
});
//# sourceURL=src/gates/VariousXGates.js
;$traceurRuntime.registerModule("src/gates/VariousYGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/VariousYGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/VariousYGates.js")).Gate;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/VariousYGates.js")).Matrix;
  var VariousYGates = {};
  VariousYGates.Y3 = Gate.fromKnownMatrix("Y^⅓", Matrix.fromPauliRotation(0, 1 / 6, 0), "Y^⅓ Gate", "Principle third root of Y.");
  VariousYGates.Y3i = Gate.fromKnownMatrix("Y^-⅓", Matrix.fromPauliRotation(0, -1 / 6, 0), "Y^-⅓ Gate", "Adjoint third root of Y.");
  VariousYGates.Y4 = Gate.fromKnownMatrix("Y^¼", Matrix.fromPauliRotation(0, 1 / 8, 0), "Y^¼ Gate", "Principle fourth root of Y.");
  VariousYGates.Y4i = Gate.fromKnownMatrix("Y^-¼", Matrix.fromPauliRotation(0, -1 / 8, 0), "Y^-¼ Gate", "Adjoint fourth root of Y.");
  VariousYGates.Y8 = Gate.fromKnownMatrix("Y^⅛", Matrix.fromPauliRotation(0, 1 / 16, 0), "Y^⅛ Gate", "Principle eighth root of Y.");
  VariousYGates.Y8i = Gate.fromKnownMatrix("Y^-⅛", Matrix.fromPauliRotation(0, -1 / 16, 0), "Y^-⅛ Gate", "Adjoint eighth root of Y.");
  VariousYGates.Y16 = Gate.fromKnownMatrix("Y^⅟₁₆", Matrix.fromPauliRotation(0, 1 / 32, 0), "Y^⅟₁₆ Gate", "Principle sixteenth root of Y.");
  VariousYGates.Y16i = Gate.fromKnownMatrix("Y^-⅟₁₆", Matrix.fromPauliRotation(0, -1 / 32, 0), "Y^-⅟₁₆ Gate", "Adjoint sixteenth root of Y.");
  VariousYGates.Y32 = Gate.fromKnownMatrix("Y^⅟₃₂", Matrix.fromPauliRotation(0, 1 / 64, 0), "Y^⅟₃₂ Gate", "Principle 32'nd root of Y.");
  VariousYGates.Y32i = Gate.fromKnownMatrix("Y^-⅟₃₂", Matrix.fromPauliRotation(0, -1 / 64, 0), "Y^-⅟₃₂ Gate", "Adjoint 32'nd root of Y.");
  VariousYGates.all = [VariousYGates.Y3, VariousYGates.Y4, VariousYGates.Y8, VariousYGates.Y16, VariousYGates.Y32, VariousYGates.Y3i, VariousYGates.Y4i, VariousYGates.Y8i, VariousYGates.Y16i, VariousYGates.Y32i];
  return {get VariousYGates() {
      return VariousYGates;
    }};
});
//# sourceURL=src/gates/VariousYGates.js
;$traceurRuntime.registerModule("src/gates/VariousZGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/VariousZGates.js";
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/VariousZGates.js")).Gate;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/gates/VariousZGates.js")).Matrix;
  var VariousZGates = {};
  VariousZGates.Z3 = Gate.fromKnownMatrix("Z^⅓", Matrix.fromPauliRotation(0, 0, 1 / 6), "Z^⅓ Gate", "Principle third root of Z.");
  VariousZGates.Z3i = Gate.fromKnownMatrix("Z^-⅓", Matrix.fromPauliRotation(0, 0, -1 / 6), "Z^-⅓ Gate", "Adjoint third root of Z.");
  VariousZGates.Z4 = Gate.fromKnownMatrix("Z^¼", Matrix.fromPauliRotation(0, 0, 1 / 8), "Z^¼ Gate", "Principle fourth root of Z.\nAlso known as the 'T' gate.");
  VariousZGates.Z4i = Gate.fromKnownMatrix("Z^-¼", Matrix.fromPauliRotation(0, 0, -1 / 8), "Z^-¼ Gate", "Adjoint fourth root of Z.");
  VariousZGates.Z8 = Gate.fromKnownMatrix("Z^⅛", Matrix.fromPauliRotation(0, 0, 1 / 16), "Z^⅛ Gate", "Principle eighth root of Z.");
  VariousZGates.Z8i = Gate.fromKnownMatrix("Z^-⅛", Matrix.fromPauliRotation(0, 0, -1 / 16), "Z^-⅛ Gate", "Adjoint eighth root of Z.");
  VariousZGates.Z16 = Gate.fromKnownMatrix("Z^⅟₁₆", Matrix.fromPauliRotation(0, 0, 1 / 32), "Z^⅟₁₆ Gate", "Principle 16'th root of Z.");
  VariousZGates.Z16i = Gate.fromKnownMatrix("Z^-⅟₁₆", Matrix.fromPauliRotation(0, 0, -1 / 32), "Z^-⅟₁₆ Gate", "Adjoint 16'th root of Z.");
  VariousZGates.Z32 = Gate.fromKnownMatrix("Z^⅟₃₂", Matrix.fromPauliRotation(0, 0, 1 / 64), "Z^⅟₃₂ Gate", "Principle 32'nd root of Z.");
  VariousZGates.Z64 = Gate.fromKnownMatrix("Z^⅟₆₄", Matrix.fromPauliRotation(0, 0, 1 / 128), "Z^⅟₆₄ Gate", "Principle 64'th root of Z.");
  VariousZGates.Z128 = Gate.fromKnownMatrix("Z^⅟₁₂₈", Matrix.fromPauliRotation(0, 0, 1 / 256), "Z^⅟₁₂₈ Gate", "Principle 128'th root of Z.");
  VariousZGates.all = [VariousZGates.Z3, VariousZGates.Z4, VariousZGates.Z8, VariousZGates.Z16, VariousZGates.Z32, VariousZGates.Z64, VariousZGates.Z128, VariousZGates.Z3i, VariousZGates.Z4i, VariousZGates.Z8i, VariousZGates.Z16i];
  return {get VariousZGates() {
      return VariousZGates;
    }};
});
//# sourceURL=src/gates/VariousZGates.js
;$traceurRuntime.registerModule("src/gates/XorGates.js", [], function() {
  "use strict";
  var __moduleName = "src/gates/XorGates.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/gates/XorGates.js")).Config;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/gates/XorGates.js")).Gate;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/KetShaderUtil.js", "src/gates/XorGates.js")),
      ketArgs = $__4.ketArgs,
      ketShaderPermute = $__4.ketShaderPermute,
      ketInputGateShaderCode = $__4.ketInputGateShaderCode;
  var XorGates = {};
  var XOR_SHADER = ketShaderPermute(ketInputGateShaderCode('A'), ("\n        float srcMask = mod(read_input_A(), span);\n        float bitPos = 1.0;\n        float result = 0.0;\n        for (int i = 0; i < " + Config.MAX_WIRE_COUNT + "; i++) {\n            float srcBit = mod(floor(srcMask/bitPos), 2.0);\n            float dstBit = mod(floor(out_id/bitPos), 2.0);\n            result += (dstBit + srcBit - dstBit * srcBit * 2.0) * bitPos;\n            bitPos *= 2.0;\n        }\n        return result;"));
  XorGates.XorAFamily = Gate.buildFamily(1, 16, function(span, builder) {
    return builder.setSerializedId("^=A" + span).setSymbol("⊕A").setTitle("Xor Gate [input A]").setBlurb("Xors input A into the qubits covered by this gate.").setRequiredContextKeys("Input Range A").setKnownEffectToParametrizedPermutation(function(t, a) {
      return t ^ (a & ((1 << span) - 1));
    }).setActualEffectToShaderProvider(function(ctx) {
      var $__1;
      return ($__1 = XOR_SHADER).withArgs.apply($__1, $traceurRuntime.spread(ketArgs(ctx, span, ['A'])));
    });
  });
  XorGates.all = $traceurRuntime.spread(XorGates.XorAFamily.all);
  return {get XorGates() {
      return XorGates;
    }};
});
//# sourceURL=src/gates/XorGates.js
;$traceurRuntime.registerModule("src/issues.js", [], function() {
  "use strict";
  var __moduleName = "src/issues.js";
  var notifyAboutKnownIssue = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/fallback.js", "src/issues.js")).notifyAboutKnownIssue;
  var canvasCreatedForTesting = document.createElement('canvas');
  var webglContextCreatedForTesting = canvasCreatedForTesting.getContext('webgl') || canvasCreatedForTesting.getContext('experimental-webgl');
  function detectWebGlNotSupported() {
    return webglContextCreatedForTesting === null || webglContextCreatedForTesting === undefined;
  }
  function doDetectIssues() {
    if (detectWebGlNotSupported()) {
      notifyAboutKnownIssue("Can't simulate circuits. Your browser doesn't support WebGL, or has it disabled.", "https://github.com/Strilanc/Quirk/issues/168", [/Computing circuit values failed/, /Error creating WebGL context./]);
    }
  }
  return {
    get doDetectIssues() {
      return doDetectIssues;
    },
    get canvasCreatedForTesting() {
      return canvasCreatedForTesting;
    },
    get webglContextCreatedForTesting() {
      return webglContextCreatedForTesting;
    }
  };
});
//# sourceURL=src/issues.js
;$traceurRuntime.registerModule("src/main.js", [], function() {
  "use strict";
  var __moduleName = "src/main.js";
  $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/browser/Polyfills.js", "src/main.js"));
  var hookErrorHandler = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/fallback.js", "src/main.js")).hookErrorHandler;
  hookErrorHandler();
  var doDetectIssues = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/issues.js", "src/main.js")).doDetectIssues;
  doDetectIssues();
  var CooldownThrottle = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/CooldownThrottle.js", "src/main.js")).CooldownThrottle;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/main.js")).Config;
  var DisplayedInspector = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/DisplayedInspector.js", "src/main.js")).DisplayedInspector;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/Painter.js", "src/main.js")).Painter;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/main.js")).Rect;
  var RestartableRng = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/RestartableRng.js", "src/main.js")).RestartableRng;
  var Revision = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Revision.js", "src/main.js")).Revision;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Serializer.js", "src/main.js")),
      initSerializer = $__10.initSerializer,
      fromJsonText_CircuitDefinition = $__10.fromJsonText_CircuitDefinition;
  var TouchScrollBlocker = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/browser/TouchScrollBlocker.js", "src/main.js")).TouchScrollBlocker;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/main.js")).Util;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglContext.js", "src/main.js")).initializedWglContext;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/browser/MouseWatcher.js", "src/main.js")),
      watchDrags = $__14.watchDrags,
      isMiddleClicking = $__14.isMiddleClicking,
      eventPosRelativeTo = $__14.eventPosRelativeTo;
  var $__15 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Obs.js", "src/main.js")),
      ObservableValue = $__15.ObservableValue,
      ObservableSource = $__15.ObservableSource;
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/run.js", "src/main.js")),
      initRun = $__16.initRun,
      obsRunsIsShowing = $__16.obsRunsIsShowing;
  var $__17 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/exports.js", "src/main.js")),
      initExports = $__17.initExports,
      obsExportsIsShowing = $__17.obsExportsIsShowing;
  var $__18 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/forge.js", "src/main.js")),
      initForge = $__18.initForge,
      obsForgeIsShowing = $__18.obsForgeIsShowing;
  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/menu.js", "src/main.js")),
      initMenu = $__19.initMenu,
      obsMenuIsShowing = $__19.obsMenuIsShowing,
      closeMenu = $__19.closeMenu;
  var initUndoRedo = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/undo.js", "src/main.js")).initUndoRedo;
  var initClear = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/clear.js", "src/main.js")).initClear;
  var initUrlCircuitSync = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/url.js", "src/main.js")).initUrlCircuitSync;
  var initTitleSync = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/title.js", "src/main.js")).initTitleSync;
  var simulate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/sim.js", "src/main.js")).simulate;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/main.js")).GatePainting;
  var GATE_CIRCUIT_DRAWER = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/DisplayedCircuit.js", "src/main.js")).GATE_CIRCUIT_DRAWER;
  initSerializer(GatePainting.LABEL_DRAWER, GatePainting.MATRIX_DRAWER, GATE_CIRCUIT_DRAWER, GatePainting.LOCATION_INDEPENDENT_GATE_DRAWER);
  var canvasDiv = document.getElementById("canvasDiv");
  var canvas = document.getElementById("drawCanvas");
  if (!canvas) {
    throw new Error("Couldn't find 'drawCanvas'");
  }
  canvas.width = canvasDiv.clientWidth;
  canvas.height = window.innerHeight * 0.9;
  var haveLoaded = false;
  var semiStableRng = (function() {
    var target = {cur: new RestartableRng()};
    var cycleRng;
    cycleRng = function() {
      target.cur = new RestartableRng();
      setTimeout(cycleRng, Config.SEMI_STABLE_RANDOM_VALUE_LIFETIME_MILLIS * 0.99);
    };
    cycleRng();
    return target;
  })();
  var inspectorDiv = document.getElementById("inspectorDiv");
  var displayed = new ObservableValue(DisplayedInspector.empty(new Rect(0, 0, canvas.clientWidth, canvas.clientHeight)));
  var revision = Revision.startingAt(displayed.get().snapshot());
  revision.latestActiveCommit().subscribe(function(jsonText) {
    var circuitDef = fromJsonText_CircuitDefinition(jsonText);
    var newInspector = displayed.get().withCircuitDefinition(circuitDef);
    displayed.set(newInspector);
  });
  var desiredCanvasSizeFor = function(curInspector) {
    return {
      w: Math.max(canvasDiv.clientWidth, curInspector.desiredWidth()),
      h: curInspector.desiredHeight()
    };
  };
  var syncArea = function(ins) {
    var size = desiredCanvasSizeFor(ins);
    ins.updateArea(new Rect(0, 0, size.w, size.h));
    return ins;
  };
  displayed.observable().map(function(e) {
    return e.displayedCircuit.circuitDefinition;
  }).whenDifferent(Util.CUSTOM_IS_EQUAL_TO_EQUALITY).subscribe(function() {
    var errDivStyle = document.getElementById('error-div').style;
    errDivStyle.opacity *= 0.9;
    if (errDivStyle.opacity < 0.06) {
      errDivStyle.display = 'None';
    }
  });
  var redrawThrottle;
  var scrollBlocker = new TouchScrollBlocker(canvasDiv);
  var redrawNow = function() {
    if (!haveLoaded) {
      return;
    }
    var shown = syncArea(displayed.get()).previewDrop();
    var stats = simulate(shown.displayedCircuit.circuitDefinition);
    var size = desiredCanvasSizeFor(shown);
    canvas.width = size.w;
    canvas.height = size.h;
    var painter = new Painter(canvas, semiStableRng.cur.restarted());
    shown.updateArea(painter.paintableArea());
    shown.paint(painter, stats);
    painter.paintDeferred();
    displayed.get().hand.paintCursor(painter);
    scrollBlocker.setBlockers(painter.touchBlockers, painter.desiredCursorStyle);
    canvas.style.cursor = painter.desiredCursorStyle || 'auto';
    var dt = displayed.get().stableDuration();
    if (dt < Infinity) {
      window.requestAnimationFrame(function() {
        return redrawThrottle.trigger();
      });
    }
  };
  redrawThrottle = new CooldownThrottle(redrawNow, Config.REDRAW_COOLDOWN_MILLIS, 0.1, true);
  window.addEventListener('resize', function() {
    return redrawThrottle.trigger();
  }, false);
  displayed.observable().subscribe(function() {
    return redrawThrottle.trigger();
  });
  var clickDownGateButtonKey = undefined;
  canvasDiv.addEventListener('click', function(ev) {
    var pt = eventPosRelativeTo(ev, canvasDiv);
    var curInspector = displayed.get();
    if (curInspector.isHandOverButtonKey() !== clickDownGateButtonKey) {
      return;
    }
    var clicked = syncArea(curInspector.withHand(curInspector.hand.withPos(pt))).tryClick();
    if (clicked !== undefined) {
      revision.commit(clicked.snapshot());
    }
  });
  watchDrags(canvasDiv, function(pt, ev) {
    var oldInspector = displayed.get();
    var newHand = oldInspector.hand.withPos(pt);
    var newInspector = syncArea(oldInspector.withHand(newHand));
    clickDownGateButtonKey = newInspector.isHandOverButtonKey();
    if (clickDownGateButtonKey !== undefined) {
      displayed.set(newInspector);
      return;
    }
    newInspector = newInspector.afterGrabbing(ev.shiftKey, ev.ctrlKey);
    if (displayed.get().isEqualTo(newInspector) || !newInspector.hand.isBusy()) {
      return;
    }
    revision.startedWorkingOnCommit();
    displayed.set(syncArea(oldInspector.withHand(newHand).withJustEnoughWires(newInspector.hand, 1)).afterGrabbing(ev.shiftKey, ev.ctrlKey));
    ev.preventDefault();
  }, function(ev) {
    revision.cancelCommitBeingWorkedOn();
    ev.preventDefault();
  }, function(pt, ev) {
    if (!displayed.get().hand.isBusy()) {
      return;
    }
    var newHand = displayed.get().hand.withPos(pt);
    var newInspector = displayed.get().withHand(newHand);
    displayed.set(newInspector);
    ev.preventDefault();
  }, function(pt, ev) {
    if (!displayed.get().hand.isBusy()) {
      return;
    }
    var newHand = displayed.get().hand.withPos(pt);
    var newInspector = syncArea(displayed.get()).withHand(newHand).afterDropping().afterTidyingUp();
    var clearHand = newInspector.hand.withPos(undefined);
    var clearInspector = newInspector.withJustEnoughWires(clearHand, 0);
    revision.commit(clearInspector.snapshot());
    ev.preventDefault();
  });
  canvasDiv.addEventListener('mousedown', function(ev) {
    if (!isMiddleClicking(ev)) {
      return;
    }
    var newHand = displayed.get().hand.withPos(eventPosRelativeTo(ev, canvas));
    var newInspector = syncArea(displayed.get()).withHand(newHand).afterGrabbing(false, false, true).withHand(newHand).afterTidyingUp().withJustEnoughWires(newHand, 0);
    if (!displayed.get().isEqualTo(newInspector)) {
      revision.commit(newInspector.snapshot());
      ev.preventDefault();
    }
  });
  canvasDiv.addEventListener('mousemove', function(ev) {
    if (!displayed.get().hand.isBusy()) {
      var newHand = displayed.get().hand.withPos(eventPosRelativeTo(ev, canvas));
      var newInspector = displayed.get().withHand(newHand);
      displayed.set(newInspector);
    }
  });
  canvasDiv.addEventListener('mouseleave', function() {
    if (!displayed.get().hand.isBusy()) {
      var newHand = displayed.get().hand.withPos(undefined);
      var newInspector = displayed.get().withHand(newHand);
      displayed.set(newInspector);
    }
  });
  var obsIsAnyOverlayShowing = new ObservableSource();
  initUrlCircuitSync(revision);
  initRun(revision, obsIsAnyOverlayShowing.observable());
  initUndoRedo(revision, obsIsAnyOverlayShowing.observable());
  initClear(revision, obsIsAnyOverlayShowing.observable());
  initTitleSync(revision);
  obsForgeIsShowing.zipLatest(obsExportsIsShowing, function(e1, e2) {
    return e1 || e2;
  }).zipLatest(obsMenuIsShowing, function(e1, e2) {
    return e1 || e2;
  }).whenDifferent().subscribe(function(e) {
    obsIsAnyOverlayShowing.send(e);
    canvasDiv.tabIndex = e ? -1 : 0;
  });
  haveLoaded = true;
  setTimeout(function() {
    inspectorDiv.style.display = 'block';
    redrawNow();
    document.getElementById("loading-div").style.display = 'none';
    document.getElementById("close-menu-button").style.display = 'block';
    if (!displayed.get().displayedCircuit.circuitDefinition.isEmpty()) {
      closeMenu();
    }
    try {
      initializedWglContext().onContextRestored = function() {
        return redrawThrottle.trigger();
      };
    } catch (ex) {
      console.error(ex);
    }
  }, 0);
  return {};
});
//# sourceURL=src/main.js
;$traceurRuntime.registerModule("src/math/Axis.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Axis.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/math/Axis.js")).DetailedError;
  var UNICODE_FRACTIONS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/math/Axis.js")).UNICODE_FRACTIONS;
  var parseFormula = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/FormulaParser.js", "src/math/Axis.js")).parseFormula;
  var PARSE_AXIS_TOKEN_MAP = new Map();
  var Axis = function() {
    function Axis(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
    }
    return ($traceurRuntime.createClass)(Axis, {
      toString: function() {
        return (this.x + "X + " + this.y + "Y + " + this.z + "Z");
      },
      isEqualTo: function(other) {
        return other instanceof Axis && other.x === this.x && other.y === this.y && other.z === this.z;
      }
    }, {
      parse: function(text) {
        var result = parseFormula(text, PARSE_AXIS_TOKEN_MAP);
        if (!(result instanceof Axis)) {
          throw new DetailedError("Not an axis.", {
            text: text,
            result: result
          });
        }
        return result;
      },
      classify: function(v) {
        if (typeof v === "number") {
          return false;
        }
        if (v instanceof Axis) {
          return true;
        }
        throw new DetailedError("Not an axis or a number", {v: v});
      },
      op: function(a, b, numNum, axisNum, numAxis, axisAxis) {
        var ca = Axis.classify(a);
        var cb = Axis.classify(b);
        if (ca && cb) {
          return axisAxis(a, b);
        }
        if (!ca && !cb) {
          return numNum(a, b);
        }
        if (ca) {
          return axisNum(a, b);
        }
        return numAxis(a, b);
      },
      times: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return a * b;
        }, function(a, b) {
          return new Axis(a.x * b, a.y * b, a.z * b);
        }, function(a, b) {
          return new Axis(b.x * a, b.y * a, b.z * a);
        }, function(a, b) {
          throw new DetailedError("Can't multiply axes.", {
            a: a,
            b: b
          });
        });
      },
      add: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return a + b;
        }, function(a, b) {
          throw new DetailedError("Can't add axes to numbers.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't add axes to numbers.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          return new Axis(a.x + b.x, a.y + b.y, a.z + b.z);
        });
      },
      negate: function(u) {
        return Axis.classify(u) ? new Axis(-u.x, -u.y, -u.z) : -u;
      },
      subtract: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return a - b;
        }, function(a, b) {
          throw new DetailedError("Can't subtract axes and numbers.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't subtract axes and numbers.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          return new Axis(a.x - b.x, a.y - b.y, a.z - b.z);
        });
      },
      divide: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return a / b;
        }, function(a, b) {
          return new Axis(a.x / b, a.y / b, a.z / b);
        }, function(a, b) {
          throw new DetailedError("Can't divide by an axis.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't divide by an axis.", {
            a: a,
            b: b
          });
        });
      },
      raisedTo: function(u, v) {
        return Axis.op(u, v, function(a, b) {
          return Math.pow(a, b);
        }, function(a, b) {
          throw new DetailedError("Can't raise an axis to a power.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't raise to an axis power.", {
            a: a,
            b: b
          });
        }, function(a, b) {
          throw new DetailedError("Can't raise to an axis power.", {
            a: a,
            b: b
          });
        });
      }
    });
  }();
  PARSE_AXIS_TOKEN_MAP.set("x", new Axis(1, 0, 0));
  PARSE_AXIS_TOKEN_MAP.set("y", new Axis(0, 1, 0));
  PARSE_AXIS_TOKEN_MAP.set("z", new Axis(0, 0, 1));
  PARSE_AXIS_TOKEN_MAP.set("(", "(");
  PARSE_AXIS_TOKEN_MAP.set(")", ")");
  var $__5 = true;
  var $__6 = false;
  var $__7 = undefined;
  try {
    for (var $__3 = void 0,
        $__2 = (UNICODE_FRACTIONS)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
      var $__9 = $__3.value,
          character = $__9.character,
          value = $__9.value;
      {
        PARSE_AXIS_TOKEN_MAP.set(character, value);
      }
    }
  } catch ($__8) {
    $__6 = true;
    $__7 = $__8;
  } finally {
    try {
      if (!$__5 && $__2.return != null) {
        $__2.return();
      }
    } finally {
      if ($__6) {
        throw $__7;
      }
    }
  }
  PARSE_AXIS_TOKEN_MAP.set("sqrt", {
    unary_action: function(e) {
      return Axis.raisedTo(e, 0.5);
    },
    priority: 4
  });
  PARSE_AXIS_TOKEN_MAP.set("^", {
    binary_action: Axis.raisedTo,
    priority: 3
  });
  PARSE_AXIS_TOKEN_MAP.set("*", {
    binary_action: Axis.times,
    priority: 2
  });
  PARSE_AXIS_TOKEN_MAP.set("/", {
    binary_action: Axis.divide,
    priority: 2
  });
  PARSE_AXIS_TOKEN_MAP.set("-", {
    unary_action: Axis.negate,
    binary_action: Axis.subtract,
    priority: 1
  });
  PARSE_AXIS_TOKEN_MAP.set("+", {
    unary_action: function(e) {
      return e;
    },
    binary_action: Axis.add,
    priority: 1
  });
  PARSE_AXIS_TOKEN_MAP.set("√", PARSE_AXIS_TOKEN_MAP.get("sqrt"));
  return {get Axis() {
      return Axis;
    }};
});
//# sourceURL=src/math/Axis.js
;$traceurRuntime.registerModule("src/math/Complex.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Complex.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/math/Complex.js")).DetailedError;
  var $__13 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/math/Complex.js")),
      Format = $__13.Format,
      UNICODE_FRACTIONS = $__13.UNICODE_FRACTIONS;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/math/Complex.js")).Util;
  var parseFormula = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/FormulaParser.js", "src/math/Complex.js")).parseFormula;
  var PARSE_COMPLEX_TOKEN_MAP = new Map();
  var Complex = function() {
    function Complex(real, imag) {
      this.real = real;
      this.imag = imag;
    }
    return ($traceurRuntime.createClass)(Complex, {
      isEqualTo: function(other) {
        if (other instanceof Complex) {
          return this.real === other.real && this.imag === other.imag;
        }
        if (typeof other === "number") {
          return this.real === other && this.imag === 0;
        }
        return false;
      },
      isApproximatelyEqualTo: function(other, epsilon) {
        if (other instanceof Complex || typeof other === "number") {
          var d = this.minus(Complex.from(other));
          return Math.abs(d.real) <= epsilon && Math.abs(d.imag) <= epsilon && d.abs() <= epsilon;
        }
        return false;
      },
      toString: function(format) {
        format = format || Format.EXACT;
        return format.allowAbbreviation ? this._toString_allowSingleValue(format) : this._toString_bothValues(format);
      },
      _toString_allowSingleValue: function(format) {
        if (Math.abs(this.imag) <= format.maxAbbreviationError) {
          return format.formatFloat(this.real);
        }
        if (Math.abs(this.real) <= format.maxAbbreviationError) {
          if (Math.abs(this.imag - 1) <= format.maxAbbreviationError) {
            return "i";
          }
          if (Math.abs(this.imag + 1) <= format.maxAbbreviationError) {
            return "-i";
          }
          return format.formatFloat(this.imag) + "i";
        }
        return this._toString_bothValues(format);
      },
      _toString_bothValues: function(format) {
        var separator = this.imag >= 0 ? "+" : "-";
        var imagFactor = format.allowAbbreviation && Math.abs(Math.abs(this.imag) - 1) <= format.maxAbbreviationError ? "" : format.formatFloat(Math.abs(this.imag));
        var prefix = format.allowAbbreviation || format.fixedDigits === undefined || this.real < 0 ? "" : "+";
        return prefix + format.formatFloat(this.real) + separator + imagFactor + "i";
      },
      norm2: function() {
        return this.real * this.real + this.imag * this.imag;
      },
      abs: function() {
        return Math.sqrt(this.norm2());
      },
      conjugate: function() {
        return new Complex(this.real, -this.imag);
      },
      neg: function() {
        return new Complex(-this.real, -this.imag);
      },
      phase: function() {
        return Math.atan2(this.imag, this.real);
      },
      unit: function() {
        var m = this.norm2();
        if (m < 0.00001) {
          return Complex.polar(1, this.phase());
        }
        return this.dividedBy(Math.sqrt(m));
      },
      plus: function(v) {
        var c = Complex.from(v);
        return new Complex(this.real + c.real, this.imag + c.imag);
      },
      minus: function(v) {
        var c = Complex.from(v);
        return new Complex(this.real - c.real, this.imag - c.imag);
      },
      times: function(v) {
        var c = Complex.from(v);
        return new Complex(this.real * c.real - this.imag * c.imag, this.real * c.imag + this.imag * c.real);
      },
      dividedBy: function(v) {
        var c = Complex.from(v);
        var d = c.norm2();
        if (d === 0) {
          throw new Error("Division by Zero");
        }
        var n = this.times(c.conjugate());
        return new Complex(n.real / d, n.imag / d);
      },
      sqrts: function() {
        var $__10,
            $__11;
        var $__9 = [this.real, this.imag],
            r = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
            i = ($__11 = $__10.next()).done ? void 0 : $__11.value;
        var m = Math.sqrt(Math.sqrt(r * r + i * i));
        if (m === 0) {
          return [Complex.ZERO];
        }
        if (i === 0 && r < 0) {
          return [new Complex(0, m), new Complex(0, -m)];
        }
        var a = this.phase() / 2;
        var c = Complex.polar(m, a);
        return [c, c.times(-1)];
      },
      exp: function() {
        return Complex.polar(Math.exp(this.real), this.imag);
      },
      ln: function() {
        return new Complex(Math.log(this.abs()), this.phase());
      },
      raisedTo: function(exponent) {
        if (exponent === 0.5 && this.imag === 0 && this.real >= 0) {
          return new Complex(Math.sqrt(this.real), 0);
        }
        if (Complex.ZERO.isEqualTo(exponent)) {
          return Complex.ONE;
        }
        if (this.isEqualTo(Complex.ZERO)) {
          return Complex.ZERO;
        }
        return this.ln().times(Complex.from(exponent)).exp();
      }
    }, {
      from: function(v) {
        if (v instanceof Complex) {
          return v;
        }
        if (typeof v === "number") {
          return new Complex(v, 0);
        }
        throw new DetailedError("Unrecognized value type.", {v: v});
      },
      polar: function(magnitude, phase) {
        var $__10,
            $__11;
        var $__9 = Util.snappedCosSin(phase),
            cos = ($__10 = $__9[Symbol.iterator](), ($__11 = $__10.next()).done ? void 0 : $__11.value),
            sin = ($__11 = $__10.next()).done ? void 0 : $__11.value;
        return new Complex(magnitude * cos, magnitude * sin);
      },
      realPartOf: function(v) {
        if (v instanceof Complex) {
          return v.real;
        }
        if (typeof v === "number") {
          return v;
        }
        throw new DetailedError("Unrecognized value type.", {v: v});
      },
      imagPartOf: function(v) {
        if (v instanceof Complex) {
          return v.imag;
        }
        if (typeof v === "number") {
          return 0;
        }
        throw new DetailedError("Unrecognized value type.", {v: v});
      },
      parse: function(text) {
        return Complex.from(parseFormula(text, PARSE_COMPLEX_TOKEN_MAP));
      },
      rootsOfQuadratic: function(a, b, c) {
        a = Complex.from(a);
        b = Complex.from(b);
        c = Complex.from(c);
        if (a.isEqualTo(0)) {
          if (!b.isEqualTo(0)) {
            return [c.times(-1).dividedBy(b)];
          }
          if (!c.isEqualTo(0)) {
            return [];
          }
          throw Error("Degenerate");
        }
        var difs = b.times(b).minus(a.times(c).times(4)).sqrts();
        var mid = b.times(-1);
        var denom = a.times(2);
        return difs.map(function(d) {
          return mid.minus(d).dividedBy(denom);
        });
      }
    });
  }();
  Complex.ZERO = new Complex(0, 0);
  Complex.ONE = new Complex(1, 0);
  Complex.I = new Complex(0, 1);
  PARSE_COMPLEX_TOKEN_MAP.set("i", Complex.I);
  PARSE_COMPLEX_TOKEN_MAP.set("e", Complex.from(Math.E));
  PARSE_COMPLEX_TOKEN_MAP.set("pi", Complex.from(Math.PI));
  PARSE_COMPLEX_TOKEN_MAP.set("(", "(");
  PARSE_COMPLEX_TOKEN_MAP.set(")", ")");
  var $__5 = true;
  var $__6 = false;
  var $__7 = undefined;
  try {
    for (var $__3 = void 0,
        $__2 = (UNICODE_FRACTIONS)[Symbol.iterator](); !($__5 = ($__3 = $__2.next()).done); $__5 = true) {
      var $__9 = $__3.value,
          character = $__9.character,
          value = $__9.value;
      {
        PARSE_COMPLEX_TOKEN_MAP.set(character, value);
      }
    }
  } catch ($__8) {
    $__6 = true;
    $__7 = $__8;
  } finally {
    try {
      if (!$__5 && $__2.return != null) {
        $__2.return();
      }
    } finally {
      if ($__6) {
        throw $__7;
      }
    }
  }
  PARSE_COMPLEX_TOKEN_MAP.set("sqrt", {
    unary_action: function(e) {
      return Complex.from(e).raisedTo(0.5);
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP.set("exp", {
    unary_action: function(e) {
      return Complex.from(e).exp();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP.set("ln", {
    unary_action: function(e) {
      return Complex.from(e).ln();
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP.set("cos", {
    unary_action: function(e) {
      var z = Complex.from(e).times(new Complex(0, Math.PI / 180));
      return z.exp().plus(z.neg().exp()).times(0.5);
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP.set("sin", {
    unary_action: function(e) {
      var z = Complex.from(e).times(new Complex(0, Math.PI / 180));
      return z.exp().minus(z.neg().exp()).dividedBy(new Complex(0, 2));
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP.set("asin", {
    unary_action: function(e) {
      if (Complex.imagPartOf(e) !== 0) {
        throw new DetailedError("asin input out of range", {e: e});
      }
      return Complex.from(Math.asin(Complex.realPartOf(e)) * 180 / Math.PI);
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP.set("acos", {
    unary_action: function(e) {
      if (Complex.imagPartOf(e) !== 0) {
        throw new DetailedError("acos input out of range", {e: e});
      }
      return Complex.from(Math.acos(Complex.realPartOf(e)) * 180 / Math.PI);
    },
    priority: 4
  });
  PARSE_COMPLEX_TOKEN_MAP.set("^", {
    binary_action: function(a, b) {
      return Complex.from(a).raisedTo(b);
    },
    priority: 3
  });
  PARSE_COMPLEX_TOKEN_MAP.set("*", {
    binary_action: function(a, b) {
      return Complex.from(a).times(b);
    },
    priority: 2
  });
  PARSE_COMPLEX_TOKEN_MAP.set("/", {
    binary_action: function(a, b) {
      return Complex.from(a).dividedBy(b);
    },
    priority: 2
  });
  PARSE_COMPLEX_TOKEN_MAP.set("-", {
    unary_action: function(e) {
      return Complex.from(e).neg();
    },
    binary_action: function(a, b) {
      return Complex.from(a).minus(b);
    },
    priority: 1
  });
  PARSE_COMPLEX_TOKEN_MAP.set("+", {
    unary_action: function(e) {
      return e;
    },
    binary_action: function(a, b) {
      return Complex.from(a).plus(b);
    },
    priority: 1
  });
  PARSE_COMPLEX_TOKEN_MAP.set("√", PARSE_COMPLEX_TOKEN_MAP.get("sqrt"));
  PARSE_COMPLEX_TOKEN_MAP.set("arccos", PARSE_COMPLEX_TOKEN_MAP.get("acos"));
  PARSE_COMPLEX_TOKEN_MAP.set("arcsin", PARSE_COMPLEX_TOKEN_MAP.get("asin"));
  return {get Complex() {
      return Complex;
    }};
});
//# sourceURL=src/math/Complex.js
;$traceurRuntime.registerModule("src/math/FormulaParser.js", [], function() {
  "use strict";
  var __moduleName = "src/math/FormulaParser.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/math/FormulaParser.js")).DetailedError;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/math/FormulaParser.js")).seq;
  function _mergeScientificFloatTokens(tokens) {
    tokens = $traceurRuntime.spread(tokens);
    for (var i = tokens.indexOf('e', 1); i !== -1; i = tokens.indexOf('e', i + 1)) {
      var s = i - 1;
      var e = i + 1;
      if (!tokens[s].match(/[0-9]/)) {
        continue;
      }
      if ((tokens[e] + '').match(/[+-]/)) {
        e += 1;
      }
      if ((tokens[e] + '').match(/[0-9]/)) {
        e += 1;
        tokens.splice(s, e - s, tokens.slice(s, e).join(''));
        i -= 1;
      }
    }
    return tokens;
  }
  function _tokenize(text) {
    var tokens = seq(text.toLowerCase().split(/\s/)).flatMap(function(part) {
      return seq(part).segmentBy(function(e) {
        if (e.trim() === '') {
          return " ";
        }
        if (e.match(/[\.0-9]/)) {
          return "#";
        }
        if (e.match(/[_a-z]/)) {
          return "a";
        }
        return NaN;
      }).map(function(e) {
        return e.join('');
      });
    }).filter(function(e) {
      return e.trim() !== '';
    }).toArray();
    return _mergeScientificFloatTokens(tokens);
  }
  function _translate_token(token, tokenMap) {
    if (token.match(/[0-9]+(\.[0-9]+)?/)) {
      return parseFloat(token);
    }
    if (tokenMap.has(token)) {
      return tokenMap.get(token);
    }
    throw new DetailedError("Unrecognized token", {token: token});
  }
  function parseFormula(text, tokenMap) {
    var tokens = _tokenize(text).map(function(e) {
      return _translate_token(e, tokenMap);
    });
    if (tokens.length > 0 && tokens[tokens.length - 1].priority !== undefined) {
      tokens = tokens.slice(0, tokens.length - 1);
    }
    var ops = [];
    var vals = [];
    var isValidEndToken = function(token) {
      return token !== "(" && token.priority === undefined;
    };
    var isValidEndState = function() {
      return vals.length === 1 && ops.length === 0;
    };
    var apply = function(op) {
      if (op === "(") {
        throw new DetailedError("Bad expression: unmatched '('", {text: text});
      }
      if (vals.length < 2) {
        throw new DetailedError("Bad expression: operated on nothing", {text: text});
      }
      var b = vals.pop();
      var a = vals.pop();
      vals.push(op.f(a, b));
    };
    var closeParen = function() {
      while (true) {
        if (ops.length === 0) {
          throw new DetailedError("Bad expression: unmatched ')'", {text: text});
        }
        var op = ops.pop();
        if (op === "(") {
          break;
        }
        apply(op);
      }
    };
    var burnOps = function(w) {
      while (ops.length > 0 && vals.length >= 2 && vals[vals.length - 1] !== undefined) {
        var top = ops[ops.length - 1];
        if (top.w === undefined || top.w < w) {
          break;
        }
        apply(ops.pop());
      }
    };
    var feedOp = function(couldBeBinary, token) {
      var mul = tokenMap.get("*");
      if (couldBeBinary && token.binary_action === undefined && token !== ")") {
        burnOps(mul.priority);
        ops.push({
          f: mul.binary_action,
          w: mul.priority
        });
      }
      if (couldBeBinary && token.binary_action !== undefined) {
        burnOps(token.priority);
        ops.push({
          f: token.binary_action,
          w: token.priority
        });
      } else if (token.unary_action !== undefined) {
        burnOps(token.priority);
        vals.push(undefined);
        ops.push({
          f: function(a, b) {
            return token.unary_action(b);
          },
          w: Infinity
        });
      } else if (token.binary_action !== undefined) {
        throw new DetailedError("Bad expression: binary op in bad spot", {text: text});
      }
    };
    var wasValidEndToken = false;
    var $__4 = true;
    var $__5 = false;
    var $__6 = undefined;
    try {
      for (var $__2 = void 0,
          $__1 = (tokens)[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
        var token = $__2.value;
        {
          feedOp(wasValidEndToken, token);
          wasValidEndToken = isValidEndToken(token);
          if (token === "(") {
            ops.push("(");
          } else if (token === ")") {
            closeParen();
          } else if (wasValidEndToken) {
            vals.push(token);
          }
        }
      }
    } catch ($__7) {
      $__5 = true;
      $__6 = $__7;
    } finally {
      try {
        if (!$__4 && $__1.return != null) {
          $__1.return();
        }
      } finally {
        if ($__5) {
          throw $__6;
        }
      }
    }
    burnOps(-Infinity);
    if (!isValidEndState()) {
      throw new DetailedError("Incomplete expression", {text: text});
    }
    return vals[0];
  }
  return {get parseFormula() {
      return parseFormula;
    }};
});
//# sourceURL=src/math/FormulaParser.js
;$traceurRuntime.registerModule("src/math/Matrix.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Matrix.js";
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/math/Matrix.js")).Complex;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/math/Matrix.js")).DetailedError;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/math/Matrix.js")).Format;
  var $__35 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/math/Matrix.js")),
      seq = $__35.seq,
      Seq = $__35.Seq;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/math/Matrix.js")).Util;
  var Matrix = function() {
    function Matrix(width, height, buffer) {
      if (width * height * 2 !== buffer.length) {
        throw new DetailedError("width*height*2 !== buffer.length", {
          width: width,
          height: height,
          len: buffer.length
        });
      }
      this._width = width;
      this._height = height;
      this._buffer = buffer;
    }
    return ($traceurRuntime.createClass)(Matrix, {
      cell: function(col, row) {
        if (col < 0 || row < 0 || col >= this._width || row >= this._height) {
          throw new DetailedError("Cell out of range", {
            col: col,
            row: row,
            width: this._width,
            height: this._height
          });
        }
        var i = (this._width * row + col) * 2;
        return new Complex(this._buffer[i], this._buffer[i + 1]);
      },
      rawBuffer: function() {
        return this._buffer;
      },
      rows: function() {
        var $__2 = this;
        return Seq.range(this._height).map(function(row) {
          return Seq.range($__2._width).map(function(col) {
            return $__2.cell(col, row);
          }).toArray();
        }).toArray();
      },
      isEqualTo: function(obj) {
        var $__2 = this;
        if (this === obj) {
          return true;
        }
        if (!(obj instanceof Matrix)) {
          return false;
        }
        var other = obj;
        return this._width === other._width && this._height === other._height && Seq.range(this._buffer.length).every(function(i) {
          return $__2._buffer[i] === other._buffer[i];
        });
      },
      isApproximatelyEqualTo: function(other, epsilon) {
        return other instanceof Matrix && this._width === other._width && this._height === other._height && Math.sqrt(this.minus(other).norm2()) <= epsilon;
      },
      toString: function() {
        var format = arguments[0] !== (void 0) ? arguments[0] : Format.EXACT;
        var data = this.rows().map(function(row) {
          return row.map(function(e) {
            return e.toString(format);
          }).join(format.itemSeparator);
        }).join("}" + format.itemSeparator + "{");
        return "{[" + data + "]}";
      },
      width: function() {
        return this._width;
      },
      height: function() {
        return this._height;
      },
      isUnitary: function(epsilon) {
        var n = this.width();
        if (this.height() !== n) {
          return false;
        }
        return this.times(this.adjoint()).isApproximatelyEqualTo(Matrix.identity(n), epsilon);
      },
      isLowerTriangular: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        for (var r = 0; r < this._height; r++) {
          for (var c = r + 1; c < this._width; c++) {
            var k = (r * this._width + c) * 2;
            var v1 = this._buffer[k];
            var v2 = this._buffer[k + 1];
            if (isNaN(v1) || isNaN(v2) || v1 * v1 + v2 * v2 > epsilon * epsilon) {
              return false;
            }
          }
        }
        return true;
      },
      isUpperTriangular: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        for (var r = 0; r < this._height; r++) {
          for (var c = 0; c < r && c < this._width; c++) {
            var k = (r * this._width + c) * 2;
            var v1 = this._buffer[k];
            var v2 = this._buffer[k + 1];
            if (isNaN(v1) || isNaN(v2) || v1 * v1 + v2 * v2 > epsilon * epsilon) {
              return false;
            }
          }
        }
        return true;
      },
      isPhasedPermutation: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        if (this._width !== this._height) {
          return false;
        }
        var n = this._width;
        var colCounts = new Uint32Array(n);
        var rowCounts = new Uint32Array(n);
        for (var col = 0; col < n; col++) {
          for (var row = 0; row < n; row++) {
            var i = (row * n + col) * 2;
            var m = Math.max(Math.abs(this._buffer[i]), Math.abs(this._buffer[i + 1]));
            if (isNaN(m) || m > epsilon) {
              colCounts[col] += 1;
              rowCounts[row] += 1;
            }
          }
        }
        return seq(colCounts).concat(rowCounts).every(function(e) {
          return e <= 1;
        });
      },
      isApproximatelyHermitian: function(epsilon) {
        if (this._width !== this._height) {
          return false;
        }
        for (var c = 0; c < this._width; c++) {
          for (var r = 0; r < this._height; r++) {
            var i = (this._width * r + c) * 2;
            var j = (this._width * c + r) * 2;
            if (Math.abs(this._buffer[i] - this._buffer[j]) > epsilon) {
              return false;
            }
            if (Math.abs(this._buffer[i + 1] + this._buffer[j + 1]) > epsilon) {
              return false;
            }
          }
        }
        return true;
      },
      isIdentity: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        if (this._width !== this._height) {
          return false;
        }
        for (var c = 0; c < this._width; c++) {
          for (var r = 0; r < this._height; r++) {
            var i = (this._width * r + c) * 2;
            var dr = Math.abs(this._buffer[i] - (r === c ? 1 : 0));
            var di = Math.abs(this._buffer[i + 1]);
            if (Math.max(dr, di) > epsilon) {
              return false;
            }
          }
        }
        return !this.hasNaN();
      },
      isScaler: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        if (this._width !== this._height) {
          return false;
        }
        var sr = this._buffer[0];
        var si = this._buffer[1];
        for (var c = 0; c < this._width; c++) {
          for (var r = 0; r < this._height; r++) {
            var i = (this._width * r + c) * 2;
            var dr = Math.abs(this._buffer[i] - (r === c ? sr : 0));
            var di = Math.abs(this._buffer[i + 1] - (r === c ? si : 0));
            if (Math.max(dr, di) > epsilon) {
              return false;
            }
          }
        }
        return !this.hasNaN();
      },
      hasNaN: function() {
        for (var i = 0; i < this._buffer.length; i++) {
          if (isNaN(this._buffer[i])) {
            return true;
          }
        }
        return false;
      },
      isDiagonal: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        for (var c = 0; c < this._width; c++) {
          for (var r = 0; r < this._height; r++) {
            if (r === c) {
              continue;
            }
            var k = (this._width * r + c) * 2;
            var dr = Math.abs(this._buffer[k]);
            var di = Math.abs(this._buffer[k + 1]);
            var d = Math.max(dr, di);
            if (isNaN(d) || d > epsilon) {
              return false;
            }
          }
        }
        return this._width === this._height;
      },
      adjoint: function() {
        var w = this._height;
        var h = this._width;
        var newBuf = new Float64Array(w * h * 2);
        for (var r = 0; r < h; r++) {
          for (var c = 0; c < w; c++) {
            var kIn = (c * this._width + r) * 2;
            var kOut = (r * w + c) * 2;
            newBuf[kOut] = this._buffer[kIn];
            newBuf[kOut + 1] = -this._buffer[kIn + 1];
          }
        }
        return new Matrix(w, h, newBuf);
      },
      transpose: function() {
        var w = this._height;
        var h = this._width;
        var newBuf = new Float64Array(w * h * 2);
        for (var r = 0; r < h; r++) {
          for (var c = 0; c < w; c++) {
            var kIn = (c * this._width + r) * 2;
            var kOut = (r * w + c) * 2;
            newBuf[kOut] = this._buffer[kIn];
            newBuf[kOut + 1] = this._buffer[kIn + 1];
          }
        }
        return new Matrix(w, h, newBuf);
      },
      trace: function() {
        var total_r = 0;
        var total_i = 0;
        var d = this._width * 2 + 2;
        for (var i = 0; i < this._buffer.length; i += d) {
          total_r += this._buffer[i];
          total_i += this._buffer[i + 1];
        }
        return new Complex(total_r, total_i);
      },
      _timesScalar: function(v) {
        var newBuffer = new Float64Array(this._buffer.length);
        var sr = Complex.realPartOf(v);
        var si = Complex.imagPartOf(v);
        for (var i = 0; i < newBuffer.length; i += 2) {
          var vr = this._buffer[i];
          var vi = this._buffer[i + 1];
          newBuffer[i] = vr * sr - vi * si;
          newBuffer[i + 1] = vr * si + vi * sr;
        }
        return new Matrix(this._width, this._height, newBuffer);
      },
      plus: function(other) {
        var $__20 = this,
            w = $__20._width,
            h = $__20._height,
            b1 = $__20._buffer;
        var b2 = other._buffer;
        Util.need(other._width === w && other._height === h, "Matrix.plus: compatible sizes");
        var newBuffer = new Float64Array(this._buffer.length);
        for (var i = 0; i < newBuffer.length; i++) {
          newBuffer[i] = b1[i] + b2[i];
        }
        return new Matrix(w, h, newBuffer);
      },
      minus: function(other) {
        var $__20 = this,
            w = $__20._width,
            h = $__20._height,
            b1 = $__20._buffer;
        var b2 = other._buffer;
        Util.need(other._width === w && other._height === h, "Matrix.minus: compatible sizes");
        var newBuffer = new Float64Array(this._buffer.length);
        for (var i = 0; i < newBuffer.length; i++) {
          newBuffer[i] = b1[i] - b2[i];
        }
        return new Matrix(w, h, newBuffer);
      },
      _timesMatrix: function(other) {
        if (this._width !== other._height) {
          throw new DetailedError("Incompatible sizes.", {
            'this': this,
            other: other
          });
        }
        var w = other._width;
        var h = this._height;
        var n = this._width;
        var newBuffer = new Float64Array(w * h * 2);
        for (var r = 0; r < h; r++) {
          for (var c = 0; c < w; c++) {
            var k3 = (r * w + c) * 2;
            for (var k = 0; k < n; k++) {
              var k1 = (r * n + k) * 2;
              var k2 = (k * w + c) * 2;
              var r1 = this._buffer[k1];
              var i1 = this._buffer[k1 + 1];
              var r2 = other._buffer[k2];
              var i2 = other._buffer[k2 + 1];
              var r3 = r1 * r2 - i1 * i2;
              var i3 = r1 * i2 + r2 * i1;
              newBuffer[k3] += r3;
              newBuffer[k3 + 1] += i3;
            }
          }
        }
        return new Matrix(w, h, newBuffer);
      },
      times: function(other) {
        return other instanceof Matrix ? this._timesMatrix(other) : this._timesScalar(other);
      },
      expandedForQubitInRegister: function(targetQubitOffset, registerSize, controls) {
        var used = Math.round(Math.log2(this._width));
        var result = Matrix.identity(1 << (registerSize - targetQubitOffset - used)).tensorProduct(this).tensorProduct(Matrix.identity(1 << targetQubitOffset))._clone();
        for (var c = 0; c < result._width; c++) {
          for (var r = 0; r < result._height; r++) {
            if (!controls.allowsState(c) || !controls.allowsState(r)) {
              var k = 2 * (c + r * result._width);
              result._buffer[k] = c === r ? 1 : 0;
              result._buffer[k + 1] = 0;
            }
          }
        }
        return result;
      },
      applyToStateVectorAtQubitWithControls: function(stateVector, qubitIndex, controls) {
        var chunkSize = this._width * 2;
        var chunkBuf = stateVector._buffer.slice(0, chunkSize);
        var strideLength = 2 << qubitIndex;
        var strideChunkSize = strideLength * chunkSize >> 1;
        var resultBuf = stateVector._buffer.slice();
        for (var strideChunkStart = 0; strideChunkStart < resultBuf.length; strideChunkStart += strideChunkSize) {
          for (var strideOffset = 0; strideOffset < strideLength; strideOffset += 2) {
            if (!controls.allowsState((strideChunkStart | strideOffset) >> 1)) {
              continue;
            }
            var k = strideChunkStart + strideOffset;
            for (var i = 0; i < chunkBuf.length; i += 2) {
              chunkBuf[i] = stateVector._buffer[k];
              chunkBuf[i + 1] = stateVector._buffer[k + 1];
              k += strideLength;
            }
            var transformedChunk = this.times(new Matrix(1, chunkBuf.length >> 1, chunkBuf));
            k = strideChunkStart + strideOffset;
            for (var i$__30 = 0; i$__30 < chunkBuf.length; i$__30 += 2) {
              resultBuf[k] = transformedChunk._buffer[i$__30];
              resultBuf[k + 1] = transformedChunk._buffer[i$__30 + 1];
              k += strideLength;
            }
          }
        }
        return new Matrix(1, stateVector.height(), resultBuf);
      },
      norm2: function() {
        var t = 0;
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this._buffer)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var e = $__4.value;
            {
              t += e * e;
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        return t;
      },
      tensorProduct: function(other) {
        var w1 = this._width;
        var h1 = this._height;
        var w2 = other._width;
        var h2 = other._height;
        var w = w1 * w2;
        var h = h1 * h2;
        var newBuffer = new Float64Array(w * h * 2);
        for (var r1 = 0; r1 < h1; r1++) {
          for (var r2 = 0; r2 < h2; r2++) {
            for (var c1 = 0; c1 < w1; c1++) {
              for (var c2 = 0; c2 < w2; c2++) {
                var k1 = (r1 * w1 + c1) * 2;
                var k2 = (r2 * w2 + c2) * 2;
                var k3 = ((r1 * h2 + r2) * w + (c1 * w2 + c2)) * 2;
                var cr1 = this._buffer[k1];
                var ci1 = this._buffer[k1 + 1];
                var cr2 = other._buffer[k2];
                var ci2 = other._buffer[k2 + 1];
                var cr3 = cr1 * cr2 - ci1 * ci2;
                var ci3 = cr1 * ci2 + ci1 * cr2;
                newBuffer[k3] = cr3;
                newBuffer[k3 + 1] = ci3;
              }
            }
          }
        }
        return new Matrix(w, h, newBuffer);
      },
      timesQubitOperation: function(operation2x2, qubitIndex, controlMask, desiredValueMask) {
        var $__22,
            $__23;
        Util.need((controlMask & (1 << qubitIndex)) === 0, "Matrix.timesQubitOperation: self-controlled");
        Util.need(operation2x2._width === 2 && operation2x2._height === 2, "Matrix.timesQubitOperation: not 2x2");
        var $__20 = this,
            w = $__20._width,
            h = $__20._height,
            old = $__20._buffer;
        var $__21 = operation2x2._buffer,
            ar = ($__22 = $__21[Symbol.iterator](), ($__23 = $__22.next()).done ? void 0 : $__23.value),
            ai = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            br = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            bi = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            cr = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            ci = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            dr = ($__23 = $__22.next()).done ? void 0 : $__23.value,
            di = ($__23 = $__22.next()).done ? void 0 : $__23.value;
        Util.need(h >= (2 << qubitIndex), "Matrix.timesQubitOperation: qubit index out of range");
        var buf = new Float64Array(old);
        var i = 0;
        for (var r = 0; r < h; r++) {
          var isControlled = ((controlMask & r) ^ desiredValueMask) !== 0;
          var qubitVal = (r & (1 << qubitIndex)) !== 0;
          for (var c = 0; c < w; c++) {
            if (!isControlled && !qubitVal) {
              var j = i + (1 << qubitIndex) * 2 * w;
              var xr = buf[i];
              var xi = buf[i + 1];
              var yr = buf[j];
              var yi = buf[j + 1];
              buf[i] = xr * ar - xi * ai + yr * br - yi * bi;
              buf[i + 1] = xr * ai + xi * ar + yr * bi + yi * br;
              buf[j] = xr * cr - xi * ci + yr * dr - yi * di;
              buf[j + 1] = xr * ci + xi * cr + yr * di + yi * dr;
            }
            i += 2;
          }
        }
        return new Matrix(w, h, buf);
      },
      tensorPower: function(exponent) {
        if (!Number.isInteger(exponent) || exponent < 0) {
          throw new DetailedError("Bad exponent", {exponent: exponent});
        }
        var t = Matrix.identity(1);
        var p = this;
        for (var m = 1; m <= exponent; m *= 2) {
          if ((m & exponent) !== 0) {
            t = t.tensorProduct(p);
          }
          p = p.tensorProduct(p);
        }
        return t;
      },
      transformRealAndImagComponentsWith: function(func) {
        var buf = this._buffer.slice();
        for (var i = 0; i < buf.length; i++) {
          buf[i] = func(buf[i]);
        }
        return new Matrix(this._width, this._height, buf);
      },
      _inline_rowScale_preMultiply: function(row, scale) {
        for (var col = 0; col < this._width; col++) {
          var v1 = this.cell(col, row);
          var v2 = v1.times(scale);
          var k = (row * this._width + col) * 2;
          this._buffer[k] = v2.real;
          this._buffer[k + 1] = v2.imag;
        }
      },
      _inline_colScale_postMultiply: function(col, scale) {
        for (var row = 0; row < this._height; row++) {
          var v1 = this.cell(col, row);
          var v2 = v1.times(scale);
          var k = (row * this._width + col) * 2;
          this._buffer[k] = v2.real;
          this._buffer[k + 1] = v2.imag;
        }
      },
      _inline_rowMix_preMultiply: function(row1, row2, op) {
        var $__21,
            $__22;
        var $__20 = op._2x2Breakdown(),
            a = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            b = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            c = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            d = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        for (var col = 0; col < this._width; col++) {
          var x = this.cell(col, row1);
          var y = this.cell(col, row2);
          var v1 = x.times(a).plus(y.times(b));
          var v2 = x.times(c).plus(y.times(d));
          var k1 = (row1 * this._width + col) * 2;
          var k2 = (row2 * this._width + col) * 2;
          this._buffer[k1] = v1.real;
          this._buffer[k1 + 1] = v1.imag;
          this._buffer[k2] = v2.real;
          this._buffer[k2 + 1] = v2.imag;
        }
      },
      _inline_colMix_postMultiply: function(col1, col2, op) {
        var $__21,
            $__22;
        var $__20 = op._2x2Breakdown(),
            a = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            b = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            c = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            d = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        for (var row = 0; row < this._width; row++) {
          var x = this.cell(col1, row);
          var y = this.cell(col2, row);
          var v1 = x.times(a).plus(y.times(c));
          var v2 = x.times(b).plus(y.times(d));
          var k1 = (row * this._width + col1) * 2;
          var k2 = (row * this._width + col2) * 2;
          this._buffer[k1] = v1.real;
          this._buffer[k1 + 1] = v1.imag;
          this._buffer[k2] = v2.real;
          this._buffer[k2 + 1] = v2.imag;
        }
      },
      _clone: function() {
        return new Matrix(this._width, this._height, this._buffer.slice());
      },
      qrDecomposition: function() {
        if (this._width !== this._height) {
          throw new DetailedError("Expected a square matrix.", this);
        }
        var Q = Matrix.identity(this._width);
        var R = this._clone();
        for (var row = 0; row < this._height; row++) {
          for (var col = 0; col < row && col < this._width; col++) {
            var belowDiag = R.cell(col, row);
            var onDiag = R.cell(col, col);
            var mag1 = onDiag.abs();
            var mag2 = belowDiag.abs();
            if (mag2 === 0) {
              continue;
            }
            var theta = -Math.atan2(mag2, mag1);
            var cos = Math.cos(theta);
            var sin = Math.sin(theta);
            var phase1 = onDiag.unit().conjugate();
            var phase2 = belowDiag.unit().conjugate();
            var op = Matrix.square(phase1.times(cos), phase2.times(-sin), phase1.times(sin), phase2.times(cos));
            R._inline_rowMix_preMultiply(col, row, op);
            Q._inline_colMix_postMultiply(col, row, op.adjoint());
          }
          var u = R.cell(row, row).unit();
          R._inline_rowScale_preMultiply(row, u.conjugate());
          Q._inline_colScale_postMultiply(row, u);
        }
        return {
          Q: Q,
          R: R
        };
      },
      lqDecomposition: function() {
        var $__20 = this.adjoint().qrDecomposition(),
            Q = $__20.Q,
            R = $__20.R;
        return {
          L: R.adjoint(),
          Q: Q.adjoint()
        };
      },
      eigenvalueMagnitudes: function(epsilon) {
        var maxIterations = arguments[1] !== (void 0) ? arguments[1] : 1000;
        if (this._width !== this._height) {
          throw new DetailedError("Expected a square matrix.", this);
        }
        var iteration = 0;
        var m = this;
        while (!m.isUpperTriangular(epsilon) && iteration < maxIterations) {
          var $__20 = m.qrDecomposition(),
              Q = $__20.Q,
              R = $__20.R;
          if (R.isIdentity(epsilon)) {
            return Seq.repeat(1, this._width).toArray();
          }
          m = R.times(Q);
          iteration++;
        }
        return Seq.range(this._width).map(function(i) {
          return m.cell(i, i).abs();
        }).sortedBy(function(e) {
          return -e;
        }).toArray();
      },
      eigenDecomposition: function() {
        var $__21,
            $__22;
        if (this.width() !== 2 || this.height() !== 2) {
          throw new Error("Not implemented: non-2x2 eigen decomposition");
        }
        var $__20 = this._2x2Breakdown(),
            a = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            b = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            c = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            d = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        var vals = Complex.rootsOfQuadratic(Complex.ONE, a.plus(d).times(-1), a.times(d).minus(b.times(c)));
        if (vals.length === 0) {
          throw new Error("Degenerate");
        }
        if (vals.length === 1) {
          return [{
            val: vals[0],
            vec: Matrix.col(1, 0)
          }, {
            val: vals[0],
            vec: Matrix.col(0, 1)
          }];
        }
        return vals.map(function(v) {
          var $__24,
              $__25,
              $__26,
              $__27,
              $__28;
          var $__23 = [b.times(-1), a.minus(v)],
              x = ($__24 = $__23[Symbol.iterator](), ($__25 = $__24.next()).done ? void 0 : $__25.value),
              y = ($__25 = $__24.next()).done ? void 0 : $__25.value;
          if (x.isEqualTo(0) && y.isEqualTo(0)) {
            ($__26 = [v.minus(d), c], x = ($__27 = $__26[Symbol.iterator](), ($__28 = $__27.next()).done ? void 0 : $__28.value), y = ($__28 = $__27.next()).done ? void 0 : $__28.value, $__26);
          }
          if (!x.isEqualTo(0)) {
            y = y.dividedBy(x);
            x = Complex.ONE;
          }
          var m = Math.sqrt(x.norm2() + y.norm2());
          if (m === 0) {
            throw new Error("Unexpected degenerate");
          }
          return {
            val: v,
            vec: Matrix.col(x, y).times(1 / m)
          };
        });
      },
      liftApply: function(complexFunction) {
        var t = this.times(0);
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this.eigenDecomposition())[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var $__20 = $__4.value,
                val = $__20.val,
                vec = $__20.vec;
            {
              var fVal = complexFunction(val);
              var part = vec.times(vec.adjoint());
              t = t.plus(part.times(fVal));
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        return t;
      },
      qubitDensityMatrixToBlochVector: function() {
        var $__21,
            $__22;
        if (this._width !== 2 || this._height !== 2) {
          throw new DetailedError("Need a 2x2 density matrix.", this);
        }
        if (!this.isApproximatelyHermitian(0.01)) {
          throw new DetailedError("Density matrix should be Hermitian.", this);
        }
        if (!this.trace().isApproximatelyEqualTo(1, 0.01)) {
          throw new DetailedError("Density matrix should have unit trace.", this);
        }
        var $__20 = this._buffer,
            ar = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            ai = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            br = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            bi = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            cr = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            ci = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            dr = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            di = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        var x = -cr - br;
        var y = bi - ci;
        var z = dr - ar;
        return [x, y, z];
      },
      determinant: function() {
        var $__2 = this;
        Util.need(this.width() === this.height(), "Must be square");
        var n = this.width();
        if (n === 1) {
          return this.cell(0, 0);
        }
        return Seq.range(n).map(function(k) {
          var cutColMatrix = Matrix.generate(n - 1, n - 1, function(r, c) {
            return $__2.cell(c + (c < k ? 0 : 1), r + 1);
          });
          return cutColMatrix.determinant().times($__2.cell(k, 0)).times(Math.pow(-1, k));
        }).aggregate(Complex.ZERO, function(a, e) {
          return a.plus(e);
        });
      },
      _2x2Breakdown: function() {
        return [new Complex(this._buffer[0], this._buffer[1]), new Complex(this._buffer[2], this._buffer[3]), new Complex(this._buffer[4], this._buffer[5]), new Complex(this._buffer[6], this._buffer[7])];
      },
      qubitOperationToAngleAxisRotation: function() {
        var $__21,
            $__22;
        Util.need(this.width() === 2 && this.height() === 2, "Need a 2x2 matrix.");
        Util.need(this.isUnitary(0.01), "Need a unitary matrix.");
        var $__20 = this._2x2Breakdown(),
            a = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            b = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            c = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            d = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        var wφ = a.plus(d);
        var xφ = b.plus(c).dividedBy(Complex.I);
        var yφ = b.minus(c);
        var zφ = a.minus(d).dividedBy(Complex.I);
        var φ = seq([wφ, xφ, yφ, zφ]).maxBy(function(e) {
          return e.abs();
        }).unit().times(2);
        var w = Math.min(1, Math.max(-1, wφ.dividedBy(φ).real));
        var x = xφ.dividedBy(φ).real;
        var y = yφ.dividedBy(φ).real;
        var z = zφ.dividedBy(φ).real;
        var θ = -2 * Math.acos(w);
        var n = Math.sqrt(x * x + y * y + z * z);
        if (n < 0.0000001) {
          return {
            axis: [1, 0, 0],
            angle: 0,
            phase: φ.phase()
          };
        }
        x /= n;
        y /= n;
        z /= n;
        if (θ <= -Math.PI) {
          θ += 2 * Math.PI;
          φ = φ.times(-1);
        }
        if (x + y + z < 0) {
          x = -x;
          y = -y;
          z = -z;
          θ = -θ;
        }
        return {
          axis: [x, y, z],
          angle: θ,
          phase: φ.phase()
        };
      },
      cross3: function(other) {
        var $__2 = this;
        Util.need(this.width() === 1 && this.height() === 3, "This isn't a 3d column vector.");
        Util.need(other.width() === 1 && other.height() === 3, "Other's not a 3d column vector.");
        return Matrix.generate(1, 3, function(r) {
          var $__21,
              $__22;
          var $__20 = [(r + 1) % 3, (r + 2) % 3],
              i = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
              j = ($__22 = $__21.next()).done ? void 0 : $__22.value;
          var a = $__2.cell(0, i).times(other.cell(0, j));
          var b = $__2.cell(0, j).times(other.cell(0, i));
          return a.minus(b);
        });
      },
      _unordered_singularValueDecomposition_2x2: function() {
        var $__22,
            $__23;
        var U = Matrix.identity(2);
        var $__20 = this.lqDecomposition(),
            S = $__20.L,
            V = $__20.Q;
        var au = S.cell(0, 0).unit();
        var cu = S.cell(0, 1).unit();
        U._inline_colScale_postMultiply(0, au);
        U._inline_colScale_postMultiply(1, cu);
        S._inline_rowScale_preMultiply(0, au.conjugate());
        S._inline_rowScale_preMultiply(1, cu.conjugate());
        var du = S.cell(1, 1).unit();
        S._inline_colScale_postMultiply(1, du.conjugate());
        V._inline_rowScale_preMultiply(1, du);
        var $__21 = S._buffer,
            a = ($__22 = $__21[Symbol.iterator](), ($__23 = $__22.next()).done ? void 0 : $__23.value),
            b = ($__22.next(), ($__23 = $__22.next()).done ? void 0 : $__23.value),
            c = ($__22.next(), ($__23 = $__22.next()).done ? void 0 : $__23.value),
            d = ($__22.next(), ($__23 = $__22.next()).done ? void 0 : $__23.value);
        var t = a + d;
        var x = b + c;
        var y = b - c;
        var z = a - d;
        var theta_0 = Math.atan2(x, t) / 2.0;
        var theta_d = Math.atan2(y, z) / 2.0;
        var s_0 = Math.sqrt(t * t + x * x) / 2.0;
        var s_d = Math.sqrt(z * z + y * y) / 2.0;
        U._inline_colMix_postMultiply(0, 1, Matrix.rotation(theta_0 - theta_d));
        V._inline_rowMix_preMultiply(0, 1, Matrix.rotation(theta_0 + theta_d));
        S = Matrix.square(s_0 + s_d, 0, 0, s_0 - s_d);
        return {
          U: U,
          S: S,
          V: V
        };
      },
      _unordered_singularValueDecomposition_iterative: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        var maxIterations = arguments[1] !== (void 0) ? arguments[1] : 100;
        var U = Matrix.identity(this._width);
        var S = this._clone();
        var V = Matrix.identity(this._width);
        var iter = 0;
        while (!S.isDiagonal(epsilon) && iter++ < maxIterations) {
          var $__20 = S.qrDecomposition(),
              Ql = $__20.Q,
              Sl = $__20.R;
          var $__21 = Sl.lqDecomposition(),
              Sr = $__21.L,
              Qr = $__21.Q;
          U = U.times(Ql);
          S = Sr;
          V = Qr.times(V);
        }
        return {
          U: U,
          S: S,
          V: V
        };
      },
      singularValueDecomposition: function() {
        var $__21,
            $__22,
            $__23,
            $__24,
            $__25,
            $__26,
            $__27,
            $__28,
            $__29;
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        var maxIterations = arguments[1] !== (void 0) ? arguments[1] : 100;
        if (this._width !== this._height) {
          throw new DetailedError("Expected a square matrix.", this);
        }
        var $__20 = this._width === 2 ? this._unordered_singularValueDecomposition_2x2() : this._unordered_singularValueDecomposition_iterative(epsilon, maxIterations),
            U = $__20.U,
            S = $__20.S,
            V = $__20.V;
        var permutation = Seq.range(this._width).sortedBy(function(i) {
          return -S.cell(i, i).norm2();
        }).toArray();
        for (var i = 0; i < S._width; i++) {
          var j = permutation[i];
          if (i !== j) {
            U._inline_colMix_postMultiply(i, j, Matrix.PAULI_X);
            V._inline_rowMix_preMultiply(i, j, Matrix.PAULI_X);
            ($__21 = [S._buffer[j * 2], S._buffer[i * 2]], S._buffer[i * 2] = ($__22 = $__21[Symbol.iterator](), ($__23 = $__22.next()).done ? void 0 : $__23.value), S._buffer[j * 2] = ($__23 = $__22.next()).done ? void 0 : $__23.value, $__21);
            ($__24 = [S._buffer[j * 2 + 1], S._buffer[i * 2 + 1]], S._buffer[i * 2 + 1] = ($__25 = $__24[Symbol.iterator](), ($__26 = $__25.next()).done ? void 0 : $__26.value), S._buffer[j * 2 + 1] = ($__26 = $__25.next()).done ? void 0 : $__26.value, $__24);
            ($__27 = [permutation[i], permutation[j]], permutation[j] = ($__28 = $__27[Symbol.iterator](), ($__29 = $__28.next()).done ? void 0 : $__29.value), permutation[i] = ($__29 = $__28.next()).done ? void 0 : $__29.value, $__27);
          }
        }
        for (var i$__31 = 0; i$__31 < S._width; i$__31++) {
          U._inline_colScale_postMultiply(i$__31, S.cell(i$__31, i$__31).unit());
        }
        S = Matrix.generateDiagonal(S._width, function(k) {
          return S.cell(k, k).abs();
        });
        return {
          U: U,
          S: S,
          V: V
        };
      },
      getColumn: function(colIndex) {
        Util.need(colIndex >= 0 && colIndex <= this.width(), "colIndex >= 0 && colIndex <= this.width()");
        var col = [];
        for (var r = 0; r < this._height; r++) {
          col.push(this.cell(colIndex, r));
        }
        return col;
      },
      getRow: function(rowIndex) {
        Util.need(rowIndex >= 0 && rowIndex <= this.height(), "rowIndex >= 0 && rowIndex <= this.height()");
        var row = [];
        for (var c = 0; c < this._width; c++) {
          row.push(this.cell(c, rowIndex));
        }
        return row;
      },
      closestUnitary: function() {
        var epsilon = arguments[0] !== (void 0) ? arguments[0] : 0;
        var maxIterations = arguments[1] !== (void 0) ? arguments[1] : 100;
        var svd = this.singularValueDecomposition(epsilon, maxIterations);
        return svd.U.times(svd.V);
      }
    }, {
      fromRows: function(rows) {
        Util.need(Array.isArray(rows) && rows.every(Array.isArray), "array rows", rows);
        Util.need(rows.length > 0, "non-zero height", arguments);
        var seqRows = seq(rows);
        var h = rows.length;
        var w = seqRows.map(function(e) {
          return e.length;
        }).distinct().single(null);
        if (w === null) {
          throw new DetailedError("Inconsistent row widths.", {rows: rows});
        }
        var buffer = new Float64Array(w * h * 2);
        var i = 0;
        var $__13 = true;
        var $__14 = false;
        var $__15 = undefined;
        try {
          for (var $__11 = void 0,
              $__10 = (rows)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
            var row = $__11.value;
            {
              var $__6 = true;
              var $__7 = false;
              var $__8 = undefined;
              try {
                for (var $__4 = void 0,
                    $__3 = (row)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                  var cell = $__4.value;
                  {
                    buffer[i] = Complex.realPartOf(cell);
                    buffer[i + 1] = Complex.imagPartOf(cell);
                    i += 2;
                  }
                }
              } catch ($__9) {
                $__7 = true;
                $__8 = $__9;
              } finally {
                try {
                  if (!$__6 && $__3.return != null) {
                    $__3.return();
                  }
                } finally {
                  if ($__7) {
                    throw $__8;
                  }
                }
              }
            }
          }
        } catch ($__16) {
          $__14 = true;
          $__15 = $__16;
        } finally {
          try {
            if (!$__13 && $__10.return != null) {
              $__10.return();
            }
          } finally {
            if ($__14) {
              throw $__15;
            }
          }
        }
        return new Matrix(w, h, buffer);
      },
      parse: function(text) {
        text = text.replace(/\s/g, "");
        if (text.length < 4 || text.substr(0, 2) !== "{[" || text.substr(text.length - 2, 2) !== "]}") {
          throw new Error("Not surrounded by {[]}.");
        }
        return Matrix.fromRows(text.substr(2, text.length - 4).split("},{").map(function(row) {
          return row.split(",").map(Complex.parse);
        }));
      },
      generate: function(width, height, coefficientRowColGenerator) {
        var buf = new Float64Array(width * height * 2);
        for (var r = 0; r < height; r++) {
          for (var c = 0; c < width; c++) {
            var k = (r * width + c) * 2;
            var v = coefficientRowColGenerator(r, c);
            buf[k] = Complex.realPartOf(v);
            buf[k + 1] = Complex.imagPartOf(v);
          }
        }
        return new Matrix(width, height, buf);
      },
      generateDiagonal: function(size, coefficientFunc) {
        var buf = new Float64Array(size * size * 2);
        for (var i = 0; i < size; i++) {
          var k = i * (size + 1) * 2;
          var v = coefficientFunc(i);
          buf[k] = Complex.realPartOf(v);
          buf[k + 1] = Complex.imagPartOf(v);
        }
        return new Matrix(size, size, buf);
      },
      generateTransition: function(size, transitionFunc) {
        var buf = new Float64Array(size * size * 2);
        for (var c = 0; c < size; c++) {
          var r = transitionFunc(c);
          var k = (r * size + c) * 2;
          buf[k] = 1;
        }
        return new Matrix(size, size, buf);
      },
      zero: function(width, height) {
        return new Matrix(width, height, new Float64Array(width * height * 2));
      },
      solo: function(coef) {
        return new Matrix(1, 1, new Float64Array([Complex.realPartOf(coef), Complex.imagPartOf(coef)]));
      },
      square: function() {
        for (var coefs = [],
            $__17 = 0; $__17 < arguments.length; $__17++)
          coefs[$__17] = arguments[$__17];
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        var n = Math.round(Math.sqrt(coefs.length));
        Util.need(n * n === coefs.length, "Matrix.square: non-square number of arguments");
        return Matrix.generate(n, n, function(r, c) {
          return coefs[r * n + c];
        });
      },
      col: function() {
        for (var coefs = [],
            $__18 = 0; $__18 < arguments.length; $__18++)
          coefs[$__18] = arguments[$__18];
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        return Matrix.generate(1, coefs.length, function(r) {
          return coefs[r];
        });
      },
      row: function() {
        for (var coefs = [],
            $__19 = 0; $__19 < arguments.length; $__19++)
          coefs[$__19] = arguments[$__19];
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        return Matrix.generate(coefs.length, 1, function(r, c) {
          return coefs[c];
        });
      },
      fromPauliRotation: function(x, y, z) {
        var $__21,
            $__22;
        var sinc = function(t) {
          if (Math.abs(t) < 0.0002) {
            return 1 - t * t / 6.0;
          }
          return Math.sin(t) / t;
        };
        x = -x * Math.PI * 2;
        y = -y * Math.PI * 2;
        z = -z * Math.PI * 2;
        var s = -11 * x + -13 * y + -17 * z >= 0 ? 1 : -1;
        var theta = Math.sqrt(x * x + y * y + z * z);
        var sigma_v = Matrix.PAULI_X.times(x).plus(Matrix.PAULI_Y.times(y)).plus(Matrix.PAULI_Z.times(z));
        var $__20 = Util.snappedCosSin(s * theta),
            cos = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            sin = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        var ci = new Complex(1 + cos, sin).times(0.5);
        var cv = new Complex(Math.sin(theta / 2) * sinc(theta / 2), -s * sinc(theta)).times(s * 0.5);
        var m = Matrix.identity(2).times(ci).minus(sigma_v.times(cv));
        var expectNiceValuesCorrection = function(v) {
          return Format.simplifyByRounding(v, 0.0000000000001);
        };
        return m.transformRealAndImagComponentsWith(expectNiceValuesCorrection);
      },
      fromWireSwap: function(numWires, swapWire1, swapWire2) {
        var bitSwap = function(n) {
          var m1 = 1 << swapWire1;
          var m2 = 1 << swapWire2;
          var s = n & ~(m1 | m2);
          if ((n & m1) !== 0) {
            s |= m2;
          }
          if ((n & m2) !== 0) {
            s |= m1;
          }
          return s;
        };
        return Matrix.generateTransition(1 << numWires, bitSwap);
      },
      identity: function(size) {
        if (!Number.isInteger(size) || size <= 0) {
          throw new DetailedError("Bad size", {size: size});
        }
        var buf = new Float64Array(size * size * 2);
        for (var k = 0; k < size; k++) {
          buf[k * (size + 1) * 2] = 1;
        }
        return new Matrix(size, size, buf);
      },
      rotation: function(theta) {
        var c = Math.cos(theta);
        var s = Math.sin(theta);
        return Matrix.square(c, -s, s, c);
      },
      fromAngleAxisPhaseRotation: function(angle, axis, phase) {
        var $__21,
            $__22,
            $__24,
            $__25;
        var $__20 = axis,
            x = ($__21 = $__20[Symbol.iterator](), ($__22 = $__21.next()).done ? void 0 : $__22.value),
            y = ($__22 = $__21.next()).done ? void 0 : $__22.value,
            z = ($__22 = $__21.next()).done ? void 0 : $__22.value;
        Util.need(Math.abs(x * x + y * y + z * z - 1) < 0.000001, "Not a unit axis.");
        var vσ = Matrix.PAULI_X.times(x).plus(Matrix.PAULI_Y.times(y)).plus(Matrix.PAULI_Z.times(z));
        var $__23 = Util.snappedCosSin(-angle / 2),
            cos = ($__24 = $__23[Symbol.iterator](), ($__25 = $__24.next()).done ? void 0 : $__25.value),
            sin = ($__25 = $__24.next()).done ? void 0 : $__25.value;
        return Matrix.identity(2).times(cos).plus(vσ.times(new Complex(0, sin))).times(Complex.polar(1, phase));
      }
    });
  }();
  Matrix.PAULI_X = Matrix.square(0, 1, 1, 0);
  Matrix.PAULI_Y = Matrix.square(0, new Complex(0, -1), Complex.I, 0);
  Matrix.PAULI_Z = Matrix.square(1, 0, 0, -1);
  Matrix.HADAMARD = Matrix.square(1, 1, 1, -1).times(Math.sqrt(0.5));
  return {get Matrix() {
      return Matrix;
    }};
});
//# sourceURL=src/math/Matrix.js
;$traceurRuntime.registerModule("src/math/Point.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Point.js";
  var Point = function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }
    return ($traceurRuntime.createClass)(Point, {
      isEqualTo: function(obj) {
        if (!(obj instanceof Point)) {
          return false;
        }
        var other = obj;
        return other.x === this.x && other.y === this.y;
      },
      toString: function() {
        return ("(x: " + this.x + ", y: " + this.y + ")");
      },
      offsetBy: function(dx, dy) {
        return new Point(this.x + dx, this.y + dy);
      },
      plus: function(p) {
        return new Point(this.x + p.x, this.y + p.y);
      },
      minus: function(p) {
        return new Point(this.x - p.x, this.y - p.y);
      },
      times: function(c) {
        return new Point(this.x * c, this.y * c);
      },
      distanceTo: function(other) {
        var dx = this.x - other.x;
        var dy = this.y - other.y;
        return Math.sqrt(dx * dx + dy * dy);
      }
    }, {});
  }();
  return {get Point() {
      return Point;
    }};
});
//# sourceURL=src/math/Point.js
;$traceurRuntime.registerModule("src/math/Rect.js", [], function() {
  "use strict";
  var __moduleName = "src/math/Rect.js";
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/math/Rect.js")).Point;
  var Rect = function() {
    function Rect(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    }
    return ($traceurRuntime.createClass)(Rect, {
      isEqualTo: function(obj) {
        if (!(obj instanceof Rect)) {
          return false;
        }
        var other = obj;
        return other.x === this.x && other.y === this.y && other.w === this.w && other.h === this.h;
      },
      isApproximatelyEqualTo: function(obj, epsilon) {
        if (!(obj instanceof Rect)) {
          return false;
        }
        var other = obj;
        return Math.abs(other.x - this.x) <= epsilon && Math.abs(other.y - this.y) <= epsilon && Math.abs(other.right() - this.right()) <= epsilon && Math.abs(other.bottom() - this.bottom()) <= epsilon;
      },
      toString: function() {
        return ("[" + this.x + ":" + this.right() + "]x[" + this.y + ":" + this.bottom() + "]");
      },
      center: function() {
        return new Point(this.x + this.w / 2, this.y + this.h / 2);
      },
      topLeft: function() {
        return new Point(this.x, this.y);
      },
      topRight: function() {
        return new Point(this.x + this.w, this.y);
      },
      bottomLeft: function() {
        return new Point(this.x, this.y + this.h);
      },
      bottomRight: function() {
        return new Point(this.x + this.w, this.y + this.h);
      },
      centerLeft: function() {
        return new Point(this.x, this.y + this.h / 2);
      },
      centerRight: function() {
        return new Point(this.x + this.w, this.y + this.h / 2);
      },
      topCenter: function() {
        return new Point(this.x + this.w / 2, this.y);
      },
      bottomCenter: function() {
        return new Point(this.x + this.w / 2, this.y + this.h);
      },
      right: function() {
        return this.x + this.w;
      },
      bottom: function() {
        return this.y + this.h;
      },
      skipLeft: function(lostWidth) {
        var d = Math.min(lostWidth, this.w);
        return new Rect(this.x + d, this.y, this.w - d, this.h);
      },
      skipRight: function(lostWidth) {
        var d = Math.min(lostWidth, this.w);
        return new Rect(this.x, this.y, this.w - d, this.h);
      },
      skipTop: function(lostHeight) {
        var d = Math.min(lostHeight, this.h);
        return new Rect(this.x, this.y + d, this.w, this.h - d);
      },
      skipBottom: function(lostHeight) {
        var d = Math.min(lostHeight, this.h);
        return new Rect(this.x, this.y, this.w, this.h - d);
      },
      takeLeft: function(keptWidth) {
        var d = Math.max(keptWidth, 0);
        return new Rect(this.x, this.y, d, this.h);
      },
      takeRight: function(keptWidth) {
        var d = Math.max(keptWidth, 0);
        return new Rect(this.x + this.w - d, this.y, d, this.h);
      },
      takeTop: function(keptHeight) {
        var d = Math.max(keptHeight, 0);
        return new Rect(this.x, this.y, this.w, d);
      },
      takeBottom: function(keptHeight) {
        var d = Math.max(keptHeight, 0);
        return new Rect(this.x, this.y + this.h - d, this.w, d);
      },
      paddedBy: function(p) {
        return new Rect(this.x - p, this.y - p, this.w + p * 2, this.h + p * 2);
      },
      scaledOutwardBy: function(factor) {
        var c = this.center();
        var w2 = this.w * factor;
        var h2 = this.h * factor;
        return new Rect(c.x - w2 / 2, c.y - h2 / 2, w2, h2);
      },
      containsPoint: function(p) {
        return p.x >= this.x && p.x < this.x + this.w && p.y >= this.y && p.y < this.y + this.h;
      },
      takeLeftProportion: function(proportion) {
        return this.takeLeft(this.w * proportion);
      },
      takeRightProportion: function(proportion) {
        return this.takeRight(this.w * proportion);
      },
      takeTopProportion: function(proportion) {
        return this.takeTop(this.h * proportion);
      },
      takeBottomProportion: function(proportion) {
        return this.takeBottom(this.h * proportion);
      },
      leftHalf: function() {
        return this.skipRight(this.w / 2);
      },
      rightHalf: function() {
        return this.skipLeft(this.w / 2);
      },
      topHalf: function() {
        return this.skipBottom(this.h / 2);
      },
      bottomHalf: function() {
        return this.skipTop(this.h / 2);
      },
      shiftedBy: function(dx, dy) {
        return new Rect(this.x + dx, this.y + dy, this.w, this.h);
      },
      proportionalShiftedBy: function(dx, dy) {
        return this.shiftedBy(dx * this.w, dy * this.h);
      },
      withX: function(newX) {
        return new Rect(newX, this.y, this.w, this.h);
      },
      withY: function(newY) {
        return new Rect(this.x, newY, this.w, this.h);
      },
      withW: function(newW) {
        return new Rect(this.x, this.y, newW, this.h);
      },
      withH: function(newH) {
        return new Rect(this.x, this.y, this.w, newH);
      },
      snapInside: function(boundingRect) {
        var w = Math.min(boundingRect.w, this.w);
        var h = Math.min(boundingRect.h, this.h);
        var x = Math.max(Math.min(this.x, boundingRect.right() - w), boundingRect.x);
        var y = Math.max(Math.min(this.y, boundingRect.bottom() - h), boundingRect.y);
        return new Rect(x, y, w, h);
      }
    }, {centeredSquareWithRadius: function(center, radius) {
        return new Rect(center.x - radius, center.y - radius, radius * 2, radius * 2);
      }});
  }();
  return {get Rect() {
      return Rect;
    }};
});
//# sourceURL=src/math/Rect.js
;$traceurRuntime.registerModule("src/ui/clear.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/clear.js";
  function initClear(revision, obsIsAnyOverlayShowing) {
    var EMPTY_STATE = '{"cols":[]}';
    var clearAllButton = document.getElementById('clear-all-button');
    revision.latestActiveCommit().zipLatest(obsIsAnyOverlayShowing, function(r, v) {
      return ({
        r: r,
        v: v
      });
    }).subscribe(function($__1) {
      var $__2 = $__1,
          r = $__2.r,
          v = $__2.v;
      clearAllButton.disabled = r === EMPTY_STATE || v;
    });
    clearAllButton.addEventListener('click', function() {
      return revision.commit(EMPTY_STATE);
    });
    var clearCircuitButton = document.getElementById('clear-circuit-button');
    revision.latestActiveCommit().zipLatest(obsIsAnyOverlayShowing, function(r, v) {
      return ({
        r: r,
        v: v
      });
    }).subscribe(function($__1) {
      var $__2 = $__1,
          r = $__2.r,
          v = $__2.v;
      clearCircuitButton.disabled = r === _getEmptyCircuitState(revision) || v;
    });
    clearCircuitButton.addEventListener('click', function() {
      return revision.commit(_getEmptyCircuitState(revision));
    });
  }
  function _getEmptyCircuitState(revision) {
    var val = JSON.parse(revision.peekActiveCommit());
    val["cols"] = [];
    return JSON.stringify(val);
  }
  return {get initClear() {
      return initClear;
    }};
});
//# sourceURL=src/ui/clear.js
;$traceurRuntime.registerModule("src/ui/DisplayedCircuit.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/DisplayedCircuit.js";
  var CachablePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/CachablePainting.js", "src/ui/DisplayedCircuit.js")).CachablePainting;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitDefinition.js", "src/ui/DisplayedCircuit.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitStats.js", "src/ui/DisplayedCircuit.js")).CircuitStats;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/DisplayedCircuit.js")).Config;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/ui/DisplayedCircuit.js")).DetailedError;
  var equate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Equate.js", "src/ui/DisplayedCircuit.js")).equate;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/ui/DisplayedCircuit.js")).Format;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateColumn.js", "src/ui/DisplayedCircuit.js")).GateColumn;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GateDrawParams.js", "src/ui/DisplayedCircuit.js")).GateDrawParams;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/ui/DisplayedCircuit.js")).GatePainting;
  var Hand = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/Hand.js", "src/ui/DisplayedCircuit.js")).Hand;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/ui/DisplayedCircuit.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/ui/DisplayedCircuit.js")).Point;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/ui/DisplayedCircuit.js")).Matrix;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/ui/DisplayedCircuit.js")).Rect;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/ui/DisplayedCircuit.js")).Util;
  var $__36 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/ui/DisplayedCircuit.js")),
      seq = $__36.seq,
      Seq = $__36.Seq;
  var paintBlochSphereDisplay = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/BlochSphereDisplay.js", "src/ui/DisplayedCircuit.js")).paintBlochSphereDisplay;
  var CIRCUIT_OP_HORIZONTAL_SPACING = 10;
  var CIRCUIT_OP_LEFT_SPACING = 35;
  var SUPERPOSITION_GRID_LABEL_SPAN = 50;
  var EXTRA_COLS_FOR_SINGLE_QUBIT_DISPLAYS = 2;
  var DisplayedCircuit = function() {
    function DisplayedCircuit(top, circuitDefinition, compressedColumnIndex, highlightedSlot, extraWireStartIndex) {
      if (!Number.isFinite(top)) {
        throw new DetailedError("Bad top", {
          top: top,
          circuitDefinition: circuitDefinition
        });
      }
      if (!(circuitDefinition instanceof CircuitDefinition)) {
        throw new DetailedError("Bad circuitDefinition", {
          top: top,
          circuitDefinition: circuitDefinition
        });
      }
      this.top = top;
      this.circuitDefinition = circuitDefinition;
      this._compressedColumnIndex = compressedColumnIndex;
      this._highlightedSlot = highlightedSlot;
      this._extraWireStartIndex = extraWireStartIndex;
    }
    return ($traceurRuntime.createClass)(DisplayedCircuit, {
      isBeingEdited: function() {
        return this._extraWireStartIndex !== undefined;
      },
      _groundedWireCount: function() {
        var pseudoCount = this._extraWireStartIndex !== undefined && this._extraWireStartIndex !== Config.MAX_WIRE_COUNT ? 1 : 0;
        var n = Math.max(Config.MIN_WIRE_COUNT, this.circuitDefinition.numWires) - pseudoCount;
        return Math.max(n, this.circuitDefinition.minimumRequiredWireCount());
      },
      desiredHeight: function() {
        var forTooltip = arguments[0] !== (void 0) ? arguments[0] : false;
        if (forTooltip) {
          return this.circuitDefinition.numWires * Config.WIRE_SPACING;
        }
        return this._groundedWireCount() * Config.WIRE_SPACING + 55;
      },
      desiredWidth: function() {
        var forTooltip = arguments[0] !== (void 0) ? arguments[0] : false;
        if (forTooltip) {
          return this.opRect(this.circuitDefinition.columns.length - 1).right() + CIRCUIT_OP_LEFT_SPACING;
        }
        return this._rectForSuperpositionDisplay().right() + 101;
      },
      wireRect: function(wireIndex) {
        if (wireIndex < 0) {
          throw new DetailedError("Bad wireIndex", {wireIndex: wireIndex});
        }
        return new Rect(0, this.top + Config.WIRE_SPACING * wireIndex, Infinity, Config.WIRE_SPACING);
      },
      wireIndexAt: function(y) {
        return Math.floor((y - this.top) / Config.WIRE_SPACING);
      },
      toColumnSpaceCoordinate: function(x) {
        var spacing = (CIRCUIT_OP_HORIZONTAL_SPACING + Config.GATE_RADIUS * 2);
        var left = CIRCUIT_OP_LEFT_SPACING - CIRCUIT_OP_HORIZONTAL_SPACING / 2;
        return (x - left) / spacing - 0.5;
      },
      indexOfDisplayedRowAt: function(y) {
        var i = Math.floor((y - this.top) / Config.WIRE_SPACING);
        if (i < 0 || i >= this.circuitDefinition.numWires) {
          return undefined;
        }
        return i;
      },
      indexOfDisplayedColumnAt: function(x) {
        var col = this.toColumnSpaceCoordinate(x);
        var i;
        if (this._compressedColumnIndex === undefined || col < this._compressedColumnIndex - 0.75) {
          i = Math.round(col);
        } else if (col < this._compressedColumnIndex - 0.25) {
          i = this._compressedColumnIndex;
        } else {
          i = Math.round(col) - 1;
        }
        if (i < 0 || i >= this.circuitDefinition.columns.length) {
          return undefined;
        }
        return i;
      },
      findOpHalfColumnAt: function(p) {
        if (p.x < 0 || p.y < this.top || p.y > this.top + this.desiredHeight()) {
          return undefined;
        }
        return Math.max(-0.5, Math.round(this.toColumnSpaceCoordinate(p.x) * 2) / 2);
      },
      _findModificationIndex_helperColRow: function(hand) {
        if (hand.pos === undefined || hand.heldGate === undefined) {
          return undefined;
        }
        var pos = hand.pos.minus(hand.holdOffset).plus(new Point(Config.GATE_RADIUS, Config.GATE_RADIUS));
        var halfColIndex = this.findOpHalfColumnAt(pos);
        var row = this.indexOfDisplayedRowAt(pos.y);
        if (halfColIndex === undefined || row === undefined) {
          return undefined;
        }
        var col = Math.ceil(halfColIndex);
        return {
          col: col,
          row: row,
          halfColIndex: halfColIndex
        };
      },
      findModificationIndex: function(hand) {
        var loc = this._findModificationIndex_helperColRow(hand);
        if (loc === undefined) {
          return undefined;
        }
        var $__10 = loc,
            col = $__10.col,
            row = $__10.row,
            halfColIndex = $__10.halfColIndex;
        var isInsert = Math.abs(halfColIndex % 1) === 0.5;
        if (col >= this.circuitDefinition.columns.length) {
          return {
            col: col,
            row: row,
            isInsert: isInsert
          };
        }
        if (!isInsert) {
          var mustInsert = this.circuitDefinition.isSlotRectCoveredByGateInSameColumn(col, row, hand.heldGate.height);
          if (mustInsert) {
            var isAfter = hand.pos.x > this.opRect(col).center().x;
            isInsert = true;
            if (isAfter) {
              col += 1;
            }
          }
        }
        return {
          col: col,
          row: row,
          isInsert: isInsert
        };
      },
      opRect: function(operationIndex) {
        var opWidth = Config.GATE_RADIUS * 2;
        var opSeparation = opWidth + CIRCUIT_OP_HORIZONTAL_SPACING;
        var tweak = 0;
        if (this._compressedColumnIndex !== undefined && operationIndex === this._compressedColumnIndex) {
          tweak = opSeparation / 2;
        }
        if (this._compressedColumnIndex !== undefined && operationIndex > this._compressedColumnIndex) {
          tweak = opSeparation;
        }
        var dx = opSeparation * operationIndex - tweak + CIRCUIT_OP_LEFT_SPACING;
        return new Rect(dx, this.top, opWidth, this.desiredHeight());
      },
      gateRect: function(wireIndex, operationIndex) {
        var width = arguments[2] !== (void 0) ? arguments[2] : 1;
        var height = arguments[3] !== (void 0) ? arguments[3] : 1;
        var op = this.opRect(operationIndex);
        var wire = this.wireRect(wireIndex);
        var r = new Rect(op.center().x - Config.GATE_RADIUS, wire.center().y - Config.GATE_RADIUS, 2 * Config.GATE_RADIUS + (width - 1) * Config.WIRE_SPACING, 2 * Config.GATE_RADIUS + (height - 1) * Config.WIRE_SPACING);
        return new Rect(Math.round(r.x - 0.5) + 0.5, Math.round(r.y - 0.5) + 0.5, Math.round(r.w), Math.round(r.h));
      },
      afterTidyingUp: function() {
        return this.withCircuit(this.circuitDefinition.withUncoveredColumnsRemoved().withHeightOverlapsFixed().withWidthOverlapsFixed().withUncoveredColumnsRemoved().withTrailingSpacersIncluded())._withCompressedColumnIndex(undefined)._withExtraWireStartIndex(undefined)._withHighlightedSlot(undefined);
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof DisplayedCircuit && this.top === other.top && this.circuitDefinition.isEqualTo(other.circuitDefinition) && this._compressedColumnIndex === other._compressedColumnIndex && this._extraWireStartIndex === other._extraWireStartIndex && equate(this._highlightedSlot, other._highlightedSlot);
      },
      paint: function(painter, hand, stats) {
        var forTooltip = arguments[3] !== (void 0) ? arguments[3] : false;
        var showWires = arguments[4] !== (void 0) ? arguments[4] : true;
        if (showWires) {
          this._drawWires(painter, !forTooltip);
        }
        for (var col = 0; col < this.circuitDefinition.columns.length; col++) {
          this._drawColumn(painter, this.circuitDefinition.columns[col], col, hand, stats);
        }
        if (!forTooltip) {
          this._drawOutputDisplays(painter, stats, hand);
          this._drawHintLabels(painter, stats);
        }
      },
      _drawWires: function(painter, showLabels) {
        var $__2 = this;
        var drawnWireCount = Math.min(this.circuitDefinition.numWires, (this._extraWireStartIndex || Infinity) + 1);
        if (showLabels) {
          for (var row = 0; row < drawnWireCount; row++) {
            var wireRect = this.wireRect(row);
            var y = wireRect.center().y;
            painter.print('|0⟩', 20, y, 'right', 'middle', 'black', '14px sans-serif', 20, Config.WIRE_SPACING);
          }
        }
        painter.ctx.save();
        var $__17 = this,
            $__18 = function(row) {
              if (row === $__17._extraWireStartIndex) {
                painter.ctx.globalAlpha *= 0.5;
              }
              painter.trace(function(trace) {
                var wireRect = $__2.wireRect(row);
                var y = Math.round(wireRect.center().y - 0.5) + 0.5;
                var lastX = showLabels ? 25 : 5;
                for (var col = 0; showLabels ? lastX < painter.canvas.width : col <= $__2.circuitDefinition.columns.length; col++) {
                  var x = $__2.opRect(col).center().x;
                  if ($__2.circuitDefinition.locIsMeasured(new Point(col, row))) {
                    trace.line(lastX, y - 1, x, y - 1);
                    trace.line(lastX, y + 1, x, y + 1);
                  } else {
                    trace.line(lastX, y, x, y);
                  }
                  lastX = x;
                }
              }).thenStroke('black');
            };
        for (var row$__16 = 0; row$__16 < drawnWireCount; row$__16++) {
          $__18(row$__16);
        }
        painter.ctx.restore();
        if (this._extraWireStartIndex !== undefined && this.circuitDefinition.numWires === Config.MAX_WIRE_COUNT) {
          painter.print(("(Max wires. Qubit limit is " + Config.MAX_WIRE_COUNT + ".)"), 5, this.wireRect(Config.MAX_WIRE_COUNT).y, 'left', 'top', 'red', '16px bold monospace', 400, Config.WIRE_SPACING);
        }
      },
      _highlightStatusAt: function(col, row, focusPosPts) {
        var $__2 = this;
        if (this._highlightedSlot !== undefined) {
          if (this._highlightedSlot.col === col && this._highlightedSlot.row === row) {
            return {
              isResizeShowing: true,
              isResizeHighlighted: this._highlightedSlot.resizeStyle,
              isHighlighted: !this._highlightedSlot.resizeStyle
            };
          }
        }
        var gate = this.circuitDefinition.gateInSlot(col, row);
        if (gate === undefined || this._highlightedSlot !== undefined) {
          return {
            isResizeShowing: false,
            isResizeHighlighted: false,
            isHighlighted: false
          };
        }
        var gateRect = this.gateRect(row, col, gate.width, gate.height);
        var resizeTabRect = GatePainting.rectForResizeTab(gateRect);
        var isOverGate = function(pos) {
          var overGate = $__2.findGateOverlappingPos(pos);
          return overGate !== undefined && overGate.col === col && overGate.row === row;
        };
        var isNotCoveredAt = function(pos) {
          var g = $__2.findGateOverlappingPos(pos);
          return g === undefined || (g.col === col && g.row === row);
        };
        var isOverGateResizeTab = function(pos) {
          return isNotCoveredAt(pos) && resizeTabRect.containsPoint(pos);
        };
        var isResizeHighlighted = gate.canChangeInSize() && seq(focusPosPts).any(isOverGateResizeTab);
        var isHighlighted = !isResizeHighlighted && seq(focusPosPts).any(isOverGate);
        var isResizeShowing = gate.canChangeInSize() && (isResizeHighlighted || isHighlighted);
        return {
          isHighlighted: isHighlighted,
          isResizeShowing: isResizeShowing,
          isResizeHighlighted: isResizeHighlighted
        };
      },
      _drawGate_disabledReason: function(painter, col, row, gateRect, isHighlighted) {
        var isDisabledReason = this.circuitDefinition.gateAtLocIsDisabledReason(col, row);
        if (isDisabledReason === undefined) {
          return;
        }
        painter.ctx.save();
        if (isHighlighted) {
          painter.ctx.globalAlpha *= 0.3;
        }
        painter.ctx.globalAlpha *= 0.5;
        painter.fillRect(gateRect.paddedBy(5), 'yellow');
        painter.ctx.globalAlpha *= 2;
        painter.strokeLine(gateRect.topLeft(), gateRect.bottomRight(), 'orange', 3);
        var r = painter.printParagraph(isDisabledReason, gateRect.paddedBy(5), new Point(0.5, 0.5), 'red');
        painter.ctx.globalAlpha *= 0.5;
        painter.fillRect(r.paddedBy(2), 'yellow');
        painter.ctx.globalAlpha *= 2;
        painter.printParagraph(isDisabledReason, gateRect.paddedBy(5), new Point(0.5, 0.5), 'red');
        painter.ctx.restore();
      },
      _drawColumn: function(painter, gateColumn, col, hand, stats) {
        this._drawColumnControlWires(painter, col);
        this._drawColumnDragHighlight(painter, col);
        for (var row = 0; row < this.circuitDefinition.numWires; row++) {
          if (gateColumn.gates[row] === undefined) {
            continue;
          }
          var gate = gateColumn.gates[row];
          var gateRect = this.gateRect(row, col, gate.width, gate.height);
          var $__10 = this._highlightStatusAt(col, row, hand.hoverPoints()),
              isHighlighted = $__10.isHighlighted,
              isResizeShowing = $__10.isResizeShowing,
              isResizeHighlighted = $__10.isResizeHighlighted;
          var drawer = gate.customDrawer || GatePainting.DEFAULT_DRAWER;
          painter.noteTouchBlocker({
            rect: gateRect,
            cursor: 'pointer'
          });
          if (gate.canChangeInSize()) {
            painter.noteTouchBlocker({
              rect: GatePainting.rectForResizeTab(gateRect),
              cursor: 'ns-resize'
            });
          }
          drawer(new GateDrawParams(painter, false, isHighlighted && !isResizeHighlighted, isResizeShowing, isResizeHighlighted, gateRect, gate, stats, {
            row: row,
            col: col
          }, this._highlightedSlot === undefined ? hand.hoverPoints() : [], stats.customStatsForSlot(col, row)));
          this._drawGate_disabledReason(painter, col, row, gateRect, isHighlighted);
        }
        this._drawColumnSurvivalRate(painter, gateColumn, col, stats);
      },
      _drawColumnSurvivalRate: function(painter, gateColumn, col, stats) {
        if (gateColumn.indexOfNonUnitaryGate() === undefined) {
          return;
        }
        var preRate = stats.survivalRate(col - 1);
        var postRate = stats.survivalRate(col);
        var marginalRate = (postRate - preRate) / preRate;
        if (isNaN(marginalRate) || Math.abs(marginalRate) <= 0.005) {
          return;
        }
        var descAmount;
        var descCategory;
        if (marginalRate < 0) {
          var rate = Math.round(-marginalRate * 100);
          var rateDesc = marginalRate === -1 ? "100" : rate < 100 ? rate : ">99";
          descAmount = (rateDesc + "%");
          descCategory = 'omits';
        } else {
          var factor = Math.round(marginalRate * 100 + 100);
          descAmount = (factor + "%");
          descCategory = 'gains';
        }
        var pt = this.opRect(col).bottomCenter();
        painter.print(descCategory, pt.x, pt.y - 28, 'center', 'bottom', 'red', '14px sans-serif', 800, 50);
        painter.print(descAmount, pt.x, pt.y - 13, 'center', 'bottom', 'red', '14px sans-serif', 800, 50);
      },
      _drawColumnDragHighlight: function(painter, col) {
        if (this._highlightedSlot !== undefined && this._highlightedSlot.col === col && this._highlightedSlot.row === undefined) {
          var rect = this.gateRect(0, col, 1, this._groundedWireCount()).paddedBy(3);
          painter.fillRect(rect, 'rgba(255, 196, 112, 0.7)');
          painter.strokeRect(rect, 'black');
        }
      },
      _drawColumnControlWires: function(painter, columnIndex) {
        var x = Math.round(this.opRect(columnIndex).center().x - 0.5) + 0.5;
        if (this.circuitDefinition.columns[columnIndex].hasGatesWithGlobalEffects()) {
          painter.ctx.save();
          painter.ctx.setLineDash([1, 4]);
          painter.strokeLine(new Point(x, this.gateRect(0, 0).y), new Point(x, this.opRect(0).bottom() - 40));
          painter.ctx.restore();
        }
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this.circuitDefinition.controlLinesRanges(columnIndex))[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var $__10 = $__4.value,
                first = $__10.first,
                last = $__10.last,
                measured = $__10.measured;
            {
              var y1 = this.wireRect(first).center().y;
              var y2 = this.wireRect(last).center().y;
              if (measured) {
                painter.strokeLine(new Point(x + 1, y1), new Point(x + 1, y2));
                painter.strokeLine(new Point(x - 1, y1), new Point(x - 1, y2));
              } else {
                painter.strokeLine(new Point(x, y1), new Point(x, y2));
              }
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
      },
      previewDrop: function(hand) {
        return hand.heldColumn !== undefined ? this._previewDropMovedGateColumn(hand) : hand.heldGate !== undefined ? this._previewDropMovedGate(hand) : this._previewResizedGate(hand);
      },
      _previewDropMovedGateColumn: function(hand) {
        if (hand.pos === undefined) {
          return this;
        }
        var halfCol = this.findOpHalfColumnAt(new Point(hand.pos.x, this.top));
        var mustInsert = halfCol % 1 === 0 && this.circuitDefinition.columns[halfCol] !== undefined && !this.circuitDefinition.columns[halfCol].isEmpty();
        if (mustInsert) {
          var isAfter = hand.pos.x > this.opRect(halfCol).center().x;
          halfCol += isAfter ? 0.5 : -0.5;
        }
        var col = Math.ceil(halfCol);
        var isInsert = halfCol % 1 !== 0;
        var rowShift = Math.round((hand.pos.y - hand.holdOffset.y - this.top) / Config.WIRE_SPACING);
        var newCircuitDef = this._shiftAndSpliceColumn(rowShift, $traceurRuntime.spread(hand.heldColumn.gates), col, isInsert);
        return this.withCircuit(newCircuitDef)._withHighlightedSlot({
          row: undefined,
          col: col,
          resizeStyle: false
        })._withCompressedColumnIndex(isInsert ? col : undefined);
      },
      _shiftAndSpliceColumn: function(rowShift, gatesOfCol, insertCol, isInsert) {
        while (rowShift < 0 && gatesOfCol[0] === undefined) {
          gatesOfCol.shift();
          gatesOfCol.push(undefined);
          rowShift += 1;
        }
        while (rowShift > 0 && new GateColumn(gatesOfCol).minimumRequiredWireCount() < Config.MAX_WIRE_COUNT) {
          gatesOfCol.unshift(undefined);
          if (new GateColumn(gatesOfCol).minimumRequiredWireCount() < gatesOfCol.length) {
            gatesOfCol.pop();
          }
          rowShift -= 1;
        }
        var expandedCircuit = this.circuitDefinition.withWireCount(gatesOfCol.length);
        var newCols = $traceurRuntime.spread(expandedCircuit.columns);
        while (newCols.length < insertCol) {
          newCols.push(GateColumn.empty(expandedCircuit.numWires));
        }
        newCols.splice(insertCol, isInsert ? 0 : 1, new GateColumn(gatesOfCol));
        return expandedCircuit.withColumns(newCols).withTrailingSpacersIncluded();
      },
      _previewDropMovedGate: function(hand) {
        var modificationPoint = this.findModificationIndex(hand);
        if (modificationPoint === undefined) {
          return this;
        }
        var handRowOffset = Math.floor(hand.holdOffset.y / Config.WIRE_SPACING);
        if (modificationPoint.row + handRowOffset >= this.circuitDefinition.numWires) {
          return this;
        }
        var addedGate = hand.heldGate;
        var emptyCol = GateColumn.empty(this.circuitDefinition.numWires);
        var i = modificationPoint.col;
        var isInserting = modificationPoint.isInsert;
        var row = Math.min(modificationPoint.row, Math.max(0, Config.MAX_WIRE_COUNT - addedGate.height));
        var newCols = seq(this.circuitDefinition.columns).padded(i, emptyCol).ifThen(isInserting, function(s) {
          return s.withInsertedItem(i, emptyCol);
        }).padded(i + addedGate.width, emptyCol).withTransformedItem(i, function(c) {
          return c.withGatesAdded(row, new GateColumn([addedGate]));
        }).toArray();
        var newWireCount = Math.max(this._extraWireStartIndex || 0, Math.max(this.circuitDefinition.numWires, addedGate.height + row));
        if (newWireCount > Config.MAX_WIRE_COUNT) {
          return this;
        }
        var newCircuitDef = this.circuitDefinition.withColumns(newCols).withWireCount(newWireCount);
        return this.withCircuit(newCircuitDef)._withHighlightedSlot({
          row: row,
          col: modificationPoint.col,
          resizeStyle: false
        })._withCompressedColumnIndex(isInserting ? i : undefined)._withFallbackExtraWireStartIndex(this.circuitDefinition.numWires);
      },
      _previewResizedGate: function(hand) {
        if (hand.resizingGateSlot === undefined || hand.pos === undefined) {
          return this;
        }
        var gate = this.circuitDefinition.gateInSlot(hand.resizingGateSlot.x, hand.resizingGateSlot.y);
        if (gate === undefined) {
          return this;
        }
        var row = Math.min(this.wireIndexAt(hand.pos.y - hand.holdOffset.y), Config.MAX_WIRE_COUNT - 1);
        var newGate = seq(gate.gateFamily).minBy(function(g) {
          return Math.abs(g.height - (row - hand.resizingGateSlot.y + 1));
        });
        var newWireCount = Math.min(Config.MAX_WIRE_COUNT, Math.max(this.circuitDefinition.numWires, newGate.height + hand.resizingGateSlot.y));
        var newCols = seq(this.circuitDefinition.columns).withTransformedItem(hand.resizingGateSlot.x, function(colObj) {
          return new GateColumn(seq(colObj.gates).withOverlayedItem(hand.resizingGateSlot.y, newGate).toArray());
        }).toArray();
        var newCircuitWithoutOverlapFix = this.circuitDefinition.withColumns(newCols).withWireCount(newWireCount);
        var newCircuitWithOverlapFix = newCircuitWithoutOverlapFix.withHeightOverlapsFixed();
        var newCircuit = newCircuitWithOverlapFix.withTrailingSpacersIncluded();
        return this.withCircuit(newCircuit)._withHighlightedSlot(this._highlightedSlot)._withCompressedColumnIndex(newCircuitWithoutOverlapFix.isEqualTo(newCircuitWithOverlapFix) ? undefined : hand.resizingGateSlot.x + 1)._withFallbackExtraWireStartIndex(this.circuitDefinition.numWires);
      },
      afterDropping: function(hand) {
        return this.previewDrop(hand)._withCompressedColumnIndex(undefined);
      },
      withCircuit: function(circuitDefinition) {
        return new DisplayedCircuit(this.top, circuitDefinition, this._compressedColumnIndex, this._highlightedSlot, this._extraWireStartIndex);
      },
      _withCompressedColumnIndex: function(compressedColumnIndex) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, compressedColumnIndex, this._highlightedSlot, this._extraWireStartIndex);
      },
      _withHighlightedSlot: function(slot) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, this._compressedColumnIndex, slot, this._extraWireStartIndex);
      },
      _withExtraWireStartIndex: function(extraWireStartIndex) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, this._compressedColumnIndex, this._highlightedSlot, extraWireStartIndex);
      },
      _withFallbackExtraWireStartIndex: function(fallbackExtraWireStartIndex) {
        return this._withExtraWireStartIndex(this._extraWireStartIndex || fallbackExtraWireStartIndex);
      },
      withJustEnoughWires: function(hand, extraWireCount) {
        var neededWireCountForPlacement = hand.heldGate !== undefined ? hand.heldGate.height : 0;
        var desiredWireCount = this.circuitDefinition.minimumRequiredWireCount();
        var clampedWireCount = Math.min(Config.MAX_WIRE_COUNT, Math.max(Math.min(1, neededWireCountForPlacement), Math.max(Config.MIN_WIRE_COUNT, desiredWireCount) + extraWireCount));
        return this.withCircuit(this.circuitDefinition.withWireCount(clampedWireCount))._withExtraWireStartIndex(extraWireCount === 0 ? undefined : this.circuitDefinition.numWires);
      },
      findGateOverlappingPos: function(pos) {
        var col = this.indexOfDisplayedColumnAt(pos.x);
        var row = this.indexOfDisplayedRowAt(pos.y);
        if (col === undefined || row === undefined) {
          return undefined;
        }
        var target = this.circuitDefinition.findGateCoveringSlot(col, row);
        if (target === undefined) {
          return undefined;
        }
        var gateRect = this.gateRect(target.row, target.col, target.gate.width, target.gate.height);
        if (!gateRect.containsPoint(pos)) {
          return undefined;
        }
        return {
          col: target.col,
          row: target.row,
          offset: pos.minus(gateRect.topLeft())
        };
      },
      findGateWithButtonContaining: function(pos) {
        var foundPt = this.findGateOverlappingPos(pos);
        if (foundPt === undefined) {
          return undefined;
        }
        var gate = this.circuitDefinition.gateInSlot(foundPt.col, foundPt.row);
        if (gate.onClickGateFunc === undefined) {
          return undefined;
        }
        var buttonRect = GatePainting.gateButtonRect(this.gateRect(foundPt.row, foundPt.col, gate.width, gate.height));
        if (!buttonRect.containsPoint(pos)) {
          return undefined;
        }
        return {
          col: foundPt.col,
          row: foundPt.row,
          gate: gate
        };
      },
      tryClick: function(hand) {
        if (hand.pos === undefined) {
          return undefined;
        }
        var found = this.findGateWithButtonContaining(hand.pos);
        if (found === undefined) {
          return undefined;
        }
        var newGate = found.gate.onClickGateFunc(found.gate);
        var cols = $traceurRuntime.spread(this.circuitDefinition.columns);
        var col = cols[found.col];
        var gates = $traceurRuntime.spread(col.gates);
        gates.splice(found.row, 1, newGate);
        cols.splice(found.col, 1, new GateColumn(gates));
        return this.withCircuit(this.circuitDefinition.withColumns(cols));
      },
      tryGrab: function(hand) {
        var duplicate = arguments[1] !== (void 0) ? arguments[1] : false;
        var wholeColumn = arguments[2] !== (void 0) ? arguments[2] : false;
        var ignoreResizeTabs = arguments[3] !== (void 0) ? arguments[3] : false;
        if (wholeColumn) {
          return this._tryGrabWholeColumn(hand, duplicate) || {
            newCircuit: this,
            newHand: hand
          };
        }
        var newHand = hand;
        var newCircuit = this;
        if (!ignoreResizeTabs) {
          var resizing = this._tryGrabResizeTab(hand);
          if (resizing !== undefined) {
            newHand = resizing.newHand;
            newCircuit = resizing.newCircuit;
          }
        }
        return newCircuit._tryGrabGate(newHand, duplicate) || {
          newCircuit: newCircuit,
          newHand: newHand
        };
      },
      _tryGrabGate: function(hand) {
        var duplicate = arguments[1] !== (void 0) ? arguments[1] : false;
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        var foundPt = this.findGateOverlappingPos(hand.pos);
        if (foundPt === undefined) {
          return undefined;
        }
        var $__10 = foundPt,
            col = $__10.col,
            row = $__10.row,
            offset = $__10.offset;
        var gate = this.circuitDefinition.columns[col].gates[row];
        var remainingGates = seq(this.circuitDefinition.columns[col].gates).toArray();
        if (!duplicate) {
          remainingGates[row] = undefined;
        }
        var newCols = seq(this.circuitDefinition.columns).withOverlayedItem(col, new GateColumn(remainingGates)).toArray();
        return {
          newCircuit: new DisplayedCircuit(this.top, this.circuitDefinition.withColumns(newCols), undefined, undefined, this._extraWireStartIndex),
          newHand: hand.withHeldGate(gate, offset)
        };
      },
      _tryGrabResizeTab: function(hand) {
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        for (var col = 0; col < this.circuitDefinition.columns.length; col++) {
          for (var row = 0; row < this.circuitDefinition.numWires; row++) {
            var gate = this.circuitDefinition.columns[col].gates[row];
            if (gate === undefined) {
              continue;
            }
            var isResizeHighlighted = this._highlightStatusAt(col, row, hand.hoverPoints()).isResizeHighlighted;
            if (isResizeHighlighted) {
              var offset = hand.pos.minus(this.gateRect(row + gate.height - 1, col, 1, 1).center());
              return {
                newCircuit: this._withHighlightedSlot({
                  col: col,
                  row: row,
                  resizeStyle: true
                }),
                newHand: hand.withResizeSlot(new Point(col, row), offset)
              };
            }
          }
        }
        return undefined;
      },
      _tryGrabWholeColumn: function(hand, duplicate) {
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        var col = Math.round(this.toColumnSpaceCoordinate(hand.pos.x));
        if (col < 0 || col >= this.circuitDefinition.columns.length || this.circuitDefinition.columns[col].isEmpty()) {
          return undefined;
        }
        var newCols = $traceurRuntime.spread(this.circuitDefinition.columns);
        if (!duplicate) {
          newCols.splice(col, 1, GateColumn.empty(this.circuitDefinition.numWires));
        }
        var holdOffset = new Point(0, this.wireIndexAt(hand.pos.y) * Config.WIRE_SPACING + Config.WIRE_SPACING / 2);
        return {
          newCircuit: this.withCircuit(this.circuitDefinition.withColumns(newCols)),
          newHand: hand.withHeldGateColumn(this.circuitDefinition.columns[col], holdOffset)
        };
      },
      stableDuration: function() {
        return this.circuitDefinition.stableDuration();
      },
      importantWireCount: function() {
        return Math.max(this.circuitDefinition.numWires - (this._extraWireStartIndex === Config.MAX_WIRE_COUNT ? 0 : 1), Config.MIN_WIRE_COUNT, this.circuitDefinition.minimumRequiredWireCount());
      },
      _drawOutputDisplays: function(painter, stats, hand) {
        var chanceCol = this.clampedCircuitColCount() + 1;
        var blochCol = chanceCol + 1;
        var numWire = this.importantWireCount();
        for (var i = 0; i < numWire; i++) {
          var p = stats.controlledWireProbabilityJustAfter(i, Infinity);
          MathPainter.paintProbabilityBox(painter, p, this.gateRect(i, chanceCol), hand.hoverPoints());
          var m = stats.qubitDensityMatrix(Infinity, i);
          if (m !== undefined) {
            paintBlochSphereDisplay(painter, m, this.gateRect(i, blochCol), hand.hoverPoints());
          }
        }
        var bottom = this.wireRect(numWire - 1).bottom();
        var x = this.opRect(chanceCol - 1).x;
        painter.printParagraph("Local wire states\n(Chance/Bloch)", new Rect(x, bottom + 4, 190, 40), new Point(0.5, 0), 'gray');
        this._drawOutputSuperpositionDisplay(painter, stats, hand);
      },
      clampedCircuitColCount: function() {
        return Math.max(this.circuitDefinition.columns.length, Config.MIN_COL_COUNT + (this._compressedColumnIndex !== undefined ? 1 : 0));
      },
      _drawOutputSuperpositionDisplay: function(painter, stats, hand) {
        var amplitudeGrid = this._outputStateAsMatrix(stats);
        var gridRect = this._rectForSuperpositionDisplay();
        var numWire = this.importantWireCount();
        MathPainter.paintMatrix(painter, amplitudeGrid, gridRect, numWire < Config.SIMPLE_SUPERPOSITION_DRAWING_WIRE_THRESHOLD ? Config.SUPERPOSITION_MID_COLOR : undefined, 'black', numWire < Config.SIMPLE_SUPERPOSITION_DRAWING_WIRE_THRESHOLD ? Config.SUPERPOSITION_FORE_COLOR : undefined, Config.SUPERPOSITION_BACK_COLOR);
        var forceSign = function(v) {
          return (v >= 0 ? '+' : '') + v.toFixed(2);
        };
        MathPainter.paintMatrixTooltip(painter, amplitudeGrid, gridRect, hand.hoverPoints(), function(c, r) {
          return ("Amplitude of |" + Util.bin(r * amplitudeGrid.width() + c, numWire) + "⟩");
        }, function(c, r, v) {
          return 'val:' + v.toString(new Format(false, 0, 5, ", "));
        }, function(c, r, v) {
          return ("mag²:" + (v.norm2() * 100).toFixed(4) + "%, phase:" + forceSign(v.phase() * 180 / Math.PI) + "°");
        });
        this._drawOutputSuperpositionDisplay_labels(painter);
      },
      _drawOutputSuperpositionDisplay_labels: function(painter) {
        var gridRect = this._rectForSuperpositionDisplay();
        var numWire = this.importantWireCount();
        _cachedRowLabelDrawer.paint(gridRect.right(), gridRect.y, painter, numWire);
        _cachedColLabelDrawer.paint(gridRect.x, gridRect.bottom(), painter, numWire);
      },
      _outputStateAsMatrix: function(stats) {
        var $__11,
            $__12,
            $__14,
            $__15;
        var numWire = this.importantWireCount();
        var buf = stats.finalState.rawBuffer();
        if (stats.circuitDefinition.numWires !== numWire) {
          var r = new Float32Array(2 << numWire);
          r.set(buf.slice(0, r.length));
          buf = r;
        }
        var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
            colWires = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
            rowWires = ($__12 = $__11.next()).done ? void 0 : $__12.value;
        var $__13 = [1 << colWires, 1 << rowWires],
            colCount = ($__14 = $__13[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
            rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
        return new Matrix(colCount, rowCount, buf);
      },
      _rectForSuperpositionDisplay: function() {
        var $__13,
            $__11,
            $__14,
            $__15;
        var col = this.clampedCircuitColCount() + EXTRA_COLS_FOR_SINGLE_QUBIT_DISPLAYS + 1;
        var numWire = this.importantWireCount();
        var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
            colWires = ($__13 = $__10[Symbol.iterator](), ($__11 = $__13.next()).done ? void 0 : $__11.value),
            rowWires = ($__11 = $__13.next()).done ? void 0 : $__11.value;
        var $__12 = [1 << colWires, 1 << rowWires],
            colCount = ($__14 = $__12[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
            rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
        var topRect = this.gateRect(0, col);
        var bottomRect = this.gateRect(numWire - 1, col);
        var gridRect = new Rect(topRect.x, topRect.y, 0, bottomRect.bottom() - topRect.y);
        return gridRect.withW(gridRect.h * (colCount / rowCount));
      },
      _drawHintLabels: function(painter, stats) {
        var gridRect = this._rectForSuperpositionDisplay();
        painter.print('Final amplitudes', gridRect.right() + 3, gridRect.bottom() + 3, 'left', 'top', 'gray', '12px sans-serif', 100, 20);
        if (this.circuitDefinition.colIsMeasuredMask(Infinity) !== 0) {
          painter.printParagraph("(assuming measurement deferred)", new Rect(gridRect.right() + 3, gridRect.bottom() + 20, 100, 75), new Point(0.5, 0), 'red');
        }
        var survivalRate = stats.survivalRate(Infinity);
        if (Math.abs(survivalRate - 1) > 0.01) {
          var desc;
          if (survivalRate < 1) {
            var rate = Math.round(survivalRate * 100);
            var rateDesc = survivalRate === 0 ? "0" : rate > 0 ? rate : "<1";
            desc = ("kept: " + rateDesc + "%");
          } else {
            var factor = Math.round(survivalRate * 100);
            desc = ("over-unity: " + factor + "%");
          }
          painter.print(desc, this._rectForSuperpositionDisplay().x - 5, gridRect.bottom() + SUPERPOSITION_GRID_LABEL_SPAN, 'right', 'bottom', 'red', '14px sans-serif', 800, 50);
        }
      }
    }, {
      empty: function(top) {
        return new DisplayedCircuit(top, new CircuitDefinition(Config.MIN_WIRE_COUNT, []), undefined, undefined, undefined);
      },
      fromTextDiagram: function(gateMap, diagramText) {
        var lines = diagramText.split('\n').map(function(e) {
          var p = e.split('|');
          if (p.length !== 2) {
            throw new DetailedError('Bad diagram', {
              diagramText: diagramText,
              gateMap: gateMap
            });
          }
          return p[1];
        });
        var circuitDiagramSubset = seq(lines).skip(1).stride(2).map(function(line) {
          return seq(line).skip(1).stride(2).join("");
        }).join('\n');
        var top = 10;
        var circuit = new DisplayedCircuit(top, CircuitDefinition.fromTextDiagram(gateMap, circuitDiagramSubset), undefined, undefined, undefined);
        var pts = Seq.naturals().takeWhile(function(k) {
          return diagramText.indexOf(k) !== -1;
        }).map(function(k) {
          var pos = seq(lines).mapWithIndex(function(line, row) {
            return ({
              row: row,
              col: line.indexOf(k)
            });
          }).filter(function(e) {
            return e.col !== -1;
          }).single();
          if (lines[pos.row][pos.col + 1] === '^') {
            pos.row -= 1;
            pos.col += 1;
          }
          return new Point(pos.col * Config.WIRE_SPACING / 2 + 35.5, pos.row * Config.WIRE_SPACING / 2 + 10.5);
        }).toArray();
        return {
          circuit: circuit,
          pts: pts
        };
      }
    });
  }();
  function drawCircuitTooltip(painter, circuitDefinition, rect, showWires, time) {
    var displayed = new DisplayedCircuit(0, circuitDefinition, undefined, undefined, undefined);
    var neededWidth = displayed.desiredWidth(true);
    var neededHeight = displayed.desiredHeight(true);
    var scaleX = rect.w / neededWidth;
    var scaleY = rect.h / neededHeight;
    if (showWires) {
      var s = Math.min(scaleX, scaleY);
      scaleX = s;
      scaleY = s;
    }
    var stats = CircuitStats.withNanDataFromCircuitAtTime(circuitDefinition, time);
    try {
      painter.ctx.save();
      painter.ctx.translate(rect.x, rect.y);
      painter.ctx.scale(Math.min(1, scaleX), Math.min(1, scaleY));
      painter.ctx.translate(0, 0);
      displayed.paint(painter, Hand.EMPTY, stats, true, showWires);
    } finally {
      painter.ctx.restore();
    }
    return {
      maxW: neededWidth * scaleX,
      maxH: neededHeight * scaleY
    };
  }
  var GATE_CIRCUIT_DRAWER = function(args) {
    var circuit = args.gate.knownCircuit;
    if (circuit === undefined || args.gate.symbol !== '') {
      if (args.gate.stableDuration() === Infinity) {
        GatePainting.DEFAULT_DRAWER(args);
      } else {
        GatePainting.makeCycleDrawer()(args);
      }
      return;
    }
    var toolboxColor = args.gate.stableDuration() === Infinity ? Config.GATE_FILL_COLOR : Config.TIME_DEPENDENT_HIGHLIGHT_COLOR;
    GatePainting.paintBackground(args, toolboxColor);
    drawCircuitTooltip(args.painter, args.gate.knownCircuitNested, args.rect, false, args.stats.time);
    GatePainting.paintOutline(args);
    if (args.isHighlighted) {
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.9;
      args.painter.fillRect(args.rect, Config.HIGHLIGHTED_GATE_FILL_COLOR);
      args.painter.ctx.restore();
    }
    GatePainting.paintOutline(args);
  };
  function _drawLabelsReasonablyFast(painter, dy, n, labeller, boundingWidth) {
    var ctx = painter.ctx;
    ctx.save();
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    painter.ctx.font = '12px monospace';
    var w = Math.max(painter.ctx.measureText(labeller(0)).width, painter.ctx.measureText(labeller(n - 1)).width);
    var h = ctx.measureText("0").width * 2.5;
    var scale = Math.min(Math.min((boundingWidth - 2) / w, dy / h), 1);
    var step = dy / scale;
    var pad = 1 / scale;
    ctx.scale(scale, scale);
    ctx.translate(0, dy * 0.5 / scale - h * 0.5);
    ctx.fillStyle = 'lightgray';
    if (h < step * 0.95) {
      for (var i = 0; i < n; i++) {
        ctx.fillRect(0, step * i, w + 2 * pad, h);
      }
    } else {
      ctx.fillRect(0, 0, w + 2 * pad, step * n);
    }
    ctx.fillStyle = 'black';
    for (var i$__19 = 0; i$__19 < n; i$__19++) {
      ctx.fillText(labeller(i$__19), pad, h * 0.5 + step * i$__19);
    }
    ctx.restore();
  }
  var _cachedRowLabelDrawer = new CachablePainting(function(numWire) {
    return ({
      width: SUPERPOSITION_GRID_LABEL_SPAN,
      height: (numWire - 1) * Config.WIRE_SPACING + Config.GATE_RADIUS * 2
    });
  }, function(painter, numWire) {
    var $__12,
        $__13;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__12 = $__10[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
        rowWires = ($__13 = $__12.next()).done ? void 0 : $__13.value;
    var rowCount = 1 << rowWires;
    var suffix = colWires < 4 ? "_".repeat(colWires) : "_..";
    _drawLabelsReasonablyFast(painter, painter.canvas.height / rowCount, rowCount, function(i) {
      return Util.bin(i, rowWires) + suffix;
    }, SUPERPOSITION_GRID_LABEL_SPAN);
  });
  var _cachedColLabelDrawer = new CachablePainting(function(numWire) {
    var $__12,
        $__13,
        $__14,
        $__15;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__12 = $__10[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
        rowWires = ($__13 = $__12.next()).done ? void 0 : $__13.value;
    var $__11 = [1 << colWires, 1 << rowWires],
        colCount = ($__14 = $__11[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
        rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
    var total_height = (numWire - 1) * Config.WIRE_SPACING + Config.GATE_RADIUS * 2;
    var cellDiameter = total_height / rowCount;
    return {
      width: colCount * cellDiameter,
      height: SUPERPOSITION_GRID_LABEL_SPAN
    };
  }, function(painter, numWire) {
    var $__11,
        $__12;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
        rowWires = ($__12 = $__11.next()).done ? void 0 : $__12.value;
    var colCount = 1 << colWires;
    var dw = painter.canvas.width / colCount;
    painter.ctx.translate(colCount * dw, 0);
    painter.ctx.rotate(Math.PI / 2);
    var prefix = rowWires < 4 ? "_".repeat(rowWires) : ".._";
    _drawLabelsReasonablyFast(painter, dw, colCount, function(i) {
      return prefix + Util.bin(colCount - 1 - i, colWires);
    }, SUPERPOSITION_GRID_LABEL_SPAN);
  });
  return {
    get DisplayedCircuit() {
      return DisplayedCircuit;
    },
    get drawCircuitTooltip() {
      return drawCircuitTooltip;
    },
    get GATE_CIRCUIT_DRAWER() {
      return GATE_CIRCUIT_DRAWER;
    }
  };
});
//# sourceURL=src/ui/DisplayedCircuit.js
;$traceurRuntime.registerModule("src/ui/DisplayedInspector.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/DisplayedInspector.js";
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitDefinition.js", "src/ui/DisplayedInspector.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitStats.js", "src/ui/DisplayedInspector.js")).CircuitStats;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/DisplayedInspector.js")).Config;
  var DisplayedCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/DisplayedCircuit.js", "src/ui/DisplayedInspector.js")).DisplayedCircuit;
  var DisplayedToolbox = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/DisplayedToolbox.js", "src/ui/DisplayedInspector.js")).DisplayedToolbox;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GateDrawParams.js", "src/ui/DisplayedInspector.js")).GateDrawParams;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/ui/DisplayedInspector.js")).GatePainting;
  var Gates = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/AllGates.js", "src/ui/DisplayedInspector.js")).Gates;
  var Hand = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/Hand.js", "src/ui/DisplayedInspector.js")).Hand;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/Painter.js", "src/ui/DisplayedInspector.js")).Painter;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/ui/DisplayedInspector.js")).Rect;
  var Serializer = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Serializer.js", "src/ui/DisplayedInspector.js")).Serializer;
  var DisplayedInspector = function() {
    function DisplayedInspector(drawArea, circuitWidget, displayedToolboxTop, hand) {
      this.displayedCircuit = circuitWidget;
      this.displayedToolboxTop = displayedToolboxTop;
      this.hand = hand;
      this.drawArea = new Rect(0, 0, 0, 0);
      this.updateArea(drawArea);
    }
    return ($traceurRuntime.createClass)(DisplayedInspector, {
      desiredWidth: function() {
        return Math.max(this.displayedToolboxTop.desiredWidth(), Math.max(this.displayedCircuit.desiredWidth()));
      },
      updateArea: function(drawArea) {
        this.drawArea = drawArea;
        this.displayedToolboxTop = this.displayedToolboxTop.withTop(0);
      },
      paint: function(painter, stats) {
        painter.fillRect(this.drawArea, Config.BACKGROUND_COLOR);
        this.displayedToolboxTop.paint(painter, stats, this.hand);
        this.displayedCircuit.paint(painter, this.hand, stats);
        this._paintHand(painter, stats);
        this._drawHint(painter);
      },
      _paintHand: function(painter, stats) {
        if (this.hand.pos === undefined || this.hand.heldGate === undefined) {
          return;
        }
        var gate = this.hand.heldGate;
        var pos = this.hand.pos.minus(this.hand.holdOffset);
        var rect = new Rect(Math.round(pos.x - 0.5) + 0.5, Math.round(pos.y - 0.5) + 0.5, Config.GATE_RADIUS * 2 + Config.WIRE_SPACING * (gate.width - 1), Config.GATE_RADIUS * 2 + Config.WIRE_SPACING * (gate.height - 1));
        var drawer = gate.customDrawer || GatePainting.DEFAULT_DRAWER;
        drawer(new GateDrawParams(painter, false, true, true, false, rect, gate, stats, undefined, [], undefined));
      },
      isHandOverButtonKey: function() {
        if (this.hand.pos === undefined) {
          return undefined;
        }
        var pos = this.displayedCircuit.findGateWithButtonContaining(this.hand.pos);
        return pos === undefined ? undefined : pos.col + ':' + pos.row;
      },
      tryClick: function() {
        var newDisplayedCircuit = this.displayedCircuit.tryClick(this.hand);
        return newDisplayedCircuit === undefined ? undefined : this.withDisplayedCircuit(newDisplayedCircuit);
      },
      afterGrabbing: function() {
        var duplicate = arguments[0] !== (void 0) ? arguments[0] : false;
        var wholeCol = arguments[1] !== (void 0) ? arguments[1] : false;
        var ignoreResizeTabs = arguments[2] !== (void 0) ? arguments[2] : false;
        var hand = this.hand;
        var circuit = this.displayedCircuit;
        hand = this.displayedToolboxTop.tryGrab(hand);
        var obj = circuit.tryGrab(hand, duplicate, wholeCol, ignoreResizeTabs);
        hand = obj.newHand;
        circuit = obj.newCircuit;
        return new DisplayedInspector(this.drawArea, circuit, this.displayedToolboxTop, hand);
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof DisplayedInspector && this.drawArea.isEqualTo(other.drawArea) && this.displayedCircuit.isEqualTo(other.displayedCircuit) && this.displayedToolboxTop.isEqualTo(other.displayedToolboxTop) && this.hand.isEqualTo(other.hand);
      },
      withDisplayedCircuit: function(displayedCircuit) {
        if (displayedCircuit === this.displayedCircuit) {
          return this;
        }
        return new DisplayedInspector(this.drawArea, displayedCircuit, this.displayedToolboxTop, this.hand);
      },
      withJustEnoughWires: function(hand, extraWires) {
        return this.withDisplayedCircuit(this.displayedCircuit.withJustEnoughWires(hand, extraWires));
      },
      afterTidyingUp: function() {
        return this.withDisplayedCircuit(this.displayedCircuit.afterTidyingUp());
      },
      previewDrop: function() {
        if (!this.hand.isBusy()) {
          return this;
        }
        var hand = this.hand;
        var circuitWidget = this.displayedCircuit;
        var previewCircuit = circuitWidget.previewDrop(hand);
        var previewHand = previewCircuit === circuitWidget ? hand : hand.withDrop();
        return this.withHand(previewHand).withDisplayedCircuit(previewCircuit);
      },
      afterDropping: function() {
        return this.withDisplayedCircuit(this.displayedCircuit.afterDropping(this.hand)).withHand(this.hand.withDrop());
      },
      stableDuration: function() {
        return Math.min(this.displayedToolboxTop.stableDuration(this.hand), this.hand.stableDuration(), this.displayedCircuit.stableDuration());
      },
      withHand: function(hand) {
        return new DisplayedInspector(this.drawArea, this.displayedCircuit, this.displayedToolboxTop, hand);
      },
      withCircuitDefinition: function(newCircuitDefinition) {
        return new DisplayedInspector(this.drawArea, DisplayedCircuit.empty(this.displayedToolboxTop.desiredHeight()).withCircuit(newCircuitDefinition), this.displayedToolboxTop, this.hand.withDrop());
      },
      desiredHeight: function() {
        var minimumDesired = this.displayedToolboxTop.desiredHeight() + this.displayedCircuit.desiredHeight();
        return Math.max(Config.MINIMUM_CANVAS_HEIGHT, minimumDesired);
      },
      snapshot: function() {
        return JSON.stringify(Serializer.toJson(this.displayedCircuit.circuitDefinition), null, 0);
      },
      _drawHint: function(painter) {
        this._drawHint_dragGatesOntoCircuit(painter);
        this._drawHint_watchOutputsChange(painter);
        this._drawHint_useControls(painter);
      },
      _watchOutputsChangeVisibility: function() {
        var gatesInCircuit = this.displayedCircuit.circuitDefinition.countGatesUpTo(2);
        var gatesInPlay = gatesInCircuit + (this.hand.isBusy() ? 1 : 0);
        if (gatesInCircuit >= 2 || gatesInPlay === 0) {
          return 0;
        }
        var handPosY = this.hand.pos === undefined ? Infinity : this.hand.pos.y;
        return gatesInCircuit === 0 ? (handPosY - 125) / 25 : gatesInPlay === 2 ? (150 - handPosY) / 25 : 1.0;
      },
      _drawHint_watchOutputsChange: function(painter) {
        var visibilityFactor = this._watchOutputsChangeVisibility();
        if (visibilityFactor <= 0) {
          return;
        }
        painter.ctx.save();
        painter.ctx.globalAlpha *= Math.min(1, visibilityFactor);
        painter.ctx.translate(this.displayedCircuit.opRect(this.displayedCircuit.clampedCircuitColCount()).x - 280, 15);
        painter.ctx.save();
        painter.ctx.translate(268, 250);
        painter.ctx.rotate(Math.PI * 0.02);
        painter.ctx.fillStyle = 'red';
        painter.ctx.textAlign = 'right';
        painter.ctx.font = '16px sans-serif';
        painter.ctx.fillText("outputs change", 0, 0);
        painter.ctx.restore();
        painter.ctx.beginPath();
        painter.ctx.moveTo(270, 245);
        painter.ctx.bezierCurveTo(300, 245, 315, 235, 325, 225);
        painter.ctx.strokeStyle = 'red';
        painter.ctx.lineWidth = 3;
        painter.ctx.stroke();
        painter.trace(function(tracer) {
          tracer.arrowHead(330, 219, 10, Math.PI * -0.265, 1.3);
        }).thenFill('red');
        painter.ctx.restore();
      },
      _drawHint_dragGatesOntoCircuit: function(painter) {
        if (this.displayedCircuit.circuitDefinition.hasNonControlGates()) {
          return;
        }
        var visibilityFactor = this.hand.pos === undefined || !this.hand.isBusy() ? 1.0 : this.hand.heldGate !== undefined && this.hand.heldGate.isControl() ? 1.0 : (150 - this.hand.pos.y) / 50;
        if (visibilityFactor <= 0) {
          return;
        }
        painter.ctx.save();
        painter.ctx.globalAlpha *= Math.min(1, visibilityFactor);
        painter.ctx.save();
        painter.ctx.translate(70, 190);
        painter.ctx.rotate(Math.PI * 0.05);
        painter.ctx.fillStyle = 'red';
        painter.ctx.font = '16px sans-serif';
        painter.ctx.fillText("drag gates onto circuit", 0, 0);
        painter.ctx.restore();
        painter.ctx.beginPath();
        painter.ctx.moveTo(268, 132);
        painter.ctx.bezierCurveTo(260, 170, 235, 175, 217, 187);
        painter.ctx.strokeStyle = 'red';
        painter.ctx.lineWidth = 3;
        painter.ctx.stroke();
        painter.trace(function(tracer) {
          tracer.arrowHead(210, 190, 10, Math.PI * 0.84, 1.3);
        }).thenFill('red');
        painter.ctx.restore();
      },
      _useControlsHintVisibility: function() {
        var circ = this.displayedCircuit.circuitDefinition;
        var gatesInCircuit = circ.countGatesUpTo(2);
        var gatesInPlay = gatesInCircuit + (this.hand.heldGate !== undefined ? 1 : 0);
        var gate = circ.gateInSlot(0, 0);
        if (circ.hasControls() || !circ.hasNonControlGates() || (gate !== undefined && gate.height > 1)) {
          return 0;
        }
        if (gatesInCircuit === 1 && gatesInPlay === 1 && !this.displayedCircuit.isBeingEdited()) {
          return 1;
        }
        if (gatesInCircuit === 1 && gatesInPlay === 2 && this.displayedCircuit.isBeingEdited()) {
          return (150 - this.hand.pos.y) / 50;
        }
        return 0;
      },
      _drawHint_useControls: function(painter) {
        var visibilityFactor = this._useControlsHintVisibility();
        if (visibilityFactor <= 0) {
          return;
        }
        painter.ctx.save();
        painter.ctx.globalAlpha *= Math.min(1, visibilityFactor);
        var firstSlotAvailable = this.displayedCircuit.circuitDefinition.gateInSlot(0, 0) === undefined;
        var fy = firstSlotAvailable ? 173 : 223;
        painter.ctx.save();
        painter.ctx.translate(70, fy - 3);
        painter.ctx.rotate(Math.PI * -0.01);
        painter.ctx.fillStyle = 'red';
        painter.ctx.font = '16px sans-serif';
        painter.ctx.fillText("use controls", 0, 0);
        painter.ctx.restore();
        painter.ctx.beginPath();
        if (firstSlotAvailable) {
          painter.ctx.moveTo(90, 125);
          painter.ctx.bezierCurveTo(60, 140, 48, 160, 55, fy);
        } else {
          painter.ctx.moveTo(100, 125);
          painter.ctx.bezierCurveTo(115, 150, 105, 170, 55, fy);
        }
        painter.ctx.strokeStyle = 'red';
        painter.ctx.lineWidth = 3;
        painter.ctx.stroke();
        painter.ctx.beginPath();
        painter.ctx.arc(55, fy, 5, 0, 2 * Math.PI);
        painter.ctx.fillStyle = 'red';
        painter.ctx.fill();
        painter.ctx.restore();
      }
    }, {empty: function(drawArea) {
        var topToolbox = new DisplayedToolbox('Toolbox', 0, Gates.TopToolboxGroups, true, 3);
        var displayedCircuit = DisplayedCircuit.empty(topToolbox.desiredHeight());
        return new DisplayedInspector(drawArea, displayedCircuit, topToolbox, Hand.EMPTY);
      }});
  }();
  return {get DisplayedInspector() {
      return DisplayedInspector;
    }};
});
//# sourceURL=src/ui/DisplayedInspector.js
;$traceurRuntime.registerModule("src/ui/DisplayedTimeLine.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/DisplayedTimeLine.js";
  var CachablePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/CachablePainting.js", "src/ui/DisplayedTimeLine.js")).CachablePainting;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitDefinition.js", "src/ui/DisplayedTimeLine.js")).CircuitDefinition;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitStats.js", "src/ui/DisplayedTimeLine.js")).CircuitStats;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/DisplayedTimeLine.js")).Config;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/ui/DisplayedTimeLine.js")).DetailedError;
  var equate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Equate.js", "src/ui/DisplayedTimeLine.js")).equate;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/ui/DisplayedTimeLine.js")).Format;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateColumn.js", "src/ui/DisplayedTimeLine.js")).GateColumn;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GateDrawParams.js", "src/ui/DisplayedTimeLine.js")).GateDrawParams;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/ui/DisplayedTimeLine.js")).GatePainting;
  var Hand = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/Hand.js", "src/ui/DisplayedTimeLine.js")).Hand;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/ui/DisplayedTimeLine.js")).MathPainter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/ui/DisplayedTimeLine.js")).Point;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/ui/DisplayedTimeLine.js")).Matrix;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/ui/DisplayedTimeLine.js")).Rect;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/ui/DisplayedTimeLine.js")).Util;
  var $__36 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/ui/DisplayedTimeLine.js")),
      seq = $__36.seq,
      Seq = $__36.Seq;
  var paintBlochSphereDisplay = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/BlochSphereDisplay.js", "src/ui/DisplayedTimeLine.js")).paintBlochSphereDisplay;
  var CIRCUIT_OP_HORIZONTAL_SPACING = 10;
  var CIRCUIT_OP_LEFT_SPACING = 35;
  var SUPERPOSITION_GRID_LABEL_SPAN = 50;
  var EXTRA_COLS_FOR_SINGLE_QUBIT_DISPLAYS = 2;
  var DisplayedTimeLine = function() {
    function DisplayedTimeLine(top, circuitDefinition, compressedColumnIndex, highlightedSlot, extraWireStartIndex) {
      if (!Number.isFinite(top)) {
        throw new DetailedError("Bad top", {
          top: top,
          circuitDefinition: circuitDefinition
        });
      }
      if (!(circuitDefinition instanceof CircuitDefinition)) {
        throw new DetailedError("Bad circuitDefinition", {
          top: top,
          circuitDefinition: circuitDefinition
        });
      }
      this.top = top;
      this.circuitDefinition = circuitDefinition;
      this._compressedColumnIndex = compressedColumnIndex;
      this._highlightedSlot = highlightedSlot;
      this._extraWireStartIndex = extraWireStartIndex;
    }
    return ($traceurRuntime.createClass)(DisplayedTimeLine, {
      isBeingEdited: function() {
        return this._extraWireStartIndex !== undefined;
      },
      _groundedWireCount: function() {
        var pseudoCount = this._extraWireStartIndex !== undefined && this._extraWireStartIndex !== Config.MAX_WIRE_COUNT ? 1 : 0;
        var n = Math.max(Config.MIN_WIRE_COUNT, this.circuitDefinition.numWires) - pseudoCount;
        return Math.max(n, this.circuitDefinition.minimumRequiredWireCount());
      },
      desiredHeight: function() {
        var forTooltip = arguments[0] !== (void 0) ? arguments[0] : false;
        if (forTooltip) {
          return this.circuitDefinition.numWires * Config.WIRE_SPACING;
        }
        return this._groundedWireCount() * Config.WIRE_SPACING + 55;
      },
      desiredWidth: function() {
        var forTooltip = arguments[0] !== (void 0) ? arguments[0] : false;
        if (forTooltip) {
          return this.opRect(this.circuitDefinition.columns.length - 1).right() + CIRCUIT_OP_LEFT_SPACING;
        }
        return this._rectForSuperpositionDisplay().right() + 101;
      },
      wireRect: function(wireIndex) {
        if (wireIndex < 0) {
          throw new DetailedError("Bad wireIndex", {wireIndex: wireIndex});
        }
        return new Rect(0, this.top + Config.WIRE_SPACING * wireIndex, Infinity, Config.WIRE_SPACING);
      },
      wireIndexAt: function(y) {
        return Math.floor((y - this.top) / Config.WIRE_SPACING);
      },
      toColumnSpaceCoordinate: function(x) {
        var spacing = (CIRCUIT_OP_HORIZONTAL_SPACING + Config.GATE_RADIUS * 2);
        var left = CIRCUIT_OP_LEFT_SPACING - CIRCUIT_OP_HORIZONTAL_SPACING / 2;
        return (x - left) / spacing - 0.5;
      },
      indexOfDisplayedRowAt: function(y) {
        var i = Math.floor((y - this.top) / Config.WIRE_SPACING);
        if (i < 0 || i >= this.circuitDefinition.numWires) {
          return undefined;
        }
        return i;
      },
      indexOfDisplayedColumnAt: function(x) {
        var col = this.toColumnSpaceCoordinate(x);
        var i;
        if (this._compressedColumnIndex === undefined || col < this._compressedColumnIndex - 0.75) {
          i = Math.round(col);
        } else if (col < this._compressedColumnIndex - 0.25) {
          i = this._compressedColumnIndex;
        } else {
          i = Math.round(col) - 1;
        }
        if (i < 0 || i >= this.circuitDefinition.columns.length) {
          return undefined;
        }
        return i;
      },
      findOpHalfColumnAt: function(p) {
        if (p.x < 0 || p.y < this.top || p.y > this.top + this.desiredHeight()) {
          return undefined;
        }
        return Math.max(-0.5, Math.round(this.toColumnSpaceCoordinate(p.x) * 2) / 2);
      },
      _findModificationIndex_helperColRow: function(hand) {
        if (hand.pos === undefined || hand.heldGate === undefined) {
          return undefined;
        }
        var pos = hand.pos.minus(hand.holdOffset).plus(new Point(Config.GATE_RADIUS, Config.GATE_RADIUS));
        var halfColIndex = this.findOpHalfColumnAt(pos);
        var row = this.indexOfDisplayedRowAt(pos.y);
        if (halfColIndex === undefined || row === undefined) {
          return undefined;
        }
        var col = Math.ceil(halfColIndex);
        return {
          col: col,
          row: row,
          halfColIndex: halfColIndex
        };
      },
      findModificationIndex: function(hand) {
        var loc = this._findModificationIndex_helperColRow(hand);
        if (loc === undefined) {
          return undefined;
        }
        var $__10 = loc,
            col = $__10.col,
            row = $__10.row,
            halfColIndex = $__10.halfColIndex;
        var isInsert = Math.abs(halfColIndex % 1) === 0.5;
        if (col >= this.circuitDefinition.columns.length) {
          return {
            col: col,
            row: row,
            isInsert: isInsert
          };
        }
        if (!isInsert) {
          var mustInsert = this.circuitDefinition.isSlotRectCoveredByGateInSameColumn(col, row, hand.heldGate.height);
          if (mustInsert) {
            var isAfter = hand.pos.x > this.opRect(col).center().x;
            isInsert = true;
            if (isAfter) {
              col += 1;
            }
          }
        }
        return {
          col: col,
          row: row,
          isInsert: isInsert
        };
      },
      opRect: function(operationIndex) {
        var opWidth = Config.GATE_RADIUS * 2;
        var opSeparation = opWidth + CIRCUIT_OP_HORIZONTAL_SPACING;
        var tweak = 0;
        if (this._compressedColumnIndex !== undefined && operationIndex === this._compressedColumnIndex) {
          tweak = opSeparation / 2;
        }
        if (this._compressedColumnIndex !== undefined && operationIndex > this._compressedColumnIndex) {
          tweak = opSeparation;
        }
        var dx = opSeparation * operationIndex - tweak + CIRCUIT_OP_LEFT_SPACING;
        return new Rect(dx, this.top, opWidth, this.desiredHeight());
      },
      gateRect: function(wireIndex, operationIndex) {
        var width = arguments[2] !== (void 0) ? arguments[2] : 1;
        var height = arguments[3] !== (void 0) ? arguments[3] : 1;
        var op = this.opRect(operationIndex);
        var wire = this.wireRect(wireIndex);
        var r = new Rect(op.center().x - Config.GATE_RADIUS, wire.center().y - Config.GATE_RADIUS, 2 * Config.GATE_RADIUS + (width - 1) * Config.WIRE_SPACING, 2 * Config.GATE_RADIUS + (height - 1) * Config.WIRE_SPACING);
        return new Rect(Math.round(r.x - 0.5) + 0.5, Math.round(r.y - 0.5) + 0.5, Math.round(r.w), Math.round(r.h));
      },
      afterTidyingUp: function() {
        return this.withCircuit(this.circuitDefinition.withUncoveredColumnsRemoved().withHeightOverlapsFixed().withWidthOverlapsFixed().withUncoveredColumnsRemoved().withTrailingSpacersIncluded())._withCompressedColumnIndex(undefined)._withExtraWireStartIndex(undefined)._withHighlightedSlot(undefined);
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof DisplayedCircuit && this.top === other.top && this.circuitDefinition.isEqualTo(other.circuitDefinition) && this._compressedColumnIndex === other._compressedColumnIndex && this._extraWireStartIndex === other._extraWireStartIndex && equate(this._highlightedSlot, other._highlightedSlot);
      },
      paint: function(painter, hand, stats) {
        var forTooltip = arguments[3] !== (void 0) ? arguments[3] : false;
        var showWires = arguments[4] !== (void 0) ? arguments[4] : true;
        if (showWires) {
          this._drawWires(painter, !forTooltip);
        }
        for (var col = 0; col < this.circuitDefinition.columns.length; col++) {
          this._drawColumn(painter, this.circuitDefinition.columns[col], col, hand, stats);
        }
        if (!forTooltip) {
          this._drawOutputDisplays(painter, stats, hand);
          this._drawHintLabels(painter, stats);
        }
      },
      _drawWires: function(painter, showLabels) {
        var $__2 = this;
        var drawnWireCount = Math.min(this.circuitDefinition.numWires, (this._extraWireStartIndex || Infinity) + 1);
        if (showLabels) {
          for (var row = 0; row < drawnWireCount; row++) {
            var wireRect = this.wireRect(row);
            var y = wireRect.center().y;
            painter.print('|0⟩', 20, y, 'right', 'middle', 'black', '14px sans-serif', 20, Config.WIRE_SPACING);
          }
        }
        painter.ctx.save();
        var $__17 = this,
            $__18 = function(row) {
              if (row === $__17._extraWireStartIndex) {
                painter.ctx.globalAlpha *= 0.5;
              }
              painter.trace(function(trace) {
                var wireRect = $__2.wireRect(row);
                var y = Math.round(wireRect.center().y - 0.5) + 0.5;
                var lastX = showLabels ? 25 : 5;
                for (var col = 0; showLabels ? lastX < painter.canvas.width : col <= $__2.circuitDefinition.columns.length; col++) {
                  var x = $__2.opRect(col).center().x;
                  if ($__2.circuitDefinition.locIsMeasured(new Point(col, row))) {
                    trace.line(lastX, y - 1, x, y - 1);
                    trace.line(lastX, y + 1, x, y + 1);
                  } else {
                    trace.line(lastX, y, x, y);
                  }
                  lastX = x;
                }
              }).thenStroke('black');
            };
        for (var row$__16 = 0; row$__16 < drawnWireCount; row$__16++) {
          $__18(row$__16);
        }
        painter.ctx.restore();
        if (this._extraWireStartIndex !== undefined && this.circuitDefinition.numWires === Config.MAX_WIRE_COUNT) {
          painter.print(("(Max wires. Qubit limit is " + Config.MAX_WIRE_COUNT + ".)"), 5, this.wireRect(Config.MAX_WIRE_COUNT).y, 'left', 'top', 'red', '16px bold monospace', 400, Config.WIRE_SPACING);
        }
      },
      _highlightStatusAt: function(col, row, focusPosPts) {
        var $__2 = this;
        if (this._highlightedSlot !== undefined) {
          if (this._highlightedSlot.col === col && this._highlightedSlot.row === row) {
            return {
              isResizeShowing: true,
              isResizeHighlighted: this._highlightedSlot.resizeStyle,
              isHighlighted: !this._highlightedSlot.resizeStyle
            };
          }
        }
        var gate = this.circuitDefinition.gateInSlot(col, row);
        if (gate === undefined || this._highlightedSlot !== undefined) {
          return {
            isResizeShowing: false,
            isResizeHighlighted: false,
            isHighlighted: false
          };
        }
        var gateRect = this.gateRect(row, col, gate.width, gate.height);
        var resizeTabRect = GatePainting.rectForResizeTab(gateRect);
        var isOverGate = function(pos) {
          var overGate = $__2.findGateOverlappingPos(pos);
          return overGate !== undefined && overGate.col === col && overGate.row === row;
        };
        var isNotCoveredAt = function(pos) {
          var g = $__2.findGateOverlappingPos(pos);
          return g === undefined || (g.col === col && g.row === row);
        };
        var isOverGateResizeTab = function(pos) {
          return isNotCoveredAt(pos) && resizeTabRect.containsPoint(pos);
        };
        var isResizeHighlighted = gate.canChangeInSize() && seq(focusPosPts).any(isOverGateResizeTab);
        var isHighlighted = !isResizeHighlighted && seq(focusPosPts).any(isOverGate);
        var isResizeShowing = gate.canChangeInSize() && (isResizeHighlighted || isHighlighted);
        return {
          isHighlighted: isHighlighted,
          isResizeShowing: isResizeShowing,
          isResizeHighlighted: isResizeHighlighted
        };
      },
      _drawGate_disabledReason: function(painter, col, row, gateRect, isHighlighted) {
        var isDisabledReason = this.circuitDefinition.gateAtLocIsDisabledReason(col, row);
        if (isDisabledReason === undefined) {
          return;
        }
        painter.ctx.save();
        if (isHighlighted) {
          painter.ctx.globalAlpha *= 0.3;
        }
        painter.ctx.globalAlpha *= 0.5;
        painter.fillRect(gateRect.paddedBy(5), 'yellow');
        painter.ctx.globalAlpha *= 2;
        painter.strokeLine(gateRect.topLeft(), gateRect.bottomRight(), 'orange', 3);
        var r = painter.printParagraph(isDisabledReason, gateRect.paddedBy(5), new Point(0.5, 0.5), 'red');
        painter.ctx.globalAlpha *= 0.5;
        painter.fillRect(r.paddedBy(2), 'yellow');
        painter.ctx.globalAlpha *= 2;
        painter.printParagraph(isDisabledReason, gateRect.paddedBy(5), new Point(0.5, 0.5), 'red');
        painter.ctx.restore();
      },
      _drawColumn: function(painter, gateColumn, col, hand, stats) {
        this._drawColumnControlWires(painter, col);
        this._drawColumnDragHighlight(painter, col);
        for (var row = 0; row < this.circuitDefinition.numWires; row++) {
          if (gateColumn.gates[row] === undefined) {
            continue;
          }
          var gate = gateColumn.gates[row];
          var gateRect = this.gateRect(row, col, gate.width, gate.height);
          var $__10 = this._highlightStatusAt(col, row, hand.hoverPoints()),
              isHighlighted = $__10.isHighlighted,
              isResizeShowing = $__10.isResizeShowing,
              isResizeHighlighted = $__10.isResizeHighlighted;
          var drawer = gate.customDrawer || GatePainting.DEFAULT_DRAWER;
          painter.noteTouchBlocker({
            rect: gateRect,
            cursor: 'pointer'
          });
          if (gate.canChangeInSize()) {
            painter.noteTouchBlocker({
              rect: GatePainting.rectForResizeTab(gateRect),
              cursor: 'ns-resize'
            });
          }
          drawer(new GateDrawParams(painter, false, isHighlighted && !isResizeHighlighted, isResizeShowing, isResizeHighlighted, gateRect, gate, stats, {
            row: row,
            col: col
          }, this._highlightedSlot === undefined ? hand.hoverPoints() : [], stats.customStatsForSlot(col, row)));
          this._drawGate_disabledReason(painter, col, row, gateRect, isHighlighted);
        }
        this._drawColumnSurvivalRate(painter, gateColumn, col, stats);
      },
      _drawColumnSurvivalRate: function(painter, gateColumn, col, stats) {
        if (gateColumn.indexOfNonUnitaryGate() === undefined) {
          return;
        }
        var preRate = stats.survivalRate(col - 1);
        var postRate = stats.survivalRate(col);
        var marginalRate = (postRate - preRate) / preRate;
        if (isNaN(marginalRate) || Math.abs(marginalRate) <= 0.005) {
          return;
        }
        var descAmount;
        var descCategory;
        if (marginalRate < 0) {
          var rate = Math.round(-marginalRate * 100);
          var rateDesc = marginalRate === -1 ? "100" : rate < 100 ? rate : ">99";
          descAmount = (rateDesc + "%");
          descCategory = 'omits';
        } else {
          var factor = Math.round(marginalRate * 100 + 100);
          descAmount = (factor + "%");
          descCategory = 'gains';
        }
        var pt = this.opRect(col).bottomCenter();
        painter.print(descCategory, pt.x, pt.y - 28, 'center', 'bottom', 'red', '14px sans-serif', 800, 50);
        painter.print(descAmount, pt.x, pt.y - 13, 'center', 'bottom', 'red', '14px sans-serif', 800, 50);
      },
      _drawColumnDragHighlight: function(painter, col) {
        if (this._highlightedSlot !== undefined && this._highlightedSlot.col === col && this._highlightedSlot.row === undefined) {
          var rect = this.gateRect(0, col, 1, this._groundedWireCount()).paddedBy(3);
          painter.fillRect(rect, 'rgba(255, 196, 112, 0.7)');
          painter.strokeRect(rect, 'black');
        }
      },
      _drawColumnControlWires: function(painter, columnIndex) {
        var x = Math.round(this.opRect(columnIndex).center().x - 0.5) + 0.5;
        if (this.circuitDefinition.columns[columnIndex].hasGatesWithGlobalEffects()) {
          painter.ctx.save();
          painter.ctx.setLineDash([1, 4]);
          painter.strokeLine(new Point(x, this.gateRect(0, 0).y), new Point(x, this.opRect(0).bottom() - 40));
          painter.ctx.restore();
        }
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (this.circuitDefinition.controlLinesRanges(columnIndex))[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var $__10 = $__4.value,
                first = $__10.first,
                last = $__10.last,
                measured = $__10.measured;
            {
              var y1 = this.wireRect(first).center().y;
              var y2 = this.wireRect(last).center().y;
              if (measured) {
                painter.strokeLine(new Point(x + 1, y1), new Point(x + 1, y2));
                painter.strokeLine(new Point(x - 1, y1), new Point(x - 1, y2));
              } else {
                painter.strokeLine(new Point(x, y1), new Point(x, y2));
              }
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
      },
      previewDrop: function(hand) {
        return hand.heldColumn !== undefined ? this._previewDropMovedGateColumn(hand) : hand.heldGate !== undefined ? this._previewDropMovedGate(hand) : this._previewResizedGate(hand);
      },
      _previewDropMovedGateColumn: function(hand) {
        if (hand.pos === undefined) {
          return this;
        }
        var halfCol = this.findOpHalfColumnAt(new Point(hand.pos.x, this.top));
        var mustInsert = halfCol % 1 === 0 && this.circuitDefinition.columns[halfCol] !== undefined && !this.circuitDefinition.columns[halfCol].isEmpty();
        if (mustInsert) {
          var isAfter = hand.pos.x > this.opRect(halfCol).center().x;
          halfCol += isAfter ? 0.5 : -0.5;
        }
        var col = Math.ceil(halfCol);
        var isInsert = halfCol % 1 !== 0;
        var rowShift = Math.round((hand.pos.y - hand.holdOffset.y - this.top) / Config.WIRE_SPACING);
        var newCircuitDef = this._shiftAndSpliceColumn(rowShift, $traceurRuntime.spread(hand.heldColumn.gates), col, isInsert);
        return this.withCircuit(newCircuitDef)._withHighlightedSlot({
          row: undefined,
          col: col,
          resizeStyle: false
        })._withCompressedColumnIndex(isInsert ? col : undefined);
      },
      _shiftAndSpliceColumn: function(rowShift, gatesOfCol, insertCol, isInsert) {
        while (rowShift < 0 && gatesOfCol[0] === undefined) {
          gatesOfCol.shift();
          gatesOfCol.push(undefined);
          rowShift += 1;
        }
        while (rowShift > 0 && new GateColumn(gatesOfCol).minimumRequiredWireCount() < Config.MAX_WIRE_COUNT) {
          gatesOfCol.unshift(undefined);
          if (new GateColumn(gatesOfCol).minimumRequiredWireCount() < gatesOfCol.length) {
            gatesOfCol.pop();
          }
          rowShift -= 1;
        }
        var expandedCircuit = this.circuitDefinition.withWireCount(gatesOfCol.length);
        var newCols = $traceurRuntime.spread(expandedCircuit.columns);
        while (newCols.length < insertCol) {
          newCols.push(GateColumn.empty(expandedCircuit.numWires));
        }
        newCols.splice(insertCol, isInsert ? 0 : 1, new GateColumn(gatesOfCol));
        return expandedCircuit.withColumns(newCols).withTrailingSpacersIncluded();
      },
      _previewDropMovedGate: function(hand) {
        var modificationPoint = this.findModificationIndex(hand);
        if (modificationPoint === undefined) {
          return this;
        }
        var handRowOffset = Math.floor(hand.holdOffset.y / Config.WIRE_SPACING);
        if (modificationPoint.row + handRowOffset >= this.circuitDefinition.numWires) {
          return this;
        }
        var addedGate = hand.heldGate;
        var emptyCol = GateColumn.empty(this.circuitDefinition.numWires);
        var i = modificationPoint.col;
        var isInserting = modificationPoint.isInsert;
        var row = Math.min(modificationPoint.row, Math.max(0, Config.MAX_WIRE_COUNT - addedGate.height));
        var newCols = seq(this.circuitDefinition.columns).padded(i, emptyCol).ifThen(isInserting, function(s) {
          return s.withInsertedItem(i, emptyCol);
        }).padded(i + addedGate.width, emptyCol).withTransformedItem(i, function(c) {
          return c.withGatesAdded(row, new GateColumn([addedGate]));
        }).toArray();
        var newWireCount = Math.max(this._extraWireStartIndex || 0, Math.max(this.circuitDefinition.numWires, addedGate.height + row));
        if (newWireCount > Config.MAX_WIRE_COUNT) {
          return this;
        }
        var newCircuitDef = this.circuitDefinition.withColumns(newCols).withWireCount(newWireCount);
        return this.withCircuit(newCircuitDef)._withHighlightedSlot({
          row: row,
          col: modificationPoint.col,
          resizeStyle: false
        })._withCompressedColumnIndex(isInserting ? i : undefined)._withFallbackExtraWireStartIndex(this.circuitDefinition.numWires);
      },
      _previewResizedGate: function(hand) {
        if (hand.resizingGateSlot === undefined || hand.pos === undefined) {
          return this;
        }
        var gate = this.circuitDefinition.gateInSlot(hand.resizingGateSlot.x, hand.resizingGateSlot.y);
        if (gate === undefined) {
          return this;
        }
        var row = Math.min(this.wireIndexAt(hand.pos.y - hand.holdOffset.y), Config.MAX_WIRE_COUNT - 1);
        var newGate = seq(gate.gateFamily).minBy(function(g) {
          return Math.abs(g.height - (row - hand.resizingGateSlot.y + 1));
        });
        var newWireCount = Math.min(Config.MAX_WIRE_COUNT, Math.max(this.circuitDefinition.numWires, newGate.height + hand.resizingGateSlot.y));
        var newCols = seq(this.circuitDefinition.columns).withTransformedItem(hand.resizingGateSlot.x, function(colObj) {
          return new GateColumn(seq(colObj.gates).withOverlayedItem(hand.resizingGateSlot.y, newGate).toArray());
        }).toArray();
        var newCircuitWithoutOverlapFix = this.circuitDefinition.withColumns(newCols).withWireCount(newWireCount);
        var newCircuitWithOverlapFix = newCircuitWithoutOverlapFix.withHeightOverlapsFixed();
        var newCircuit = newCircuitWithOverlapFix.withTrailingSpacersIncluded();
        return this.withCircuit(newCircuit)._withHighlightedSlot(this._highlightedSlot)._withCompressedColumnIndex(newCircuitWithoutOverlapFix.isEqualTo(newCircuitWithOverlapFix) ? undefined : hand.resizingGateSlot.x + 1)._withFallbackExtraWireStartIndex(this.circuitDefinition.numWires);
      },
      afterDropping: function(hand) {
        return this.previewDrop(hand)._withCompressedColumnIndex(undefined);
      },
      withCircuit: function(circuitDefinition) {
        return new DisplayedCircuit(this.top, circuitDefinition, this._compressedColumnIndex, this._highlightedSlot, this._extraWireStartIndex);
      },
      _withCompressedColumnIndex: function(compressedColumnIndex) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, compressedColumnIndex, this._highlightedSlot, this._extraWireStartIndex);
      },
      _withHighlightedSlot: function(slot) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, this._compressedColumnIndex, slot, this._extraWireStartIndex);
      },
      _withExtraWireStartIndex: function(extraWireStartIndex) {
        return new DisplayedCircuit(this.top, this.circuitDefinition, this._compressedColumnIndex, this._highlightedSlot, extraWireStartIndex);
      },
      _withFallbackExtraWireStartIndex: function(fallbackExtraWireStartIndex) {
        return this._withExtraWireStartIndex(this._extraWireStartIndex || fallbackExtraWireStartIndex);
      },
      withJustEnoughWires: function(hand, extraWireCount) {
        var neededWireCountForPlacement = hand.heldGate !== undefined ? hand.heldGate.height : 0;
        var desiredWireCount = this.circuitDefinition.minimumRequiredWireCount();
        var clampedWireCount = Math.min(Config.MAX_WIRE_COUNT, Math.max(Math.min(1, neededWireCountForPlacement), Math.max(Config.MIN_WIRE_COUNT, desiredWireCount) + extraWireCount));
        return this.withCircuit(this.circuitDefinition.withWireCount(clampedWireCount))._withExtraWireStartIndex(extraWireCount === 0 ? undefined : this.circuitDefinition.numWires);
      },
      findGateOverlappingPos: function(pos) {
        var col = this.indexOfDisplayedColumnAt(pos.x);
        var row = this.indexOfDisplayedRowAt(pos.y);
        if (col === undefined || row === undefined) {
          return undefined;
        }
        var target = this.circuitDefinition.findGateCoveringSlot(col, row);
        if (target === undefined) {
          return undefined;
        }
        var gateRect = this.gateRect(target.row, target.col, target.gate.width, target.gate.height);
        if (!gateRect.containsPoint(pos)) {
          return undefined;
        }
        return {
          col: target.col,
          row: target.row,
          offset: pos.minus(gateRect.topLeft())
        };
      },
      findGateWithButtonContaining: function(pos) {
        var foundPt = this.findGateOverlappingPos(pos);
        if (foundPt === undefined) {
          return undefined;
        }
        var gate = this.circuitDefinition.gateInSlot(foundPt.col, foundPt.row);
        if (gate.onClickGateFunc === undefined) {
          return undefined;
        }
        var buttonRect = GatePainting.gateButtonRect(this.gateRect(foundPt.row, foundPt.col, gate.width, gate.height));
        if (!buttonRect.containsPoint(pos)) {
          return undefined;
        }
        return {
          col: foundPt.col,
          row: foundPt.row,
          gate: gate
        };
      },
      tryClick: function(hand) {
        if (hand.pos === undefined) {
          return undefined;
        }
        var found = this.findGateWithButtonContaining(hand.pos);
        if (found === undefined) {
          return undefined;
        }
        var newGate = found.gate.onClickGateFunc(found.gate);
        var cols = $traceurRuntime.spread(this.circuitDefinition.columns);
        var col = cols[found.col];
        var gates = $traceurRuntime.spread(col.gates);
        gates.splice(found.row, 1, newGate);
        cols.splice(found.col, 1, new GateColumn(gates));
        return this.withCircuit(this.circuitDefinition.withColumns(cols));
      },
      tryGrab: function(hand) {
        var duplicate = arguments[1] !== (void 0) ? arguments[1] : false;
        var wholeColumn = arguments[2] !== (void 0) ? arguments[2] : false;
        var ignoreResizeTabs = arguments[3] !== (void 0) ? arguments[3] : false;
        if (wholeColumn) {
          return this._tryGrabWholeColumn(hand, duplicate) || {
            newCircuit: this,
            newHand: hand
          };
        }
        var newHand = hand;
        var newCircuit = this;
        if (!ignoreResizeTabs) {
          var resizing = this._tryGrabResizeTab(hand);
          if (resizing !== undefined) {
            newHand = resizing.newHand;
            newCircuit = resizing.newCircuit;
          }
        }
        return newCircuit._tryGrabGate(newHand, duplicate) || {
          newCircuit: newCircuit,
          newHand: newHand
        };
      },
      _tryGrabGate: function(hand) {
        var duplicate = arguments[1] !== (void 0) ? arguments[1] : false;
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        var foundPt = this.findGateOverlappingPos(hand.pos);
        if (foundPt === undefined) {
          return undefined;
        }
        var $__10 = foundPt,
            col = $__10.col,
            row = $__10.row,
            offset = $__10.offset;
        var gate = this.circuitDefinition.columns[col].gates[row];
        var remainingGates = seq(this.circuitDefinition.columns[col].gates).toArray();
        if (!duplicate) {
          remainingGates[row] = undefined;
        }
        var newCols = seq(this.circuitDefinition.columns).withOverlayedItem(col, new GateColumn(remainingGates)).toArray();
        return {
          newCircuit: new DisplayedCircuit(this.top, this.circuitDefinition.withColumns(newCols), undefined, undefined, this._extraWireStartIndex),
          newHand: hand.withHeldGate(gate, offset)
        };
      },
      _tryGrabResizeTab: function(hand) {
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        for (var col = 0; col < this.circuitDefinition.columns.length; col++) {
          for (var row = 0; row < this.circuitDefinition.numWires; row++) {
            var gate = this.circuitDefinition.columns[col].gates[row];
            if (gate === undefined) {
              continue;
            }
            var isResizeHighlighted = this._highlightStatusAt(col, row, hand.hoverPoints()).isResizeHighlighted;
            if (isResizeHighlighted) {
              var offset = hand.pos.minus(this.gateRect(row + gate.height - 1, col, 1, 1).center());
              return {
                newCircuit: this._withHighlightedSlot({
                  col: col,
                  row: row,
                  resizeStyle: true
                }),
                newHand: hand.withResizeSlot(new Point(col, row), offset)
              };
            }
          }
        }
        return undefined;
      },
      _tryGrabWholeColumn: function(hand, duplicate) {
        if (hand.isBusy() || hand.pos === undefined) {
          return undefined;
        }
        var col = Math.round(this.toColumnSpaceCoordinate(hand.pos.x));
        if (col < 0 || col >= this.circuitDefinition.columns.length || this.circuitDefinition.columns[col].isEmpty()) {
          return undefined;
        }
        var newCols = $traceurRuntime.spread(this.circuitDefinition.columns);
        if (!duplicate) {
          newCols.splice(col, 1, GateColumn.empty(this.circuitDefinition.numWires));
        }
        var holdOffset = new Point(0, this.wireIndexAt(hand.pos.y) * Config.WIRE_SPACING + Config.WIRE_SPACING / 2);
        return {
          newCircuit: this.withCircuit(this.circuitDefinition.withColumns(newCols)),
          newHand: hand.withHeldGateColumn(this.circuitDefinition.columns[col], holdOffset)
        };
      },
      stableDuration: function() {
        return this.circuitDefinition.stableDuration();
      },
      importantWireCount: function() {
        return Math.max(this.circuitDefinition.numWires - (this._extraWireStartIndex === Config.MAX_WIRE_COUNT ? 0 : 1), Config.MIN_WIRE_COUNT, this.circuitDefinition.minimumRequiredWireCount());
      },
      _drawOutputDisplays: function(painter, stats, hand) {
        var chanceCol = this.clampedCircuitColCount() + 1;
        var blochCol = chanceCol + 1;
        var numWire = this.importantWireCount();
        for (var i = 0; i < numWire; i++) {
          var p = stats.controlledWireProbabilityJustAfter(i, Infinity);
          MathPainter.paintProbabilityBox(painter, p, this.gateRect(i, chanceCol), hand.hoverPoints());
          var m = stats.qubitDensityMatrix(Infinity, i);
          if (m !== undefined) {
            paintBlochSphereDisplay(painter, m, this.gateRect(i, blochCol), hand.hoverPoints());
          }
        }
        var bottom = this.wireRect(numWire - 1).bottom();
        var x = this.opRect(chanceCol - 1).x;
        painter.printParagraph("Local wire states\n(Chance/Bloch)", new Rect(x, bottom + 4, 190, 40), new Point(0.5, 0), 'gray');
        this._drawOutputSuperpositionDisplay(painter, stats, hand);
      },
      clampedCircuitColCount: function() {
        return Math.max(this.circuitDefinition.columns.length, Config.MIN_COL_COUNT + (this._compressedColumnIndex !== undefined ? 1 : 0));
      },
      _drawOutputSuperpositionDisplay: function(painter, stats, hand) {
        var amplitudeGrid = this._outputStateAsMatrix(stats);
        var gridRect = this._rectForSuperpositionDisplay();
        var numWire = this.importantWireCount();
        MathPainter.paintMatrix(painter, amplitudeGrid, gridRect, numWire < Config.SIMPLE_SUPERPOSITION_DRAWING_WIRE_THRESHOLD ? Config.SUPERPOSITION_MID_COLOR : undefined, 'black', numWire < Config.SIMPLE_SUPERPOSITION_DRAWING_WIRE_THRESHOLD ? Config.SUPERPOSITION_FORE_COLOR : undefined, Config.SUPERPOSITION_BACK_COLOR);
        var forceSign = function(v) {
          return (v >= 0 ? '+' : '') + v.toFixed(2);
        };
        MathPainter.paintMatrixTooltip(painter, amplitudeGrid, gridRect, hand.hoverPoints(), function(c, r) {
          return ("Amplitude of |" + Util.bin(r * amplitudeGrid.width() + c, numWire) + "⟩");
        }, function(c, r, v) {
          return 'val:' + v.toString(new Format(false, 0, 5, ", "));
        }, function(c, r, v) {
          return ("mag²:" + (v.norm2() * 100).toFixed(4) + "%, phase:" + forceSign(v.phase() * 180 / Math.PI) + "°");
        });
        this._drawOutputSuperpositionDisplay_labels(painter);
      },
      _drawOutputSuperpositionDisplay_labels: function(painter) {
        var gridRect = this._rectForSuperpositionDisplay();
        var numWire = this.importantWireCount();
        _cachedRowLabelDrawer.paint(gridRect.right(), gridRect.y, painter, numWire);
        _cachedColLabelDrawer.paint(gridRect.x, gridRect.bottom(), painter, numWire);
      },
      _outputStateAsMatrix: function(stats) {
        var $__11,
            $__12,
            $__14,
            $__15;
        var numWire = this.importantWireCount();
        var buf = stats.finalState.rawBuffer();
        if (stats.circuitDefinition.numWires !== numWire) {
          var r = new Float32Array(2 << numWire);
          r.set(buf.slice(0, r.length));
          buf = r;
        }
        var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
            colWires = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
            rowWires = ($__12 = $__11.next()).done ? void 0 : $__12.value;
        var $__13 = [1 << colWires, 1 << rowWires],
            colCount = ($__14 = $__13[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
            rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
        return new Matrix(colCount, rowCount, buf);
      },
      _rectForSuperpositionDisplay: function() {
        var $__13,
            $__11,
            $__14,
            $__15;
        var col = this.clampedCircuitColCount() + EXTRA_COLS_FOR_SINGLE_QUBIT_DISPLAYS + 1;
        var numWire = this.importantWireCount();
        var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
            colWires = ($__13 = $__10[Symbol.iterator](), ($__11 = $__13.next()).done ? void 0 : $__11.value),
            rowWires = ($__11 = $__13.next()).done ? void 0 : $__11.value;
        var $__12 = [1 << colWires, 1 << rowWires],
            colCount = ($__14 = $__12[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
            rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
        var topRect = this.gateRect(0, col);
        var bottomRect = this.gateRect(numWire - 1, col);
        var gridRect = new Rect(topRect.x, topRect.y, 0, bottomRect.bottom() - topRect.y);
        return gridRect.withW(gridRect.h * (colCount / rowCount));
      },
      _drawHintLabels: function(painter, stats) {
        var gridRect = this._rectForSuperpositionDisplay();
        painter.print('Final amplitudes', gridRect.right() + 3, gridRect.bottom() + 3, 'left', 'top', 'gray', '12px sans-serif', 100, 20);
        if (this.circuitDefinition.colIsMeasuredMask(Infinity) !== 0) {
          painter.printParagraph("(assuming measurement deferred)", new Rect(gridRect.right() + 3, gridRect.bottom() + 20, 100, 75), new Point(0.5, 0), 'red');
        }
        var survivalRate = stats.survivalRate(Infinity);
        if (Math.abs(survivalRate - 1) > 0.01) {
          var desc;
          if (survivalRate < 1) {
            var rate = Math.round(survivalRate * 100);
            var rateDesc = survivalRate === 0 ? "0" : rate > 0 ? rate : "<1";
            desc = ("kept: " + rateDesc + "%");
          } else {
            var factor = Math.round(survivalRate * 100);
            desc = ("over-unity: " + factor + "%");
          }
          painter.print(desc, this._rectForSuperpositionDisplay().x - 5, gridRect.bottom() + SUPERPOSITION_GRID_LABEL_SPAN, 'right', 'bottom', 'red', '14px sans-serif', 800, 50);
        }
      }
    }, {
      empty: function(top) {
        return new DisplayedCircuit(top, new CircuitDefinition(Config.MIN_WIRE_COUNT, []), undefined, undefined, undefined);
      },
      fromTextDiagram: function(gateMap, diagramText) {
        var lines = diagramText.split('\n').map(function(e) {
          var p = e.split('|');
          if (p.length !== 2) {
            throw new DetailedError('Bad diagram', {
              diagramText: diagramText,
              gateMap: gateMap
            });
          }
          return p[1];
        });
        var circuitDiagramSubset = seq(lines).skip(1).stride(2).map(function(line) {
          return seq(line).skip(1).stride(2).join("");
        }).join('\n');
        var top = 10;
        var circuit = new DisplayedCircuit(top, CircuitDefinition.fromTextDiagram(gateMap, circuitDiagramSubset), undefined, undefined, undefined);
        var pts = Seq.naturals().takeWhile(function(k) {
          return diagramText.indexOf(k) !== -1;
        }).map(function(k) {
          var pos = seq(lines).mapWithIndex(function(line, row) {
            return ({
              row: row,
              col: line.indexOf(k)
            });
          }).filter(function(e) {
            return e.col !== -1;
          }).single();
          if (lines[pos.row][pos.col + 1] === '^') {
            pos.row -= 1;
            pos.col += 1;
          }
          return new Point(pos.col * Config.WIRE_SPACING / 2 + 35.5, pos.row * Config.WIRE_SPACING / 2 + 10.5);
        }).toArray();
        return {
          circuit: circuit,
          pts: pts
        };
      }
    });
  }();
  function drawCircuitTooltip(painter, circuitDefinition, rect, showWires, time) {
    var displayed = new DisplayedCircuit(0, circuitDefinition, undefined, undefined, undefined);
    var neededWidth = displayed.desiredWidth(true);
    var neededHeight = displayed.desiredHeight(true);
    var scaleX = rect.w / neededWidth;
    var scaleY = rect.h / neededHeight;
    if (showWires) {
      var s = Math.min(scaleX, scaleY);
      scaleX = s;
      scaleY = s;
    }
    var stats = CircuitStats.withNanDataFromCircuitAtTime(circuitDefinition, time);
    try {
      painter.ctx.save();
      painter.ctx.translate(rect.x, rect.y);
      painter.ctx.scale(Math.min(1, scaleX), Math.min(1, scaleY));
      painter.ctx.translate(0, 0);
      displayed.paint(painter, Hand.EMPTY, stats, true, showWires);
    } finally {
      painter.ctx.restore();
    }
    return {
      maxW: neededWidth * scaleX,
      maxH: neededHeight * scaleY
    };
  }
  var GATE_CIRCUIT_DRAWER = function(args) {
    var circuit = args.gate.knownCircuit;
    if (circuit === undefined || args.gate.symbol !== '') {
      if (args.gate.stableDuration() === Infinity) {
        GatePainting.DEFAULT_DRAWER(args);
      } else {
        GatePainting.makeCycleDrawer()(args);
      }
      return;
    }
    var toolboxColor = args.gate.stableDuration() === Infinity ? Config.GATE_FILL_COLOR : Config.TIME_DEPENDENT_HIGHLIGHT_COLOR;
    GatePainting.paintBackground(args, toolboxColor);
    drawCircuitTooltip(args.painter, args.gate.knownCircuitNested, args.rect, false, args.stats.time);
    GatePainting.paintOutline(args);
    if (args.isHighlighted) {
      args.painter.ctx.save();
      args.painter.ctx.globalAlpha *= 0.9;
      args.painter.fillRect(args.rect, Config.HIGHLIGHTED_GATE_FILL_COLOR);
      args.painter.ctx.restore();
    }
    GatePainting.paintOutline(args);
  };
  function _drawLabelsReasonablyFast(painter, dy, n, labeller, boundingWidth) {
    var ctx = painter.ctx;
    ctx.save();
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    painter.ctx.font = '12px monospace';
    var w = Math.max(painter.ctx.measureText(labeller(0)).width, painter.ctx.measureText(labeller(n - 1)).width);
    var h = ctx.measureText("0").width * 2.5;
    var scale = Math.min(Math.min((boundingWidth - 2) / w, dy / h), 1);
    var step = dy / scale;
    var pad = 1 / scale;
    ctx.scale(scale, scale);
    ctx.translate(0, dy * 0.5 / scale - h * 0.5);
    ctx.fillStyle = 'lightgray';
    if (h < step * 0.95) {
      for (var i = 0; i < n; i++) {
        ctx.fillRect(0, step * i, w + 2 * pad, h);
      }
    } else {
      ctx.fillRect(0, 0, w + 2 * pad, step * n);
    }
    ctx.fillStyle = 'black';
    for (var i$__19 = 0; i$__19 < n; i$__19++) {
      ctx.fillText(labeller(i$__19), pad, h * 0.5 + step * i$__19);
    }
    ctx.restore();
  }
  var _cachedRowLabelDrawer = new CachablePainting(function(numWire) {
    return ({
      width: SUPERPOSITION_GRID_LABEL_SPAN,
      height: (numWire - 1) * Config.WIRE_SPACING + Config.GATE_RADIUS * 2
    });
  }, function(painter, numWire) {
    var $__12,
        $__13;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__12 = $__10[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
        rowWires = ($__13 = $__12.next()).done ? void 0 : $__13.value;
    var rowCount = 1 << rowWires;
    var suffix = colWires < 4 ? "_".repeat(colWires) : "_..";
    _drawLabelsReasonablyFast(painter, painter.canvas.height / rowCount, rowCount, function(i) {
      return Util.bin(i, rowWires) + suffix;
    }, SUPERPOSITION_GRID_LABEL_SPAN);
  });
  var _cachedColLabelDrawer = new CachablePainting(function(numWire) {
    var $__12,
        $__13,
        $__14,
        $__15;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__12 = $__10[Symbol.iterator](), ($__13 = $__12.next()).done ? void 0 : $__13.value),
        rowWires = ($__13 = $__12.next()).done ? void 0 : $__13.value;
    var $__11 = [1 << colWires, 1 << rowWires],
        colCount = ($__14 = $__11[Symbol.iterator](), ($__15 = $__14.next()).done ? void 0 : $__15.value),
        rowCount = ($__15 = $__14.next()).done ? void 0 : $__15.value;
    var total_height = (numWire - 1) * Config.WIRE_SPACING + Config.GATE_RADIUS * 2;
    var cellDiameter = total_height / rowCount;
    return {
      width: colCount * cellDiameter,
      height: SUPERPOSITION_GRID_LABEL_SPAN
    };
  }, function(painter, numWire) {
    var $__11,
        $__12;
    var $__10 = [Math.floor(numWire / 2), Math.ceil(numWire / 2)],
        colWires = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
        rowWires = ($__12 = $__11.next()).done ? void 0 : $__12.value;
    var colCount = 1 << colWires;
    var dw = painter.canvas.width / colCount;
    painter.ctx.translate(colCount * dw, 0);
    painter.ctx.rotate(Math.PI / 2);
    var prefix = rowWires < 4 ? "_".repeat(rowWires) : ".._";
    _drawLabelsReasonablyFast(painter, dw, colCount, function(i) {
      return prefix + Util.bin(colCount - 1 - i, colWires);
    }, SUPERPOSITION_GRID_LABEL_SPAN);
  });
  return {get DisplayedTimeLine() {
      return DisplayedTimeLine;
    }};
});
//# sourceURL=src/ui/DisplayedTimeLine.js
;$traceurRuntime.registerModule("src/ui/DisplayedToolbox.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/DisplayedToolbox.js";
  var CachablePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/CachablePainting.js", "src/ui/DisplayedToolbox.js")).CachablePainting;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitStats.js", "src/ui/DisplayedToolbox.js")).CircuitStats;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/DisplayedToolbox.js")).Config;
  var GateDrawParams = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GateDrawParams.js", "src/ui/DisplayedToolbox.js")).GateDrawParams;
  var GatePainting = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/GatePainting.js", "src/ui/DisplayedToolbox.js")).GatePainting;
  var Hand = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/Hand.js", "src/ui/DisplayedToolbox.js")).Hand;
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/gates/Joke_MysteryGate.js", "src/ui/DisplayedToolbox.js")),
      MysteryGateSymbol = $__12.MysteryGateSymbol,
      MysteryGateMaker = $__12.MysteryGateMaker;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/ui/DisplayedToolbox.js")).Rect;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/Painter.js", "src/ui/DisplayedToolbox.js")).Painter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/ui/DisplayedToolbox.js")).Point;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/ui/DisplayedToolbox.js")).seq;
  var WidgetPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/WidgetPainter.js", "src/ui/DisplayedToolbox.js")).WidgetPainter;
  var DisplayedToolbox = function() {
    function DisplayedToolbox(name, top, toolboxGroups, labelsOnTop, groupHeight) {
      var originalGroups = arguments[5];
      var standardAppearance = arguments[6];
      var $__2 = this;
      this.name = name;
      this.top = top;
      this.toolboxGroups = toolboxGroups;
      this.labelsOnTop = labelsOnTop;
      this.groupHeight = groupHeight;
      this._originalGroups = originalGroups || this.toolboxGroups;
      this._standardApperance = standardAppearance || new CachablePainting(function() {
        return ({
          width: $__2.desiredWidth(),
          height: $__2.desiredHeight()
        });
      }, function(painter) {
        painter.ctx.save();
        painter.ctx.translate(0, -$__2.top);
        $__2._paintStandardContents(painter);
        painter.ctx.restore();
      });
    }
    return ($traceurRuntime.createClass)(DisplayedToolbox, {
      withCustomGatesInserted: function(customGateSet) {
        var groups = $traceurRuntime.spread(this._originalGroups);
        for (var i = 0; i < Math.max(1, customGateSet.gates.length); i += this.groupHeight * 2) {
          var group = {
            hint: 'Custom Gates',
            gates: [undefined, undefined, undefined, undefined, undefined, undefined]
          };
          for (var j = 0; j < this.groupHeight * 2 && i + j < customGateSet.gates.length; j++) {
            group.gates[j] = customGateSet.gates[i + j];
          }
          groups.push(group);
        }
        return new DisplayedToolbox(this.name, this.top, groups, this.labelsOnTop, this.groupHeight, this._originalGroups, this._standardApperance);
      },
      gateDrawRect: function(groupIndex, gateIndex) {
        var dx = gateIndex % 2;
        var dy = Math.floor(gateIndex / 2);
        var x = Config.TOOLBOX_MARGIN_X + dx * Config.TOOLBOX_GATE_SPAN + groupIndex * Config.TOOLBOX_GROUP_SPAN;
        var y = this.top + (this.labelsOnTop ? Config.TOOLBOX_MARGIN_Y : 3) + dy * Config.TOOLBOX_GATE_SPAN;
        return new Rect(Math.round(x - 0.5) + 0.5, Math.round(y - 0.5) + 0.5, Config.GATE_RADIUS * 2, Config.GATE_RADIUS * 2);
      },
      groupLabelRect: function(groupIndex) {
        if (this.labelsOnTop) {
          var r$__4 = this.gateDrawRect(groupIndex, 0);
          var c$__5 = new Point(r$__4.x + Config.TOOLBOX_GATE_SPAN - Config.TOOLBOX_GATE_SPACING / 2, r$__4.y - 18);
          return new Rect(c$__5.x - Config.TOOLBOX_GATE_SPAN, c$__5.y, Config.TOOLBOX_GATE_SPAN * 2, 20);
        }
        var r = this.gateDrawRect(groupIndex, this.groupHeight * 2 - 2);
        var c = new Point(r.x + Config.TOOLBOX_GATE_SPAN - Config.TOOLBOX_GATE_SPACING / 2, r.bottom());
        return new Rect(c.x - Config.TOOLBOX_GATE_SPAN, c.y + 2, Config.TOOLBOX_GATE_SPAN * 2, 20);
      },
      findGateAt: function(pt) {
        if (pt === undefined) {
          return undefined;
        }
        for (var groupIndex = 0; groupIndex < this.toolboxGroups.length; groupIndex++) {
          var group = this.toolboxGroups[groupIndex];
          for (var gateIndex = 0; gateIndex < group.gates.length; gateIndex++) {
            var gate = group.gates[gateIndex];
            var rect = this.gateDrawRect(groupIndex, gateIndex);
            if (gate !== undefined && rect.containsPoint(pt)) {
              return {
                groupIndex: groupIndex,
                gateIndex: gateIndex,
                gate: gate,
                rect: rect
              };
            }
          }
        }
        return undefined;
      },
      isEqualTo: function(other) {
        return other instanceof DisplayedToolbox && this.name === other.name && this.top === other.top && this.toolboxGroups === other.toolboxGroups && this.labelsOnTop === other.labelsOnTop;
      },
      withTop: function(newTop) {
        return new DisplayedToolbox(this.name, newTop, this.toolboxGroups, this.labelsOnTop, this.groupHeight, this._originalGroups, this._standardApperance);
      },
      curArea: function(maxWidth) {
        return new Rect(0, this.top, maxWidth, this.desiredHeight());
      },
      paint: function(painter, stats, hand) {
        painter.fillRect(this.curArea(painter.canvas.width), Config.BACKGROUND_COLOR_TOOLBOX);
        this._standardApperance.paint(0, this.top, painter);
        this._paintDeviations(painter, stats, hand);
      },
      _paintStandardContents: function(painter) {
        for (var groupIndex = 0; groupIndex < this.toolboxGroups.length; groupIndex++) {
          this._paintGatesInGroup(painter, groupIndex);
        }
        var r = this.curArea(Config.TOOLBOX_MARGIN_X);
        var $__3 = r.center(),
            x = $__3.x,
            y = $__3.y;
        painter.ctx.save();
        painter.ctx.translate(x, y);
        painter.ctx.rotate(-Math.PI / 2);
        painter.printLine(this.name, new Rect(-r.h / 2, -r.w / 2, r.h, r.w), 0.5, 'black', 24);
        painter.ctx.restore();
      },
      _paintDeviations: function(painter, stats, hand) {
        for (var groupIndex = 0; groupIndex < this.toolboxGroups.length; groupIndex++) {
          if (groupIndex >= this._originalGroups.length) {
            this._paintGatesInGroup(painter, groupIndex);
          }
          var group = this.toolboxGroups[groupIndex];
          for (var gateIndex = 0; gateIndex < group.gates.length; gateIndex++) {
            if (group.gates[gateIndex] !== undefined) {
              painter.noteTouchBlocker({
                rect: this.gateDrawRect(groupIndex, gateIndex),
                cursor: 'pointer'
              });
            }
          }
        }
        this._paintFocus(painter, stats, hand);
      },
      _paintGatesInGroup: function(painter, groupIndex) {
        var group = this.toolboxGroups[groupIndex];
        var r = this.groupLabelRect(groupIndex);
        painter.print(group.hint, r.x + r.w / 2, r.y + r.h / 2, 'center', 'middle', 'black', '16px sans-serif', r.w, r.h);
        for (var gateIndex = 0; gateIndex < group.gates.length; gateIndex++) {
          var gate = group.gates[gateIndex];
          if (gate === undefined) {
            continue;
          }
          var rect = this.gateDrawRect(groupIndex, gateIndex);
          DisplayedToolbox._paintGate(painter, gate, rect, false, CircuitStats.EMPTY);
        }
      },
      _paintFocus: function(painter, stats, hand) {
        var f = this.findGateAt(hand.pos);
        if (f === undefined || (hand.heldGate !== undefined && f.gate.symbol !== hand.heldGate.symbol)) {
          return;
        }
        DisplayedToolbox._paintGate(painter, f.gate, f.rect, true, stats);
        painter.ctx.save();
        painter.ctx.globalAlpha = 0;
        painter.ctx.translate(-10000, -10000);
        var $__3 = WidgetPainter.paintGateTooltip(painter, new Rect(0, 0, 500, 300), f.gate, stats.time, true),
            maxW = $__3.maxW,
            maxH = $__3.maxH;
        var mayNeedToScale = maxW >= 500 || maxH >= 300;
        painter.ctx.restore();
        var cx = f.rect.right() + 1;
        var hintRect = new Rect(cx, f.rect.center().y, maxW, maxH).snapInside(painter.paintableArea().skipRight(10).skipBottom(20));
        painter.defer(function() {
          return WidgetPainter.paintGateTooltip(painter, hintRect, f.gate, stats.time, mayNeedToScale);
        });
      },
      desiredWidth: function() {
        return this.gateDrawRect(this.toolboxGroups.length - 1, 5).right() + 5;
      },
      desiredHeight: function() {
        return (1 + this.groupHeight) * (Config.GATE_RADIUS * 2 + 2) - Config.GATE_RADIUS;
      },
      tryGrab: function(hand) {
        var $__2 = this;
        if (hand.pos === undefined || hand.isBusy()) {
          return hand;
        }
        var f = this.findGateAt(hand.pos);
        if (f === undefined) {
          return hand;
        }
        if (f.gate.symbol === MysteryGateSymbol) {
          setTimeout(function() {
            $__2.toolboxGroups[f.groupIndex].gates[f.gateIndex] = MysteryGateMaker();
          }, 0.1);
        }
        return hand.withHeldGate(f.gate, new Point(Config.GATE_RADIUS, Config.GATE_RADIUS));
      },
      stableDuration: function(hand) {
        var $__2 = this;
        return seq(hand.hoverPoints()).map(function(p) {
          return $__2.findGateAt(p);
        }).filter(function(e) {
          return e !== undefined;
        }).map(function(e) {
          return e.gate.stableDuration();
        }).min(Infinity);
      }
    }, {_paintGate: function(painter, gate, rect, isHighlighted, stats) {
        var drawer = gate.customDrawer || GatePainting.DEFAULT_DRAWER;
        drawer(new GateDrawParams(painter, true, isHighlighted, false, false, rect, gate, stats, undefined, [], undefined));
      }});
  }();
  return {get DisplayedToolbox() {
      return DisplayedToolbox;
    }};
});
//# sourceURL=src/ui/DisplayedToolbox.js
;$traceurRuntime.registerModule("src/ui/exports.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/exports.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/exports.js")).Config;
  var ObservableValue = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Obs.js", "src/ui/exports.js")).ObservableValue;
  var selectAndCopyToClipboard = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/browser/Clipboard.js", "src/ui/exports.js")).selectAndCopyToClipboard;
  var fromJsonText_CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Serializer.js", "src/ui/exports.js")).fromJsonText_CircuitDefinition;
  var saveFile = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/browser/SaveFile.js", "src/ui/exports.js")).saveFile;
  var exportsIsVisible = new ObservableValue(false);
  var obsExportsIsShowing = exportsIsVisible.observable().whenDifferent();
  function initExports(revision, obsIsAnyOverlayShowing) {
    (function() {
      var exportButton = document.getElementById('export-button');
      var exportOverlay = document.getElementById('export-overlay');
      var exportDiv = document.getElementById('export-div');
      exportButton.addEventListener('click', function() {
        return exportsIsVisible.set(true);
      });
      obsIsAnyOverlayShowing.subscribe(function(e) {
        exportButton.disabled = e;
      });
      exportOverlay.addEventListener('click', function() {
        return exportsIsVisible.set(false);
      });
      document.addEventListener('keydown', function(e) {
        var ESC_KEY = 27;
        if (e.keyCode === ESC_KEY) {
          exportsIsVisible.set(false);
        }
      });
      obsExportsIsShowing.subscribe(function(showing) {
        exportDiv.style.display = showing ? 'block' : 'none';
        if (showing) {
          document.getElementById('export-link-copy-button').focus();
        }
      });
    })();
    var setupButtonElementCopyToClipboard = function(button, contentElement, resultElement) {
      return button.addEventListener('click', function() {
        try {
          selectAndCopyToClipboard(contentElement);
          resultElement.innerText = "Done!";
        } catch (ex) {
          resultElement.innerText = "It didn't work...";
          console.warn('Clipboard copy failed.', ex);
        }
        button.disabled = true;
        setTimeout(function() {
          resultElement.innerText = "";
          button.disabled = false;
        }, 1000);
      });
    };
    (function() {
      var linkElement = document.getElementById('export-escaped-anchor');
      var copyButton = document.getElementById('export-link-copy-button');
      var copyResultElement = document.getElementById('export-link-copy-result');
      setupButtonElementCopyToClipboard(copyButton, linkElement, copyResultElement);
      revision.latestActiveCommit().subscribe(function(jsonText) {
        var escapedUrlHash = "#" + Config.URL_CIRCUIT_PARAM_KEY + "=" + encodeURIComponent(jsonText);
        linkElement.href = escapedUrlHash;
        linkElement.innerText = document.location.href.split("#")[0] + escapedUrlHash;
      });
    })();
    (function() {
      var jsonTextElement = document.getElementById('export-circuit-json-pre');
      var copyButton = document.getElementById('export-json-copy-button');
      var copyResultElement = document.getElementById('export-json-copy-result');
      setupButtonElementCopyToClipboard(copyButton, jsonTextElement, copyResultElement);
      revision.latestActiveCommit().subscribe(function(jsonText) {
        try {
          var val = JSON.parse(jsonText);
          jsonTextElement.innerText = JSON.stringify(val, null, '  ');
        } catch (_) {
          jsonTextElement.innerText = jsonText;
        }
      });
    })();
    (function() {
      var downloadButton = document.getElementById('download-offline-copy-button');
      var fileNameForState = function(jsonText) {
        try {
          var circuitDef = fromJsonText_CircuitDefinition(jsonText);
          if (!circuitDef.isEmpty()) {
            return ("Quirk with Circuit - " + circuitDef.readableHash() + ".html");
          }
        } catch (_) {}
        return 'Quirk.html';
      };
      var latest;
      revision.latestActiveCommit().subscribe(function(jsonText) {
        downloadButton.innerText = ("Download \"" + fileNameForState(jsonText) + "\"");
        latest = jsonText;
      });
      downloadButton.addEventListener('click', function() {
        downloadButton.disabled = true;
        setTimeout(function() {
          downloadButton.disabled = false;
        }, 1000);
        var originalHtml = document.QUIRK_QUINE_ALL_HTML_ORIGINAL;
        var startDefaultTag = '//DEFAULT_CIRCUIT_START\n';
        var endDefaultTag = '//DEFAULT_CIRCUIT_END\n';
        var modStart = originalHtml.indexOf(startDefaultTag);
        var modStop = originalHtml.indexOf(endDefaultTag, modStart);
        var moddedHtml = originalHtml.substring(0, modStart) + startDefaultTag + 'document.DEFAULT_CIRCUIT = ' + JSON.stringify(latest) + ';\n' + originalHtml.substring(modStop);
        var anaStartTag = '<!-- Start Analytics -->\n';
        var anaStart = moddedHtml.indexOf(anaStartTag);
        if (anaStart !== -1) {
          var anaStopTag = '<!-- End Analytics -->\n';
          var anaStop = moddedHtml.indexOf(anaStopTag, anaStart);
          if (anaStop !== -1) {
            moddedHtml = moddedHtml.substring(0, anaStart) + anaStartTag + moddedHtml.substring(anaStop);
          }
        }
        saveFile(fileNameForState(latest), moddedHtml);
      });
    })();
  }
  return {
    get initExports() {
      return initExports;
    },
    get obsExportsIsShowing() {
      return obsExportsIsShowing;
    }
  };
});
//# sourceURL=src/ui/exports.js
;$traceurRuntime.registerModule("src/ui/forge.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/forge.js";
  var Axis = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Axis.js", "src/ui/forge.js")).Axis;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitDefinition.js", "src/ui/forge.js")).CircuitDefinition;
  var setGateBuilderEffectToCircuit = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitComputeUtil.js", "src/ui/forge.js")).setGateBuilderEffectToCircuit;
  var Complex = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Complex.js", "src/ui/forge.js")).Complex;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/forge.js")).Config;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/ui/forge.js")).DetailedError;
  var drawCircuitTooltip = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/DisplayedCircuit.js", "src/ui/forge.js")).drawCircuitTooltip;
  var Format = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Format.js", "src/ui/forge.js")).Format;
  var $__14 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/ui/forge.js")),
      Gate = $__14.Gate,
      GateBuilder = $__14.GateBuilder;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateColumn.js", "src/ui/forge.js")).GateColumn;
  var getCircuitCycleTime = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/ui/sim.js", "src/ui/forge.js")).getCircuitCycleTime;
  var MathPainter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/MathPainter.js", "src/ui/forge.js")).MathPainter;
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/ui/forge.js")).Matrix;
  var $__19 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Obs.js", "src/ui/forge.js")),
      Observable = $__19.Observable,
      ObservableValue = $__19.ObservableValue;
  var Painter = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/draw/Painter.js", "src/ui/forge.js")).Painter;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/ui/forge.js")).Point;
  var Rect = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Rect.js", "src/ui/forge.js")).Rect;
  var $__23 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Serializer.js", "src/ui/forge.js")),
      fromJsonText_CircuitDefinition = $__23.fromJsonText_CircuitDefinition,
      Serializer = $__23.Serializer;
  var seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/ui/forge.js")).seq;
  var textEditObservable = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/browser/EventUtil.js", "src/ui/forge.js")).textEditObservable;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/ui/forge.js")).Util;
  var forgeIsVisible = new ObservableValue(false);
  var obsForgeIsShowing = forgeIsVisible.observable().whenDifferent();
  function initForge(revision, obsIsAnyOverlayShowing) {
    var obsOnShown = obsForgeIsShowing.filter(function(e) {
      return e === true;
    });
    var latestInspectorText;
    revision.latestActiveCommit().subscribe(function(e) {
      latestInspectorText = e;
    });
    (function() {
      var forgeButton = document.getElementById('gate-forge-button');
      var forgeOverlay = document.getElementById('gate-forge-overlay');
      var forgeDiv = document.getElementById('gate-forge-div');
      forgeButton.addEventListener('click', function() {
        return forgeIsVisible.set(true);
      });
      forgeOverlay.addEventListener('click', function() {
        return forgeIsVisible.set(false);
      });
      obsIsAnyOverlayShowing.subscribe(function(e) {
        forgeButton.disabled = e;
      });
      document.addEventListener('keydown', function(e) {
        var ESC_KEY = 27;
        if (e.keyCode === ESC_KEY) {
          forgeIsVisible.set(false);
        }
      });
      obsForgeIsShowing.subscribe(function(showing) {
        forgeDiv.style.display = showing ? 'block' : 'none';
        if (showing) {
          document.getElementById('gate-forge-rotation-axis').focus();
        }
      });
    })();
    function computeAndPaintOp(canvas, opGetter, button) {
      button.disabled = true;
      var painter = new Painter(canvas);
      painter.clear();
      var d = Math.min((canvas.width - 5) / 2, canvas.height);
      var rect1 = new Rect(0, 0, d, d);
      var rect2 = new Rect(d + 5, 0, d, d);
      try {
        var op = opGetter();
        MathPainter.paintMatrix(painter, op, rect1, Config.OPERATION_FORE_COLOR, 'black', undefined, Config.OPERATION_BACK_COLOR, undefined, 'transparent');
        if (!op.isUnitary(0.009)) {
          painter.printParagraph('NOT UNITARY', rect2, new Point(0.5, 0.5), 'red', 24);
        } else if (op.width() !== 2) {
          painter.printParagraph('(Not a 1-qubit rotation)', rect2, new Point(0.5, 0.5), '#666', 20);
        } else {
          MathPainter.paintBlochSphereRotation(painter, op, rect2, Config.OPERATION_BACK_COLOR, Config.OPERATION_FORE_COLOR);
        }
        var cx = (rect1.right() + rect2.x) / 2;
        painter.strokeLine(new Point(cx, 0), new Point(cx, canvas.height), 'black', 2);
        if (!op.hasNaN()) {
          button.disabled = false;
        }
      } catch (ex) {
        painter.printParagraph(ex + "", new Rect(0, 0, canvas.width, canvas.height), new Point(0.5, 0.5), 'red', 24);
      }
    }
    function createCustomGateAndClose(gate) {
      var circuitDef = arguments[1];
      var c = circuitDef || fromJsonText_CircuitDefinition(latestInspectorText);
      revision.commit(JSON.stringify(Serializer.toJson(c.withCustomGate(gate)), null, 0));
      forgeIsVisible.set(false);
    }
    (function() {
      var $__5;
      var rotationCanvas = document.getElementById('gate-forge-rotation-canvas');
      var rotationButton = document.getElementById('gate-forge-rotation-button');
      var txtAxis = document.getElementById('gate-forge-rotation-axis');
      var txtAngle = document.getElementById('gate-forge-rotation-angle');
      var txtPhase = document.getElementById('gate-forge-rotation-phase');
      var txtName = document.getElementById('gate-forge-rotation-name');
      obsOnShown.subscribe(function() {
        txtName.value = "";
      });
      function parseRotationFromInputs() {
        return parseUserRotation(valueElsePlaceholder(txtAngle), valueElsePlaceholder(txtPhase), valueElsePlaceholder(txtAxis));
      }
      var redraw = function() {
        return computeAndPaintOp(rotationCanvas, parseRotationFromInputs, rotationButton);
      };
      ($__5 = Observable).of.apply($__5, $traceurRuntime.spread([obsOnShown], [txtPhase, txtAxis, txtAngle].map(textEditObservable))).flatten().throttleLatest(100).subscribe(redraw);
      rotationButton.addEventListener('click', function() {
        var mat;
        try {
          mat = parseRotationFromInputs();
        } catch (ex) {
          console.warn(ex);
          return;
        }
        var gate = new GateBuilder().setSerializedId('~' + Math.floor(Math.random() * (1 << 20)).toString(32)).setSymbol(txtName.value).setTitle('Custom Rotation Gate').setKnownEffectToMatrix(mat).gate;
        createCustomGateAndClose(gate);
      });
    })();
    (function() {
      var matrixCanvas = document.getElementById('gate-forge-matrix-canvas');
      var txtMatrix = document.getElementById('gate-forge-matrix');
      var chkFix = document.getElementById('gate-forge-matrix-fix');
      var matrixButton = document.getElementById('gate-forge-matrix-button');
      var txtName = document.getElementById('gate-forge-matrix-name');
      obsOnShown.subscribe(function() {
        txtName.value = "";
      });
      function parseMatrixFromInputs() {
        var text = valueElsePlaceholder(txtMatrix);
        var ensureUnitary = chkFix.checked;
        return parseUserMatrix(text, ensureUnitary);
      }
      var redraw = function() {
        return computeAndPaintOp(matrixCanvas, parseMatrixFromInputs, matrixButton);
      };
      Observable.of(obsOnShown, textEditObservable(txtMatrix), Observable.elementEvent(chkFix, 'change')).flatten().throttleLatest(100).subscribe(redraw);
      matrixButton.addEventListener('click', function() {
        var mat;
        try {
          mat = parseMatrixFromInputs();
        } catch (ex) {
          console.warn(ex);
          return;
        }
        var name = txtName.value.trim();
        var h = Math.round(Math.log2(mat.height()));
        var gate = new GateBuilder().setSerializedId('~' + Math.floor(Math.random() * (1 << 20)).toString(32)).setSymbol(name).setTitle('Custom Matrix Gate').setHeight(h).setWidth(name === '' ? h : 1).setKnownEffectToMatrix(mat).gate;
        createCustomGateAndClose(gate);
      });
    })();
    (function() {
      var circuitCanvas = document.getElementById('gate-forge-circuit-canvas');
      var txtCols = document.getElementById('gate-forge-circuit-cols');
      var txtRows = document.getElementById('gate-forge-circuit-rows');
      var spanInputs = document.getElementById('gate-forge-circuit-inputs');
      var spanWeight = document.getElementById('gate-forge-circuit-weight');
      var circuitButton = document.getElementById('gate-forge-circuit-button');
      var txtName = document.getElementById('gate-forge-circuit-name');
      obsOnShown.subscribe(function() {
        txtName.value = "";
      });
      function parseEnteredCircuitGate() {
        var circuit = fromJsonText_CircuitDefinition(latestInspectorText);
        var gate = parseUserGateFromCircuitRange(circuit, valueElsePlaceholder(txtCols), valueElsePlaceholder(txtRows), txtName.value.trim());
        return {
          gate: gate,
          circuit: circuit
        };
      }
      var latestGate = new ObservableValue(undefined);
      var drawGate = function(painter, gate) {
        return drawCircuitTooltip(painter, gate.knownCircuitNested, new Rect(0, 0, circuitCanvas.width, circuitCanvas.height), true, getCircuitCycleTime());
      };
      latestGate.observable().zipLatest(obsForgeIsShowing, function(g, s) {
        return s ? g : undefined;
      }).map(function(e) {
        return e === undefined || e.gate.stableDuration() === Infinity ? Observable.of() : Observable.requestAnimationTicker().map(function(_) {
          return e;
        });
      }).flattenLatest().subscribe(function(e) {
        var painter = new Painter(circuitCanvas);
        painter.clear();
        drawGate(painter, e.gate);
      });
      var redraw = function() {
        circuitButton.disabled = true;
        var painter = new Painter(circuitCanvas);
        painter.clear();
        try {
          var gate = parseEnteredCircuitGate().gate;
          var keys = gate.getUnmetContextKeys();
          spanInputs.innerText = keys.size === 0 ? "(none)" : $traceurRuntime.spread(keys).map(function(e) {
            return e.replace("Input Range ", "").replace("Input NO_DEFAULT Range ", "");
          }).join(", ");
          spanWeight.innerText = "" + gate.knownCircuit.gateWeight();
          drawGate(painter, gate);
          circuitButton.disabled = false;
          latestGate.set({gate: gate});
        } catch (ex) {
          latestGate.set(undefined);
          spanInputs.innerText = "(err)";
          spanWeight.innerText = "(err)";
          painter.printParagraph(ex + "", new Rect(0, 0, circuitCanvas.width, circuitCanvas.height), new Point(0.5, 0.5), 'red', 24);
        }
      };
      Observable.of(obsOnShown, textEditObservable(txtCols), textEditObservable(txtRows)).flatten().throttleLatest(100).subscribe(redraw);
      circuitButton.addEventListener('click', function() {
        try {
          var $__1 = parseEnteredCircuitGate(),
              gate = $__1.gate,
              circuit = $__1.circuit;
          createCustomGateAndClose(gate, circuit);
        } catch (ex) {
          console.warn(ex);
        }
      });
    })();
  }
  function valueElsePlaceholder(textBox) {
    return textBox.value === '' ? textBox.placeholder : textBox.value;
  }
  function parseUserAngle(text) {
    var c = Complex.parse(text);
    if (c.imag !== 0 || isNaN(c.imag)) {
      throw new Error("You just had to make it complicated, didn't you?");
    }
    return c.real * Math.PI / 180;
  }
  function decreasePrecisionAndSerializedSize(matrix) {
    return Matrix.parse(matrix.toString(new Format(true, 0.0000001, 7, ",")));
  }
  function parseUserRotation(angleText, phaseText, axisText) {
    var $__3,
        $__4;
    var w = parseUserAngle(angleText);
    var phase = parseUserAngle(phaseText);
    var $__1 = Axis.parse(axisText),
        x = $__1.x,
        y = $__1.y,
        z = $__1.z;
    var len = Math.sqrt(x * x + y * y + z * z);
    x /= len;
    y /= len;
    z /= len;
    var $__2 = [Matrix.identity(2), Matrix.PAULI_X, Matrix.PAULI_Y, Matrix.PAULI_Z],
        I = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
        X = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        Y = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        Z = ($__4 = $__3.next()).done ? void 0 : $__4.value;
    var axisMatrix = X.times(x).plus(Y.times(y)).plus(Z.times(z));
    var result = I.times(Math.cos(w / 2)).plus(axisMatrix.times(Complex.I.neg()).times(Math.sin(w / 2))).times(Complex.polar(1, phase));
    if (result.hasNaN()) {
      throw new DetailedError("NaN", {
        x: x,
        y: y,
        z: z,
        result: result
      });
    }
    return decreasePrecisionAndSerializedSize(result);
  }
  function parseUserGateMatrix_noCorrection(text) {
    var $__5;
    if (text.match(/[\{}\[\]]/)) {
      return Matrix.parse(text.split(/[\{\[]/).join('{').split(/[}\]]/).join('}'));
    }
    text = text.split(/,?\s*\n\s*(?!$)/).join(',');
    text = text.trim();
    if (text.endsWith(',')) {
      text = text.substring(0, text.length - 1);
    }
    var parts = text.split(',').map(function(e) {
      return e === '' ? 0 : Complex.parse(e);
    });
    if (parts.length === 1) {
      parts.push(0, 0, parts[0]);
    }
    var n = Math.max(4, 1 << (2 * Math.max(1, Util.floorLg2(Math.sqrt(parts.length)))));
    if (n < parts.length) {
      n <<= 2;
    }
    if (n > (1 << 8)) {
      throw Error("Max custom matrix operation size is 4 qubits.");
    }
    return ($__5 = Matrix).square.apply($__5, $traceurRuntime.spread(parts, new Array(n - parts.length).fill(0)));
  }
  function parseUserMatrix(text, ensureUnitary) {
    var op = parseUserGateMatrix_noCorrection(text);
    if (op.width() !== op.height() || op.width() < 2 || op.width() > 16 || !Util.isPowerOf2(op.width())) {
      throw Error("Matrix must be 2x2, 4x4, 8x8, or 16x16.");
    }
    if (ensureUnitary && !op.hasNaN()) {
      op = op.closestUnitary(0.0001);
      op = decreasePrecisionAndSerializedSize(op);
    }
    return op;
  }
  function parseRange(text, maxLen) {
    var parts = text.split(":").map(function(e) {
      return e.trim();
    });
    if (parts.length > 2) {
      throw new Error("Too many colons.");
    }
    var infinities = [undefined, "", "∞"];
    var min = parseInt(parts[0] || "1");
    var max = infinities.indexOf(parts[1]) !== -1 ? Infinity : parseInt(parts[1]);
    if (isNaN(min)) {
      throw new Error("Not a number: " + parts[0]);
    }
    if (isNaN(max)) {
      throw new Error("Not a number: " + parts[1]);
    }
    var start = Math.min(maxLen, Math.max(0, min - 1));
    var end = Math.min(maxLen, Math.max(start, max));
    return {
      start: start,
      end: end
    };
  }
  function removeBrokenGates(circuit) {
    var w = circuit.columns.length;
    var h = circuit.numWires;
    return circuit.withColumns(seq(circuit.columns).mapWithIndex(function(col, c) {
      return new GateColumn(seq(col.gates).mapWithIndex(function(gate, r) {
        return gate === undefined || c + gate.width > w || r + gate.height > h ? undefined : gate;
      }).toArray());
    }).toArray());
  }
  function parseUserGateFromCircuitRange(circuit, colRangeText, wireRangeText, nameText) {
    var colRange = parseRange(colRangeText, circuit.columns.length);
    var rowRange = parseRange(wireRangeText, circuit.numWires);
    if (rowRange.end === rowRange.start) {
      throw new Error("Empty wire range.");
    }
    var cols = circuit.columns.slice(colRange.start, colRange.end).map(function(col) {
      return new GateColumn(col.gates.slice(rowRange.start, rowRange.end));
    });
    var gateCircuit = new CircuitDefinition(rowRange.end - rowRange.start, cols);
    gateCircuit = removeBrokenGates(gateCircuit);
    gateCircuit = gateCircuit.withUncoveredColumnsRemoved();
    if (gateCircuit.columns.length === 0) {
      throw new Error("No gates in included range.");
    }
    var symbol = nameText;
    var id = '~' + Math.floor(Math.random() * (1 << 20)).toString(32);
    return setGateBuilderEffectToCircuit(new GateBuilder(), gateCircuit).setSerializedId(id).setSymbol(symbol).setTitle(id).setBlurb('A custom gate.').gate;
  }
  return {
    get initForge() {
      return initForge;
    },
    get obsForgeIsShowing() {
      return obsForgeIsShowing;
    },
    get parseUserRotation() {
      return parseUserRotation;
    },
    get parseUserMatrix() {
      return parseUserMatrix;
    },
    get parseUserGateFromCircuitRange() {
      return parseUserGateFromCircuitRange;
    }
  };
});
//# sourceURL=src/ui/forge.js
;$traceurRuntime.registerModule("src/ui/Hand.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/Hand.js";
  var describe = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Describe.js", "src/ui/Hand.js")).describe;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/ui/Hand.js")).DetailedError;
  var Gate = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Gate.js", "src/ui/Hand.js")).Gate;
  var GateColumn = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/GateColumn.js", "src/ui/Hand.js")).GateColumn;
  var Point = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Point.js", "src/ui/Hand.js")).Point;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/ui/Hand.js")).Util;
  var Hand = function() {
    function Hand(pos, heldGate, holdOffset, heldColumn, resizingGateSlot) {
      if (pos !== undefined && !(pos instanceof Point)) {
        throw new DetailedError("Bad pos", {
          pos: pos,
          heldGate: heldGate,
          holdOffset: holdOffset,
          heldColumn: heldColumn,
          resizingGateSlot: resizingGateSlot
        });
      }
      if (heldGate !== undefined && !(heldGate instanceof Gate)) {
        throw new DetailedError("Bad heldGate", {
          pos: pos,
          heldGate: heldGate,
          holdOffset: holdOffset,
          heldColumn: heldColumn,
          resizingGateSlot: resizingGateSlot
        });
      }
      if (holdOffset !== undefined && !(holdOffset instanceof Point)) {
        throw new DetailedError("Bad holdOffset", {
          pos: pos,
          heldGate: heldGate,
          holdOffset: holdOffset,
          heldColumn: heldColumn,
          resizingGateSlot: resizingGateSlot
        });
      }
      if (resizingGateSlot !== undefined && !(resizingGateSlot instanceof Point)) {
        throw new DetailedError("Bad resizingGateSlot", {
          pos: pos,
          heldGate: heldGate,
          holdOffset: holdOffset,
          heldColumn: heldColumn,
          resizingGateSlot: resizingGateSlot
        });
      }
      if (heldColumn !== undefined && !(heldColumn instanceof GateColumn)) {
        throw new DetailedError("Bad heldColumn", {
          pos: pos,
          heldGate: heldGate,
          holdOffset: holdOffset,
          heldColumn: heldColumn,
          resizingGateSlot: resizingGateSlot
        });
      }
      if (heldGate !== undefined && this.resizingGateSlot !== undefined) {
        throw new DetailedError("Holding AND resizing", {
          pos: pos,
          heldGate: heldGate,
          holdOffset: holdOffset,
          heldColumn: heldColumn,
          resizingGateSlot: resizingGateSlot
        });
      }
      this.pos = pos;
      this.heldGate = heldGate;
      this.holdOffset = holdOffset;
      this.heldColumn = heldColumn;
      this.resizingGateSlot = resizingGateSlot;
    }
    return ($traceurRuntime.createClass)(Hand, {
      paintCursor: function(painter) {
        if (this.heldGate !== undefined || this.heldColumn !== undefined) {
          painter.setDesiredCursor('move');
        } else if (this.resizingGateSlot !== undefined) {
          painter.setDesiredCursor('ns-resize');
        }
      },
      isBusy: function() {
        return this.heldGate !== undefined || this.heldColumn !== undefined || this.resizingGateSlot !== undefined;
      },
      hoverPoints: function() {
        return this.pos === undefined || this.isBusy() ? [] : [this.pos];
      },
      isEqualTo: function(other) {
        if (this === other) {
          return true;
        }
        return other instanceof Hand && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.pos, other.pos) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.holdOffset, other.holdOffset) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.heldGate, other.heldGate) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.heldColumn, other.heldColumn) && Util.CUSTOM_IS_EQUAL_TO_EQUALITY(this.resizingGateSlot, other.resizingGateSlot);
      },
      toString: function() {
        return ("Hand(" + describe({
          pos: this.pos,
          heldGate: this.heldGate,
          holdOffset: this.holdOffset,
          heldColumn: this.heldColumn,
          resizingGateSlot: this.resizingGateSlot
        }));
      },
      withPos: function(newPos) {
        return new Hand(newPos, this.heldGate, this.holdOffset, this.heldColumn, this.resizingGateSlot);
      },
      withDrop: function() {
        return new Hand(this.pos, undefined, undefined, undefined, undefined);
      },
      withHeldGate: function(heldGate, heldGateOffset) {
        return new Hand(this.pos, heldGate, heldGateOffset, undefined, undefined);
      },
      withHeldGateColumn: function(heldGateColumn, heldGateOffset) {
        return new Hand(this.pos, undefined, heldGateOffset, heldGateColumn, undefined);
      },
      withResizeSlot: function(resizeSlot, resizeTabOffset) {
        return new Hand(this.pos, undefined, resizeTabOffset, undefined, resizeSlot);
      },
      stableDuration: function() {
        return this.heldGate !== undefined ? this.heldGate.stableDuration() : this.heldColumn !== undefined ? this.heldColumn.stableDuration() : Infinity;
      }
    }, {});
  }();
  Hand.EMPTY = new Hand(undefined, undefined, undefined, undefined, undefined);
  return {get Hand() {
      return Hand;
    }};
});
//# sourceURL=src/ui/Hand.js
;$traceurRuntime.registerModule("src/ui/menu.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/menu.js";
  var ObservableValue = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Obs.js", "src/ui/menu.js")).ObservableValue;
  var menuIsVisible = new ObservableValue(true);
  var obsMenuIsShowing = menuIsVisible.observable().whenDifferent();
  var closeMenu = function() {
    return menuIsVisible.set(false);
  };
  var groverLink = {
    "cols": [["X", "X", "X", "X", "X"], ["H", "H", "H", "H", "H"], ["Chance5"], ["~vn6c"], ["⊖", "⊖", "⊖", "⊖", "X"], ["Chance5"], ["~vn6c"], ["⊖", "⊖", "⊖", "⊖", "X"], ["Chance5"], ["~vn6c"], ["⊖", "⊖", "⊖", "⊖", "X"], ["Chance5"], ["~vn6c"], ["⊖", "⊖", "⊖", "⊖", "X"], ["Chance5"]],
    "gates": [{
      "id": "~vn6c",
      "name": "Oracle",
      "circuit": {"cols": [["Z", "•", "◦", "•", "•"]]}
    }]
  };
  var teleportLink = {
    "cols": [[1, "H"], [1, "•", 1, 1, "X"], ["…", "…", 1, 1, "…"], ["…", "…", 1, 1, "…"], ["~87lj"], ["Bloch"], ["•", "X"], ["H"], ["Measure", "Measure"], [1, "•", 1, 1, "X"], ["•", 1, 1, 1, "Z"], [1, 1, 1, 1, "Bloch"], [1, 1, 1, 1, "~f7c0"]],
    "gates": [{
      "id": "~87lj",
      "name": "message",
      "circuit": {"cols": [["e^-iYt"], ["X^t"]]}
    }, {
      "id": "~f7c0",
      "name": "received",
      "matrix": "{[1,0},{0,1]}"
    }]
  };
  var eraserLink = {
    "cols": [[1, "H"], [1, "•", 1, 1, "X"], [1, "~slits", "QFT7"], [1, 1, "Measure", "Measure", "Measure", "Measure", "Measure", "Measure", "Measure"], ["…", "…", "Chance7"], ["…", "…"], ["…", "…"], ["…", "…"], ["H"], ["Measure"], ["~choice"], ["•", "X^½"], [1, "Measure"], [1, "~result", 1, 1, 1, "~flat"], ["◦", "◦", "Chance7"], ["◦", "•", "Chance7"], [1, 1, 1, 1, 1, "~waves"], ["•", "◦", "Chance7"], ["•", "•", "Chance7"]],
    "gates": [{
      "id": "~choice",
      "name": "choice",
      "matrix": "{[1,0},{0,1]}"
    }, {
      "id": "~result",
      "name": "result",
      "matrix": "{[1,0},{0,1]}"
    }, {
      "id": "~flat",
      "name": "flat",
      "matrix": "{[1,0},{0,1]}"
    }, {
      "id": "~waves",
      "name": "waves",
      "matrix": "{[1,0},{0,1]}"
    }, {
      "id": "~slits",
      "name": "slits",
      "matrix": "{[1,0},{0,1]}"
    }]
  };
  var chshTestLink = {
    "cols": [["H"], ["◦", 1, 1, 1, "X"], ["X^-¼"], ["…", "…", "…", "…", "…"], ["~da85", "~5s2n", 1, "~5s2n", "~ahov"], [1, "H", 1, "H"], [1, "Measure", 1, "Measure"], ["X^½", "•"], [1, 1, 1, "•", "X^½"], ["Measure", 1, 1, 1, "Measure"], ["…", "…", "…", "…", "…"], [1, "•", "X", "•"], ["•", 1, "X"], [1, 1, "X", 1, "•"], [1, 1, "Chance"], [1, 1, "~q6e"]],
    "gates": [{
      "id": "~da85",
      "name": "Alice",
      "matrix": "{[1,0},{0,1]}"
    }, {
      "id": "~ahov",
      "name": "Bob",
      "matrix": "{[1,0},{0,1]}"
    }, {
      "id": "~5s2n",
      "name": "Referee",
      "matrix": "{[1,0},{0,1]}"
    }, {
      "id": "~q6e",
      "name": "Win?",
      "matrix": "{[1,0},{0,1]}"
    }]
  };
  var additionLink = {"cols": [["Counting5", 1, 1, 1, 1, 1, 1, 1, "X"], ["Chance5", 1, 1, 1, 1, "Chance5"], ["X", "X", "X", "X", "•", "X", "X", "X", "X", "X"], [1, 1, 1, 1, "•", "X"], ["Swap", 1, 1, 1, "Swap", "•"], [1, 1, 1, 1, "•", 1, "X"], [1, "Swap", 1, 1, "Swap", 1, "•"], [1, 1, 1, 1, "•", 1, 1, "X"], [1, 1, "Swap", 1, "Swap", 1, 1, "•"], [1, 1, 1, 1, "•", 1, 1, 1, "X"], [1, 1, 1, "Swap", "Swap", 1, 1, 1, "•"], [1, 1, 1, 1, "•", 1, 1, 1, 1, "X"], [1, 1, 1, "Swap", "Swap", 1, 1, 1, "•"], [1, 1, 1, "•", 1, 1, 1, 1, "X"], [1, 1, "Swap", 1, "Swap", 1, 1, "•"], [1, 1, "•", 1, 1, 1, 1, "X"], [1, "Swap", 1, 1, "Swap", 1, "•"], [1, "•", 1, 1, 1, 1, "X"], ["Swap", 1, 1, 1, "Swap", "•"], ["•", 1, 1, 1, 1, "X"], ["X", "X", "X", "X", "•", "X", "X", "X", "X", "X"], ["Chance5", 1, 1, 1, 1, "Chance5"]]};
  var qftLink = {"cols": [["Counting8"], ["Chance8"], ["…", "…", "…", "…", "…", "…", "…", "…"], ["Swap", 1, 1, 1, 1, 1, 1, "Swap"], [1, "Swap", 1, 1, 1, 1, "Swap"], [1, 1, "Swap", 1, 1, "Swap"], [1, 1, 1, "Swap", "Swap"], ["H"], ["Z^½", "•"], [1, "H"], ["Z^¼", "Z^½", "•"], [1, 1, "H"], ["Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, "H"], ["Z^⅟₁₆", "Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, 1, "H"], ["Z^⅟₃₂", "Z^⅟₁₆", "Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, 1, 1, "H"], ["Z^⅟₆₄", "Z^⅟₃₂", "Z^⅟₁₆", "Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, 1, 1, 1, "H"], ["Z^⅟₁₂₈", "Z^⅟₆₄", "Z^⅟₃₂", "Z^⅟₁₆", "Z^⅛", "Z^¼", "Z^½", "•"], [1, 1, 1, 1, 1, 1, 1, "H"]]};
  var superdenseCodingLink = {
    "cols": [[1, 1, "H"], [1, 1, "•", 1, 1, 1, "X"], ["…", "…", "…", "…", "…", "…", "…"], ["Counting2"], ["Measure", "Measure"], ["~msg"], ["Chance", "Chance"], ["~enc"], [1, "•", "X"], ["•", 1, "Z"], [1, 1, 1, "~send"], [1, 1, "Swap", 1, 1, "Swap"], [1, 1, 1, 1, 1, "~dec"], [1, 1, 1, 1, 1, "•", "X"], [1, 1, 1, 1, 1, "H"], [1, 1, 1, 1, 1, "Measure", "Measure"], [1, 1, 1, 1, 1, "~msg"], [1, 1, 1, 1, 1, "Chance", "Chance"]],
    "gates": [{
      "id": "~msg",
      "name": "message",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }, {
      "id": "~enc",
      "name": "encode",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }, {
      "id": "~send",
      "name": "send",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }, {
      "id": "~dec",
      "name": "decode",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }]
  };
  var symmetryBreakingLink = {
    "cols": [["~tpqg", 1, "~r2ku"], ["…", "…", "…", "…"], ["H"], [1, 1, "H"], ["•", "X"], [1, 1, "•", "X"], [1, "Swap", 1, "Swap"], ["•", "X"], [1, 1, "•", "X"], ["X^½", "◦"], [1, 1, "X^½", "◦"], [1, "X^½"], [1, 1, 1, "X^½"], ["Measure", "Measure", "Measure", "Measure"], [1, "~57au"], ["•", 1, "Chance"], [1, "•", 1, "Chance"], ["◦", 1, "Chance"], [1, "◦", 1, "Chance"]],
    "gates": [{
      "id": "~tpqg",
      "name": "Alice^1",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }, {
      "id": "~r2ku",
      "name": "Alice^2",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }, {
      "id": "~57au",
      "name": "disagree",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }]
  };
  var shorLink = {
    "cols": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, "~input", 1, 1, 1, "~guess"], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, {
      "id": "setR",
      "arg": 55
    }, 1, 1, 1, {
      "id": "setB",
      "arg": 26
    }], [], ["H", "H", "H", "H", "H", "H", "H", "H", "H", "H", "X"], ["inputA10", 1, 1, 1, 1, 1, 1, 1, 1, 1, "*BToAmodR6"], ["QFT†10"], [1, 1, 1, 1, "~out"], ["Chance10"]],
    "gates": [{
      "id": "~guess",
      "name": "guess:",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }, {
      "id": "~input",
      "name": "input:",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }, {
      "id": "~out",
      "name": "out:",
      "matrix": "{[1,0,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1]}"
    }]
  };
  function initMenu(revision, obsIsAnyOverlayShowing) {
    var $__11,
        $__12;
    (function() {
      var menuButton = document.getElementById('menu-button');
      var closeMenuButton = document.getElementById('close-menu-button');
      var menuOverlay = document.getElementById('menu-overlay');
      var menutDiv = document.getElementById('menu-div');
      menuButton.addEventListener('click', function() {
        return menuIsVisible.set(true);
      });
      obsIsAnyOverlayShowing.subscribe(function(e) {
        menuButton.disabled = e;
      });
      menuOverlay.addEventListener('click', function() {
        return menuIsVisible.set(false);
      });
      closeMenuButton.addEventListener('click', function() {
        return menuIsVisible.set(false);
      });
      document.addEventListener('keydown', function(e) {
        var ESC_KEY = 27;
        if (e.keyCode === ESC_KEY) {
          menuIsVisible.set(false);
        }
      });
      obsMenuIsShowing.subscribe(function(showing) {
        menutDiv.style.display = showing ? 'block' : 'none';
        if (showing) {
          document.getElementById('export-link-copy-button').focus();
        }
      });
    })();
    var groverAnchor = document.getElementById('example-anchor-grover');
    var teleportAnchor = document.getElementById('example-anchor-teleport');
    var eraserAnchor = document.getElementById('example-anchor-delayed-eraser');
    var additionAnchor = document.getElementById('example-addition');
    var superdenseCodeAnchor = document.getElementById('example-superdense-coding');
    var symmetryBreakAnchor = document.getElementById('example-symmetry-break');
    var chshTestAnchor = document.getElementById('example-chsh-test');
    var qftAnchor = document.getElementById('example-qft');
    var shorAnchor = document.getElementById('example-anchor-shor');
    var $__6 = true;
    var $__7 = false;
    var $__8 = undefined;
    try {
      var $__13 = function() {
        var $__10 = $__4.value,
            a = ($__11 = $__10[Symbol.iterator](), ($__12 = $__11.next()).done ? void 0 : $__12.value),
            t = ($__12 = $__11.next()).done ? void 0 : $__12.value;
        {
          var text = JSON.stringify(t);
          a.href = "#circuit=" + text;
          a.onclick = function(ev) {
            if (ev.shiftKey || ev.ctrlKey || ev.altKey || ev.which !== 1) {
              return undefined;
            }
            revision.commit(text);
            menuIsVisible.set(false);
            return false;
          };
        }
      };
      for (var $__4 = void 0,
          $__3 = ([[groverAnchor, groverLink], [shorAnchor, shorLink], [teleportAnchor, teleportLink], [eraserAnchor, eraserLink], [additionAnchor, additionLink], [superdenseCodeAnchor, superdenseCodingLink], [symmetryBreakAnchor, symmetryBreakingLink], [chshTestAnchor, chshTestLink], [qftAnchor, qftLink]])[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
        $__13();
      }
    } catch ($__9) {
      $__7 = true;
      $__8 = $__9;
    } finally {
      try {
        if (!$__6 && $__3.return != null) {
          $__3.return();
        }
      } finally {
        if ($__7) {
          throw $__8;
        }
      }
    }
  }
  return {
    get initMenu() {
      return initMenu;
    },
    get obsMenuIsShowing() {
      return obsMenuIsShowing;
    },
    get closeMenu() {
      return closeMenu;
    }
  };
});
//# sourceURL=src/ui/menu.js
;$traceurRuntime.registerModule("src/ui/run.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/run.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/run.js")).Config;
  var ObservableValue = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Obs.js", "src/ui/run.js")).ObservableValue;
  var selectAndCopyToClipboard = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/browser/Clipboard.js", "src/ui/run.js")).selectAndCopyToClipboard;
  var fromJsonText_CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Serializer.js", "src/ui/run.js")).fromJsonText_CircuitDefinition;
  var runIsVisible = new ObservableValue(false);
  var obsRunsIsShowing = runIsVisible.observable().whenDifferent();
  function initRun(revision, obsIsAnyOverlayShowing) {
    (function() {
      var runButton = document.getElementById('run-button');
      var runOverlay = document.getElementById('run-overlay');
      var runDiv = document.getElementById('run-div');
      runButton.addEventListener('click', function() {
        $.getJSON("{{ url_for('quantumCircuit.run')}}", {data: document.getElementById('run-circuit-json-pre').innerText}, function(data) {
          runIsVisible.set(true);
          document.getElementById('run-circuit-json-show').innerText = JSON.stringify(data);
          xDomain = 0;
          yDomain = 0;
          yDomainMin = 0;
          xDomainMin = 0;
          if (Array.isArray(data)) {
            updateChart(data);
          }
        });
      });
      obsIsAnyOverlayShowing.subscribe(function(e) {
        return runButton.disabled = e;
      });
      runOverlay.addEventListener('click', function() {
        return runIsVisible.set(false);
      });
      document.addEventListener('keydown', function(e) {
        var ESC_KEY = 27;
        if (e.keyCode === ESC_KEY) {
          runIsVisible.set(false);
        }
      });
      obsRunsIsShowing.subscribe(function(showing) {
        runDiv.style.display = showing ? 'block' : 'none';
      });
    })();
    (function() {
      var jsonTextElement = document.getElementById('run-circuit-json-pre');
      revision.latestActiveCommit().subscribe(function(jsonText) {
        try {
          var val = JSON.parse(jsonText);
          jsonTextElement.innerText = JSON.stringify(val, null, '  ');
        } catch (_) {
          jsonTextElement.innerText = jsonText;
        }
      });
    })();
  }
  return {
    get initRun() {
      return initRun;
    },
    get obsRunsIsShowing() {
      return obsRunsIsShowing;
    }
  };
});
//# sourceURL=src/ui/run.js
;$traceurRuntime.registerModule("src/ui/sim.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/sim.js";
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitDefinition.js", "src/ui/sim.js")).CircuitDefinition;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/sim.js")).Config;
  var CircuitStats = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitStats.js", "src/ui/sim.js")).CircuitStats;
  var getCircuitCycleTime = (function() {
    var _circuitCycleTime = 0;
    var _prevRealTime = performance.now();
    return function() {
      var nextRealTime = performance.now();
      var elapsed = (nextRealTime - _prevRealTime) / Config.CYCLE_DURATION_MS;
      _circuitCycleTime += elapsed;
      _circuitCycleTime %= 1;
      _prevRealTime = nextRealTime;
      return _circuitCycleTime;
    };
  })();
  var _cachedStats = undefined;
  function simulate(circuit) {
    if (_cachedStats !== undefined && _cachedStats.circuitDefinition.isEqualTo(circuit)) {
      return _cachedStats.withTime(getCircuitCycleTime());
    }
    _cachedStats = undefined;
    var result = CircuitStats.fromCircuitAtTime(circuit, getCircuitCycleTime());
    if (circuit.stableDuration() === Infinity) {
      _cachedStats = result;
    }
    return result;
  }
  return {
    get simulate() {
      return simulate;
    },
    get getCircuitCycleTime() {
      return getCircuitCycleTime;
    }
  };
});
//# sourceURL=src/ui/sim.js
;$traceurRuntime.registerModule("src/ui/title.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/title.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/title.js")).Config;
  var fromJsonText_CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Serializer.js", "src/ui/title.js")).fromJsonText_CircuitDefinition;
  function initTitleSync(revision) {
    var titleForState = function(jsonText) {
      try {
        var circuitDef = fromJsonText_CircuitDefinition(jsonText);
        if (!circuitDef.isEmpty()) {
          return ("Quirk: " + circuitDef.readableHash());
        }
      } catch (_) {}
      return Config.EMPTY_CIRCUIT_TITLE;
    };
    revision.latestActiveCommit().subscribe(function(jsonText) {
      setTimeout(function() {
        document.title = titleForState(jsonText);
      }, 0);
    });
  }
  return {get initTitleSync() {
      return initTitleSync;
    }};
});
//# sourceURL=src/ui/title.js
;$traceurRuntime.registerModule("src/ui/undo.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/undo.js";
  function initUndoRedo(revision, obsIsAnyOverlayShowing) {
    var overlay_divs = [document.getElementById('gate-forge-div'), document.getElementById('export-div')];
    var undoButton = document.getElementById('undo-button');
    var redoButton = document.getElementById('redo-button');
    revision.latestActiveCommit().zipLatest(obsIsAnyOverlayShowing, function(_, b) {
      return b;
    }).subscribe(function(anyShowing) {
      undoButton.disabled = revision.isAtBeginningOfHistory() || anyShowing;
      redoButton.disabled = revision.isAtEndOfHistory() || anyShowing;
    });
    undoButton.addEventListener('click', function() {
      return revision.undo();
    });
    redoButton.addEventListener('click', function() {
      return revision.redo();
    });
    document.addEventListener("keydown", function(e) {
      var $__3 = true;
      var $__4 = false;
      var $__5 = undefined;
      try {
        for (var $__1 = void 0,
            $__0 = (overlay_divs)[Symbol.iterator](); !($__3 = ($__1 = $__0.next()).done); $__3 = true) {
          var div = $__1.value;
          {
            if (div.style.display !== 'NONE' && div.style.display !== 'none') {
              return;
            }
          }
        }
      } catch ($__6) {
        $__4 = true;
        $__5 = $__6;
      } finally {
        try {
          if (!$__3 && $__0.return != null) {
            $__0.return();
          }
        } finally {
          if ($__4) {
            throw $__5;
          }
        }
      }
      var Y_KEY = 89;
      var Z_KEY = 90;
      var isUndo = e.keyCode === Z_KEY && e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey;
      var isRedo1 = e.keyCode === Z_KEY && e.ctrlKey && e.shiftKey && !e.altKey && !e.metaKey;
      var isRedo2 = e.keyCode === Y_KEY && e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey;
      if (isUndo) {
        revision.undo();
        e.preventDefault();
      }
      if (isRedo1 || isRedo2) {
        revision.redo();
        e.preventDefault();
      }
    });
  }
  return {get initUndoRedo() {
      return initUndoRedo;
    }};
});
//# sourceURL=src/ui/undo.js
;$traceurRuntime.registerModule("src/ui/url.js", [], function() {
  "use strict";
  var __moduleName = "src/ui/url.js";
  var notifyAboutRecoveryFromUnexpectedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/fallback.js", "src/ui/url.js")).notifyAboutRecoveryFromUnexpectedError;
  var CircuitDefinition = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/CircuitDefinition.js", "src/ui/url.js")).CircuitDefinition;
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/ui/url.js")).Config;
  var HistoryPusher = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/browser/HistoryPusher.js", "src/ui/url.js")).HistoryPusher;
  var $__12 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/circuit/Serializer.js", "src/ui/url.js")),
      fromJsonText_CircuitDefinition = $__12.fromJsonText_CircuitDefinition,
      Serializer = $__12.Serializer;
  function urlWithCircuitHash(jsonText) {
    if (jsonText.indexOf('%') !== -1 || jsonText.indexOf('&') !== -1) {
      jsonText = encodeURIComponent(jsonText);
    }
    return "#" + Config.URL_CIRCUIT_PARAM_KEY + "=" + jsonText;
  }
  function initUrlCircuitSync(revision) {
    var getHashParameters = function() {
      var hashText = document.location.hash.substr(1);
      var paramsMap = new Map();
      if (hashText !== "") {
        var $__4 = true;
        var $__5 = false;
        var $__6 = undefined;
        try {
          for (var $__2 = void 0,
              $__1 = (hashText.split("&"))[Symbol.iterator](); !($__4 = ($__2 = $__1.next()).done); $__4 = true) {
            var keyVal = $__2.value;
            {
              var eq = keyVal.indexOf("=");
              if (eq === -1) {
                continue;
              }
              var key = keyVal.substring(0, eq);
              var val = decodeURIComponent(keyVal.substring(eq + 1));
              paramsMap.set(key, val);
            }
          }
        } catch ($__7) {
          $__5 = true;
          $__6 = $__7;
        } finally {
          try {
            if (!$__4 && $__1.return != null) {
              $__1.return();
            }
          } finally {
            if ($__5) {
              throw $__6;
            }
          }
        }
      }
      return paramsMap;
    };
    var historyPusher = new HistoryPusher();
    var loadCircuitFromUrl = function() {
      try {
        historyPusher.currentStateIsMemorableButUnknown();
        var params = getHashParameters();
        if (!params.has(Config.URL_CIRCUIT_PARAM_KEY)) {
          var def = document.DEFAULT_CIRCUIT || JSON.stringify(Serializer.toJson(CircuitDefinition.EMPTY));
          params.set(Config.URL_CIRCUIT_PARAM_KEY, def);
        }
        var jsonText = params.get(Config.URL_CIRCUIT_PARAM_KEY);
        historyPusher.currentStateIsMemorableAndEqualTo(jsonText);
        var circuitDef = fromJsonText_CircuitDefinition(jsonText);
        var cleanedJson = JSON.stringify(Serializer.toJson(circuitDef));
        revision.clear(cleanedJson);
        if (circuitDef.isEmpty() && params.size === 1) {
          historyPusher.currentStateIsNotMemorable();
        } else {
          var urlHash = urlWithCircuitHash(jsonText);
          historyPusher.stateChange(jsonText, urlHash);
        }
      } catch (ex) {
        notifyAboutRecoveryFromUnexpectedError("Defaulted to an empty circuit. Failed to understand circuit from URL.", {document_location_hash: document.location.hash}, ex);
      }
    };
    window.addEventListener('popstate', loadCircuitFromUrl);
    loadCircuitFromUrl();
    revision.latestActiveCommit().whenDifferent().skip(1).subscribe(function(jsonText) {
      historyPusher.stateChange(jsonText, urlWithCircuitHash(jsonText));
    });
  }
  return {get initUrlCircuitSync() {
      return initUrlCircuitSync;
    }};
});
//# sourceURL=src/ui/url.js
;$traceurRuntime.registerModule("src/webgl/ShaderCoders_Base.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/ShaderCoders_Base.js";
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/webgl/ShaderCoders_Base.js")).WglArg;
  var ShaderPart = function() {
    function ShaderPart(code, libs, argsFor) {
      this.code = code;
      this.libs = libs;
      this.argsFor = argsFor;
    }
    return ($traceurRuntime.createClass)(ShaderPart, {}, {});
  }();
  var SingleTypeCoder = function() {
    function SingleTypeCoder(inputPartGetter, outputPart, powerSizeOverhead, pixelType, dataToPixels, pixelsToData, needRearrangingToBeInVec4Format) {
      this.inputPartGetter = inputPartGetter;
      this.outputPart = outputPart;
      this.powerSizeOverhead = powerSizeOverhead;
      this.pixelType = pixelType;
      this.dataToPixels = dataToPixels;
      this.pixelsToData = pixelsToData;
      this.needRearrangingToBeInVec4Format = needRearrangingToBeInVec4Format;
    }
    return ($traceurRuntime.createClass)(SingleTypeCoder, {arrayPowerSizeOfTexture: function(tex) {
        return tex.sizePower() - this.powerSizeOverhead;
      }}, {});
  }();
  var ShaderCoder = function() {
    function ShaderCoder(bool, float, vec2, vec4) {
      this.bool = bool;
      this.float = float;
      this.vec2 = vec2;
      this.vec4 = vec4;
    }
    return ($traceurRuntime.createClass)(ShaderCoder, {}, {});
  }();
  function boolInputPartGetter(name) {
    var pre = ("_gen_" + name);
    return new ShaderPart(("\n        ///////////// boolInput(" + name + ") ////////////\n        uniform sampler2D " + pre + "_tex;\n        uniform vec2 " + pre + "_size;\n\n        float read_" + name + "(float k) {\n            vec2 uv = vec2(mod(k, " + pre + "_size.x) + 0.5,\n                           floor(k / " + pre + "_size.x) + 0.5) / " + pre + "_size;\n            return float(texture2D(" + pre + "_tex, uv).x == 1.0);\n        }\n\n        float len_" + name + "() {\n            return " + pre + "_size.x * " + pre + "_size.y * 4.0;\n        }"), [], function(texture) {
      return [WglArg.texture((pre + "_tex"), texture), WglArg.vec2((pre + "_size"), texture.width, texture.height)];
    });
  }
  var BOOL_OUTPUT_PART = new ShaderPart("\n    ///////////// BOOL_OUTPUT_AS_FLOAT ////////////\n    bool outputFor(float k);\n\n    uniform vec2 _gen_output_size;\n    uniform float _gen_secret_half;\n\n    float len_output() {\n        return _gen_output_size.x * _gen_output_size.y;\n    }\n\n    void main() {\n        vec2 xy = gl_FragCoord.xy - vec2(_gen_secret_half, _gen_secret_half);\n        float k = xy.y * _gen_output_size.x + xy.x;\n        gl_FragColor = vec4(float(outputFor(k)), 0.0, 0.0, 0.0);\n    }", [], function(texture) {
    return [WglArg.vec2('_gen_output_size', texture.width, texture.height), WglArg.float('_gen_secret_half', 0.5)];
  });
  var BOOL_TYPE_CODER = new SingleTypeCoder(boolInputPartGetter, BOOL_OUTPUT_PART, 0, WebGLRenderingContext.UNSIGNED_BYTE, function(e) {
    return e;
  }, function(e) {
    return e;
  }, false);
  return {
    get SingleTypeCoder() {
      return SingleTypeCoder;
    },
    get ShaderCoder() {
      return ShaderCoder;
    },
    get ShaderPart() {
      return ShaderPart;
    },
    get BOOL_TYPE_CODER() {
      return BOOL_TYPE_CODER;
    }
  };
});
//# sourceURL=src/webgl/ShaderCoders_Base.js
;$traceurRuntime.registerModule("src/webgl/ShaderCoders_intoBytes.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/ShaderCoders_intoBytes.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/webgl/ShaderCoders_intoBytes.js")).DetailedError;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/webgl/ShaderCoders_intoBytes.js")).WglArg;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/webgl/ShaderCoders_intoBytes.js")).Seq;
  var $__4 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders_Base.js", "src/webgl/ShaderCoders_intoBytes.js")),
      ShaderPart = $__4.ShaderPart,
      SingleTypeCoder = $__4.SingleTypeCoder,
      ShaderCoder = $__4.ShaderCoder,
      BOOL_TYPE_CODER = $__4.BOOL_TYPE_CODER;
  function floatsAsBytes(floats) {
    if (floats instanceof Float64Array) {
      return new Uint8Array(new Float32Array(floats).buffer, 0, floats.length << 2);
    }
    if (floats instanceof Float32Array) {
      return new Uint8Array(floats.buffer, 0, floats.length << 2);
    }
    throw new DetailedError("Not a Float32Array or Float64Array", {
      type: (typeof floats === 'undefined' ? 'undefined' : $traceurRuntime.typeof(floats)),
      floats: floats
    });
  }
  function bytesAsFloats(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      throw new DetailedError("Not a Uint8Array", {
        type: (typeof bytes === 'undefined' ? 'undefined' : $traceurRuntime.typeof(bytes)),
        bytes: bytes
      });
    }
    return new Float32Array(bytes.buffer, 0, bytes.length >> 2);
  }
  var PACK_FLOAT_INTO_BYTES_CODE = "\n    //////////// PACK_FLOAT_INTO_BYTES /////////////\n    vec4 _gen_packFloatIntoBytes(float val) {\n        if (val == 0.0) {\n            // If log2(0) returns -Infinity, then the logic below would work out just right and this IF block\n            // wouldn't be needed. Unfortunately, log2(0) isn't guaranteed to do that (it's undefined by the spec).\n            return vec4(0.0, 0.0, 0.0, 0.0);\n        }\n\n        float mag = abs(val);\n        float exponent = floor(log2(mag));\n        // Correct log2 approximation errors.\n        exponent += float(exp2(exponent) <= mag / 2.0);\n        exponent -= float(exp2(exponent) > mag);\n\n        float mantissa;\n        if (exponent > 100.0) {\n            // Not sure why this needs to be done in two steps for the largest float to work. Best guess is the\n            // optimizer is rewriting '/ exp2(e)' into '* exp2(-e)', but exp2(-128.0) is too small to represent.\n            mantissa = mag / 1024.0 / exp2(exponent - 10.0) - 1.0;\n        } else {\n            mantissa = mag / float(exp2(exponent)) - 1.0;\n        }\n\n        exponent += 127.0;\n        float a = float(val < 0.0) * 128.0 + floor(exponent / 2.0);\n        mantissa *= 128.0;\n        float b = mod(exponent, 2.0) * 128.0 + floor(mantissa);\n        mantissa -= floor(mantissa);\n        mantissa *= 256.0;\n        float c = floor(mantissa);\n        mantissa -= c;\n        mantissa *= 256.0;\n        float d = floor(mantissa);\n\n        return vec4(d, c, b, a) / 255.0;\n    }";
  var UNPACK_BYTES_INTO_FLOAT_CODE = "\n    //////////// UNPACK_BYTES_INTO_FLOAT_CODE /////////////\n    float _gen_unpackBytesIntoFloat(vec4 v) {\n        float d = floor(v.r * 255.0 + 0.5);\n        float c = floor(v.g * 255.0 + 0.5);\n        float b = floor(v.b * 255.0 + 0.5);\n        float a = floor(v.a * 255.0 + 0.5);\n\n        float sign = floor(a / 128.0);\n        sign = 1.0 - sign * 2.0;\n\n        float exponent = mod(a, 128.0) * 2.0 + floor(b / 128.0) - 127.0;\n        float mantissa = float(exponent > -127.0)\n                       + mod(b, 128.0) / 128.0\n                       + c / 32768.0\n                       + d / 8388608.0;\n        return sign * mantissa * exp2(exponent);\n    }";
  function makeByteCoderInput(vecSize, name) {
    var type = ['float', 'vec2', 'vec3', 'vec4'][vecSize - 1];
    var pre = ("_gen_" + name);
    return new ShaderPart(("\n        ///////////// makeByteCoderInput(" + vecSize + ", " + name + ") ////////////\n        uniform sampler2D " + pre + "_tex;\n        uniform vec2 " + pre + "_size;\n\n        " + type + " read_" + name + "(float k) {\n            k *= " + vecSize + ".0;\n            vec2 uv = vec2(mod(k, " + pre + "_size.x) + 0.5,\n                           floor(k / " + pre + "_size.x) + 0.5) / " + pre + "_size;\n\n            " + Seq.range(vecSize).map(function(i) {
      return ("\n                vec2 uv" + i + " = uv + vec2(" + i + ".0 / " + pre + "_size.x, 0.0);\n                vec4 bytes" + i + " = texture2D(" + pre + "_tex, uv" + i + ");");
    }).join('') + "\n\n            return " + type + "(" + Seq.range(vecSize).map(function(i) {
      return ("\n                _gen_unpackBytesIntoFloat(bytes" + i + ")");
    }).join(',') + ");\n        }\n\n        float len_" + name + "() {\n            return " + pre + "_size.x * " + pre + "_size.y / " + vecSize + ".0;\n        }"), [UNPACK_BYTES_INTO_FLOAT_CODE], function(texture) {
      if (texture.pixelType !== WebGLRenderingContext.UNSIGNED_BYTE) {
        throw new DetailedError("vec2Input_Byte requires byte texture", {
          name: name,
          texture: texture
        });
      }
      return [WglArg.texture((pre + "_tex"), texture), WglArg.vec2((pre + "_size"), texture.width, texture.height)];
    });
  }
  function makeByteCoderOutput(vecSize) {
    var type = ['float', 'vec2', 'vec3', 'vec4'][vecSize - 1];
    return new ShaderPart(("\n        ///////////// makeByteCoderOutput" + vecSize + " ////////////\n        " + type + " outputFor(float k);\n\n        uniform vec2 _gen_output_size;\n        uniform float _gen_secret_half;\n\n        float len_output() {\n            return _gen_output_size.x * _gen_output_size.y / " + vecSize + ".0;\n        }\n\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(_gen_secret_half, _gen_secret_half);\n            float k = xy.y * _gen_output_size.x + xy.x;\n            float r = mod(k, " + vecSize + ".0);\n            " + (vecSize === 1 ? 'float component = outputFor(k);' : (type + " result = outputFor(floor(k / " + vecSize + ".0));\n                 " + type + " picker = " + type + "(" + Seq.range(vecSize).map(function(r) {
      return ("float(r == " + r + ".0)");
    }).join(", ") + ");\n                 float component = dot(result, picker);")) + "\n            gl_FragColor = _gen_packFloatIntoBytes(component);\n        }"), [PACK_FLOAT_INTO_BYTES_CODE], function(texture) {
      return [WglArg.vec2('_gen_output_size', texture.width, texture.height), WglArg.float('_gen_secret_half', 0.5)];
    });
  }
  var FLOAT_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeByteCoderInput(1, name);
  }, makeByteCoderOutput(1), 0, WebGLRenderingContext.UNSIGNED_BYTE, floatsAsBytes, bytesAsFloats, false);
  var VEC2_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeByteCoderInput(2, name);
  }, makeByteCoderOutput(2), 1, WebGLRenderingContext.UNSIGNED_BYTE, floatsAsBytes, bytesAsFloats, false);
  var VEC4_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeByteCoderInput(4, name);
  }, makeByteCoderOutput(4), 2, WebGLRenderingContext.UNSIGNED_BYTE, floatsAsBytes, bytesAsFloats, false);
  var SHADER_CODER_BYTES = new ShaderCoder(BOOL_TYPE_CODER, FLOAT_TYPE_CODER, VEC2_TYPE_CODER, VEC4_TYPE_CODER);
  return {
    get SHADER_CODER_BYTES() {
      return SHADER_CODER_BYTES;
    },
    get floatsAsBytes() {
      return floatsAsBytes;
    },
    get bytesAsFloats() {
      return bytesAsFloats;
    },
    get UNPACK_BYTES_INTO_FLOAT_CODE() {
      return UNPACK_BYTES_INTO_FLOAT_CODE;
    },
    get PACK_FLOAT_INTO_BYTES_CODE() {
      return PACK_FLOAT_INTO_BYTES_CODE;
    }
  };
});
//# sourceURL=src/webgl/ShaderCoders_intoBytes.js
;$traceurRuntime.registerModule("src/webgl/ShaderCoders_intoFloats.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/ShaderCoders_intoFloats.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/webgl/ShaderCoders_intoFloats.js")).DetailedError;
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders_Base.js", "src/webgl/ShaderCoders_intoFloats.js")),
      ShaderPart = $__2.ShaderPart,
      SingleTypeCoder = $__2.SingleTypeCoder,
      ShaderCoder = $__2.ShaderCoder,
      BOOL_TYPE_CODER = $__2.BOOL_TYPE_CODER;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/webgl/ShaderCoders_intoFloats.js")).WglArg;
  function makeFloatCoderInput(vecSize, name) {
    var type = ['float', 'vec2', 'vec3', 'vec4'][vecSize - 1];
    var pre = ("_gen_" + name);
    return new ShaderPart(("\n        ///////////// makeFloatCoderInput(" + vecSize + ", " + name + ") ////////////\n        uniform sampler2D " + pre + "_tex;\n        uniform vec2 " + pre + "_size;\n\n        " + type + " read_" + name + "(float k) {\n            vec2 uv = vec2(mod(k, " + pre + "_size.x) + 0.5,\n                           floor(k / " + pre + "_size.x) + 0.5) / " + pre + "_size;\n            return texture2D(" + pre + "_tex, uv)." + 'xyzw'.substring(0, vecSize) + ";\n        }\n\n        float len_" + name + "() {\n            return " + pre + "_size.x * " + pre + "_size.y;\n        }"), [], function(texture) {
      if (texture.pixelType !== WebGLRenderingContext.FLOAT) {
        throw new DetailedError(("vecInput" + vecSize + "_Float requires float texture"), {
          name: name,
          texture: texture
        });
      }
      return [WglArg.texture((pre + "_tex"), texture), WglArg.vec2((pre + "_size"), texture.width, texture.height)];
    });
  }
  function makeFloatCoderOutput(vecSize) {
    var type = ['float', 'vec2', 'vec3', 'vec4'][vecSize - 1];
    var vIntoVec4 = ['vec4(v, 0.0, 0.0, 0.0)', 'vec4(v.x, v.y, 0.0, 0.0)', 'vec4(v.x, v.y, v.z, 0.0)', 'v'][vecSize - 1];
    return new ShaderPart(("\n        ///////////// makeFloatCoderOutput" + vecSize + " ////////////\n        " + type + " outputFor(float k);\n\n        uniform vec2 _gen_output_size;\n        uniform float _gen_secret_half;\n\n        float len_output() {\n            return _gen_output_size.x * _gen_output_size.y;\n        }\n\n        void main() {\n            vec2 xy = gl_FragCoord.xy - vec2(_gen_secret_half, _gen_secret_half);\n            float k = xy.y * _gen_output_size.x + xy.x;\n\n            " + type + " v = outputFor(k);\n\n            gl_FragColor = " + vIntoVec4 + ";\n        }"), [], function(texture) {
      return [WglArg.vec2('_gen_output_size', texture.width, texture.height), WglArg.float('_gen_secret_half', 0.5)];
    });
  }
  function spreadFloatVec1(vec1Data) {
    var result = new Float32Array(vec1Data.length << 2);
    for (var i = 0; i < vec1Data.length; i++) {
      result[4 * i] = vec1Data[i];
    }
    return result;
  }
  function spreadFloatVec2(vec2Data) {
    var result = new Float32Array(vec2Data.length << 1);
    for (var i = 0; i * 2 < vec2Data.length; i++) {
      result[4 * i] = vec2Data[2 * i];
      result[4 * i + 1] = vec2Data[2 * i + 1];
    }
    return result;
  }
  function unspreadFloatVec1(pixelData) {
    var result = new Float32Array(pixelData.length >> 2);
    for (var i = 0; i < result.length; i++) {
      result[i] = pixelData[4 * i];
    }
    return result;
  }
  function unspreadFloatVec2(pixelData) {
    var result = new Float32Array(pixelData.length >> 1);
    for (var i = 0; i * 2 < result.length; i++) {
      result[2 * i] = pixelData[4 * i];
      result[2 * i + 1] = pixelData[4 * i + 1];
    }
    return result;
  }
  var FLOAT_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeFloatCoderInput(1, name);
  }, makeFloatCoderOutput(1), 0, WebGLRenderingContext.FLOAT, spreadFloatVec1, unspreadFloatVec1, true);
  var VEC2_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeFloatCoderInput(2, name);
  }, makeFloatCoderOutput(2), 0, WebGLRenderingContext.FLOAT, spreadFloatVec2, unspreadFloatVec2, true);
  var VEC4_TYPE_CODER = new SingleTypeCoder(function(name) {
    return makeFloatCoderInput(4, name);
  }, makeFloatCoderOutput(4), 0, WebGLRenderingContext.FLOAT, function(e) {
    return e;
  }, function(e) {
    return e;
  }, false);
  var SHADER_CODER_FLOATS = new ShaderCoder(BOOL_TYPE_CODER, FLOAT_TYPE_CODER, VEC2_TYPE_CODER, VEC4_TYPE_CODER);
  return {get SHADER_CODER_FLOATS() {
      return SHADER_CODER_FLOATS;
    }};
});
//# sourceURL=src/webgl/ShaderCoders_intoFloats.js
;$traceurRuntime.registerModule("src/webgl/ShaderCoders.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/ShaderCoders.js";
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/webgl/ShaderCoders.js")).WglArg;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglShader.js", "src/webgl/ShaderCoders.js")).WglShader;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexture.js", "src/webgl/ShaderCoders.js")).WglTexture;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglContext.js", "src/webgl/ShaderCoders.js")).initializedWglContext;
  var $__24 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/webgl/ShaderCoders.js")),
      provideWorkingShaderCoderToWglConfiguredShader = $__24.provideWorkingShaderCoderToWglConfiguredShader,
      WglConfiguredShader = $__24.WglConfiguredShader;
  var ShaderPart = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders_Base.js", "src/webgl/ShaderCoders.js")).ShaderPart;
  var SHADER_CODER_BYTES = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders_intoBytes.js", "src/webgl/ShaderCoders.js")).SHADER_CODER_BYTES;
  var SHADER_CODER_FLOATS = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders_intoFloats.js", "src/webgl/ShaderCoders.js")).SHADER_CODER_FLOATS;
  var ShaderPartDescription = function() {
    function ShaderPartDescription(partMaker, description) {
      this._partMaker = partMaker;
      this.description = description;
    }
    return ($traceurRuntime.createClass)(ShaderPartDescription, {
      toConcretePart: function() {
        var coder = arguments[0];
        return this._partMaker(coder || currentShaderCoder());
      },
      toString: function() {
        return ("ShaderPartDescription(" + this.description + ")");
      }
    }, {});
  }();
  var Inputs = function() {
    function Inputs() {}
    return ($traceurRuntime.createClass)(Inputs, {}, {
      bool: function(name) {
        return new ShaderPartDescription(function(coder) {
          return coder.bool.inputPartGetter(name);
        }, ("Inputs.bool(" + name + ")"));
      },
      float: function(name) {
        return new ShaderPartDescription(function(coder) {
          return coder.float.inputPartGetter(name);
        }, ("Inputs.float(" + name + ")"));
      },
      vec2: function(name) {
        return new ShaderPartDescription(function(coder) {
          return coder.vec2.inputPartGetter(name);
        }, ("Inputs.vec2(" + name + ")"));
      },
      vec4: function(name) {
        return new ShaderPartDescription(function(coder) {
          return coder.vec4.inputPartGetter(name);
        }, ("Inputs.vec4(" + name + ")"));
      }
    });
  }();
  var Outputs = function() {
    function Outputs() {}
    return ($traceurRuntime.createClass)(Outputs, {}, {
      bool: function() {
        return new ShaderPartDescription(function(coder) {
          return coder.bool.outputPart;
        }, "Outputs.bool()");
      },
      float: function() {
        return new ShaderPartDescription(function(coder) {
          return coder.float.outputPart;
        }, "Outputs.float()");
      },
      vec2: function() {
        return new ShaderPartDescription(function(coder) {
          return coder.vec2.outputPart;
        }, "Outputs.vec2()");
      },
      vec4: function() {
        return new ShaderPartDescription(function(coder) {
          return coder.vec4.outputPart;
        }, "Outputs.vec4()");
      },
      vec4WithOutputCoder: function() {
        return new ShaderPartDescription(function(_) {
          return outputShaderCoder().vec4.outputPart;
        }, "Outputs.vec4WithOutputCoder()");
      }
    });
  }();
  function combinedShaderPartsWithCode(shaderPartsOrDescs, bodyCode) {
    var shaderPartDescs = shaderPartsOrDescs.map(function(partOrDesc) {
      return partOrDesc instanceof ShaderPart ? new ShaderPartDescription(function(_) {
        return partOrDesc;
      }, 'fixed') : partOrDesc;
    });
    var sourceMaker = function() {
      var libs = new Set();
      var $__13 = true;
      var $__14 = false;
      var $__15 = undefined;
      try {
        for (var $__11 = void 0,
            $__10 = (shaderPartDescs)[Symbol.iterator](); !($__13 = ($__11 = $__10.next()).done); $__13 = true) {
          var part = $__11.value;
          {
            var $__6 = true;
            var $__7 = false;
            var $__8 = undefined;
            try {
              for (var $__4 = void 0,
                  $__3 = (part.toConcretePart().libs)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
                var lib = $__4.value;
                {
                  libs.add(lib);
                }
              }
            } catch ($__9) {
              $__7 = true;
              $__8 = $__9;
            } finally {
              try {
                if (!$__6 && $__3.return != null) {
                  $__3.return();
                }
              } finally {
                if ($__7) {
                  throw $__8;
                }
              }
            }
          }
        }
      } catch ($__16) {
        $__14 = true;
        $__15 = $__16;
      } finally {
        try {
          if (!$__13 && $__10.return != null) {
            $__10.return();
          }
        } finally {
          if ($__14) {
            throw $__15;
          }
        }
      }
      var libCode = $traceurRuntime.spread(libs, shaderPartDescs.map(function(e) {
        return e.toConcretePart().code;
      })).join('');
      var afterLibCode = '\n//////// body ////////\n' + bodyCode + '\n';
      var mainIndex = libCode.indexOf('void main()');
      if (mainIndex !== -1) {
        return libCode.substring(0, mainIndex) + afterLibCode + libCode.substring(mainIndex);
      }
      return libCode + afterLibCode;
    };
    return new WglShader(sourceMaker);
  }
  function makePseudoShaderWithInputsAndOutputAndCode(inputs, output, bodyCode) {
    var shader = combinedShaderPartsWithCode($traceurRuntime.spread(inputs, [output]), bodyCode);
    return function() {
      var $__18,
          $__19;
      for (var inputsAndArgs = [],
          $__17 = 0; $__17 < arguments.length; $__17++)
        inputsAndArgs[$__17] = arguments[$__17];
      var args = [];
      for (var i = 0; i < inputs.length; i++) {
        ($__18 = args).push.apply($__18, $traceurRuntime.spread(inputs[i].toConcretePart().argsFor(inputsAndArgs[i])));
      }
      ($__19 = args).push.apply($__19, $traceurRuntime.spread(inputsAndArgs.slice(inputs.length)));
      return shaderWithOutputPartAndArgs(shader, output.toConcretePart(), args);
    };
  }
  function shaderWithOutputPartAndArgs(shader, outputShaderPart, args) {
    return new WglConfiguredShader(function(destinationTexture) {
      var $__18;
      return ($__18 = shader).withArgs.apply($__18, $traceurRuntime.spread(args, outputShaderPart.argsFor(destinationTexture))).renderTo(destinationTexture);
    });
  }
  var _curShaderCoder = SHADER_CODER_FLOATS;
  var _outShaderCoder = SHADER_CODER_BYTES;
  function currentShaderCoder() {
    return _curShaderCoder;
  }
  function outputShaderCoder() {
    return _outShaderCoder;
  }
  function changeShaderCoder(newCoder) {
    try {
      initializedWglContext().invalidateExistingResources();
    } catch (_) {}
    _curShaderCoder = newCoder;
    _outShaderCoder = newCoder;
  }
  function _tryWriteAndReadFloatingPointTexture() {
    var texture = new WglTexture(1, 1, WebGLRenderingContext.FLOAT);
    var shader = new WglShader("void main() { gl_FragColor = vec4(2.0, 3.5, 7.0, -7654321.0); }");
    try {
      shader.withArgs().renderTo(texture);
      var result = texture.readPixels(false);
      return result instanceof Float32Array && result.length === 4 && result[0] === 2 && result[1] === 3.5 && result[2] === 7 && result[3] === -7654321;
    } catch (ex) {
      console.warn(ex);
      return false;
    } finally {
      texture.ensureDeinitialized();
      shader.ensureDeinitialized();
    }
  }
  function _tryWriteAndPassFloatingPointWithByteReadTexture() {
    var textureFloat = new WglTexture(1, 1, WebGLRenderingContext.FLOAT);
    var textureByte = new WglTexture(1, 1, WebGLRenderingContext.UNSIGNED_BYTE);
    var shader = new WglShader("void main() { gl_FragColor = vec4(1.1, 3.0, 5.0, -7654321.0); }");
    var passer = new WglShader("uniform sampler2D t; void main() {\n        vec4 v = texture2D(t, gl_FragCoord.xy);\n        if (v == vec4(2.0, 3.0, 5.0, -7654321.0)) { // Testing that expected precision is present.\n            gl_FragColor = vec4(2.0, 3.0, 5.0, 254.0) / 255.0;\n        } else {\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n    }");
    try {
      shader.withArgs().renderTo(textureFloat);
      passer.withArgs(WglArg.texture('t', textureFloat)).renderTo(textureByte);
      var result = textureByte.readPixels(false);
      return result instanceof Uint8Array && result.length === 4 && result[0] === 2 && result[1] === 3 && result[2] === 5 && result[3] === 254;
    } catch (ex) {
      console.warn(ex);
      return false;
    } finally {
      textureFloat.ensureDeinitialized();
      textureByte.ensureDeinitialized();
      shader.ensureDeinitialized();
      passer.ensureDeinitialized();
    }
  }
  function _chooseShaderCoders() {
    if (_tryWriteAndReadFloatingPointTexture()) {
      _curShaderCoder = SHADER_CODER_FLOATS;
      _outShaderCoder = SHADER_CODER_FLOATS;
    } else if (_tryWriteAndPassFloatingPointWithByteReadTexture()) {
      console.warn("Wrote but failed to read a floating point texture. Falling back to float-as-byte output coding.");
      _curShaderCoder = SHADER_CODER_FLOATS;
      _outShaderCoder = SHADER_CODER_BYTES;
    } else {
      console.warn("Failed to write a floating point texture. Falling back to float-as-byte coding everywhere.");
      _curShaderCoder = SHADER_CODER_BYTES;
      _outShaderCoder = SHADER_CODER_BYTES;
    }
  }
  var _floatShadersWorkWell = undefined;
  function canTestFloatShaders() {
    if (_floatShadersWorkWell === undefined) {
      _floatShadersWorkWell = _tryWriteAndReadFloatingPointTexture();
    }
    return _floatShadersWorkWell;
  }
  _chooseShaderCoders();
  provideWorkingShaderCoderToWglConfiguredShader(currentShaderCoder);
  return {
    get combinedShaderPartsWithCode() {
      return combinedShaderPartsWithCode;
    },
    get shaderWithOutputPartAndArgs() {
      return shaderWithOutputPartAndArgs;
    },
    get currentShaderCoder() {
      return currentShaderCoder;
    },
    get makePseudoShaderWithInputsAndOutputAndCode() {
      return makePseudoShaderWithInputsAndOutputAndCode;
    },
    get changeShaderCoder() {
      return changeShaderCoder;
    },
    get Inputs() {
      return Inputs;
    },
    get Outputs() {
      return Outputs;
    },
    get outputShaderCoder() {
      return outputShaderCoder;
    },
    get canTestFloatShaders() {
      return canTestFloatShaders;
    }
  };
});
//# sourceURL=src/webgl/ShaderCoders.js
;$traceurRuntime.registerModule("src/webgl/Shaders.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/Shaders.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/webgl/Shaders.js")).DetailedError;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/webgl/Shaders.js")).WglArg;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglContext.js", "src/webgl/Shaders.js")).initializedWglContext;
  var WglShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglShader.js", "src/webgl/Shaders.js")).WglShader;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/webgl/Shaders.js")).WglConfiguredShader;
  var $__10 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/webgl/Shaders.js")),
      currentShaderCoder = $__10.currentShaderCoder,
      Inputs = $__10.Inputs,
      Outputs = $__10.Outputs,
      makePseudoShaderWithInputsAndOutputAndCode = $__10.makePseudoShaderWithInputsAndOutputAndCode;
  var Shaders = function() {
    function Shaders() {}
    return ($traceurRuntime.createClass)(Shaders, {}, {});
  }();
  Shaders.color = function(r, g, b, a) {
    return COLOR_SHADER.withArgs(WglArg.vec4("color", r, g, b, a));
  };
  var COLOR_SHADER = new WglShader("\n    uniform vec4 color;\n    void main() {\n        gl_FragColor = color;\n    }");
  Shaders.passthrough = function(inp) {
    return new WglConfiguredShader(function(dst) {
      if (dst.width !== inp.width || dst.height !== inp.height || dst.pixelType !== inp.pixelType) {
        throw new DetailedError("Expected same-shaped textures.", {
          inp: inp,
          dst: dst
        });
      }
      PASSTHROUGH_SHADER.withArgs(WglArg.vec2("textureSize", inp.width, inp.height), WglArg.texture("dataTexture", inp)).renderTo(dst);
    });
  };
  var PASSTHROUGH_SHADER = new WglShader("\n    uniform vec2 textureSize;\n    uniform sampler2D dataTexture;\n    void main() {\n        gl_FragColor = texture2D(dataTexture, gl_FragCoord.xy / textureSize.xy);\n    }");
  Shaders.data = function(rgbaData) {
    return new WglConfiguredShader(function(destinationTexture) {
      var $__3,
          $__4;
      var $__2 = [destinationTexture.width, destinationTexture.height],
          w = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
          h = ($__4 = $__3.next()).done ? void 0 : $__4.value;
      if (rgbaData.length !== w * h * 4) {
        throw new DetailedError("rgbaData.length isn't w * h * 4", {
          w: w,
          h: h,
          len: rgbaData.length,
          rgbaData: rgbaData
        });
      }
      var GL = WebGLRenderingContext;
      var gl = initializedWglContext().gl;
      var dataTexture = gl.createTexture();
      try {
        gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, dataTexture);
        gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
        gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
        gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, w, h, 0, GL.RGBA, rgbaData instanceof Uint8Array ? GL.UNSIGNED_BYTE : GL.FLOAT, rgbaData);
        PASSTHROUGH_SHADER.withArgs(WglArg.vec2("textureSize", w, h), WglArg.webGlTexture("dataTexture", dataTexture)).renderTo(destinationTexture);
      } finally {
        gl.deleteTexture(dataTexture);
      }
    });
  };
  Shaders.vec2Data = function(floats) {
    return Shaders.data(currentShaderCoder().vec2.dataToPixels(floats));
  };
  Shaders.vec4Data = function(floats) {
    return Shaders.data(currentShaderCoder().vec4.dataToPixels(floats));
  };
  Shaders.packFloatIntoVec4 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('input')], Outputs.vec4(), "vec4 outputFor(float k) {\n        return vec4(\n            read_input(k*4.0),\n            read_input(k*4.0 + 1.0),\n            read_input(k*4.0 + 2.0),\n            read_input(k*4.0 + 3.0));\n    }");
  Shaders.packVec2IntoVec4 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec4(), 'vec4 outputFor(float k) { return vec4(read_input(k*2.0), read_input(k*2.0 + 1.0)); }');
  Shaders.sumFoldFloat = makePseudoShaderWithInputsAndOutputAndCode([Inputs.float('input')], Outputs.float(), "float outputFor(float k) {\n         return read_input(k) + read_input(k + len_output());\n     }");
  Shaders.sumFoldVec2 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec2('input')], Outputs.vec2(), "vec2 outputFor(float k) {\n         return read_input(k) + read_input(k + len_output());\n     }");
  Shaders.sumFoldVec4 = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4(), "vec4 outputFor(float k) {\n        return read_input(k) + read_input(k + len_output());\n    }");
  Shaders.convertVec4CodingForOutput = makePseudoShaderWithInputsAndOutputAndCode([Inputs.vec4('input')], Outputs.vec4WithOutputCoder(), 'vec4 outputFor(float k) { return read_input(k); }');
  return {get Shaders() {
      return Shaders;
    }};
});
//# sourceURL=src/webgl/Shaders.js
;$traceurRuntime.registerModule("src/webgl/WglArg.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglArg.js";
  var WglArg = function() {
    function WglArg(type, name, value) {
      this.type = type;
      this.name = name;
      this.value = value;
    }
    return ($traceurRuntime.createClass)(WglArg, {toString: function() {
        return (this.type + " " + this.name + " = " + JSON.stringify(this.value));
      }}, {
      bool: function(name, value) {
        return new WglArg(WglArg.BOOL_TYPE, name, value);
      },
      float: function(name, value) {
        return new WglArg(WglArg.FLOAT_TYPE, name, value);
      },
      int: function(name, value) {
        return new WglArg(WglArg.INT_TYPE, name, value);
      },
      vec2: function(name, x, y) {
        return new WglArg(WglArg.VEC2_TYPE, name, [x, y]);
      },
      float_array: function(name, buf) {
        if (buf instanceof Float64Array) {
          buf = new Float32Array(buf);
        }
        return new WglArg(WglArg.FLOAT_ARRAY_TYPE, name, buf);
      },
      vec2_array: function(name, buf) {
        if (buf instanceof Float64Array) {
          buf = new Float32Array(buf);
        }
        return new WglArg(WglArg.VEC2_ARRAY_TYPE, name, buf);
      },
      vec4_array: function(name, buf) {
        if (buf instanceof Float64Array) {
          buf = new Float32Array(buf);
        }
        return new WglArg(WglArg.VEC4_ARRAY_TYPE, name, buf);
      },
      mat4_array: function(name, buf) {
        if (buf instanceof Float64Array) {
          buf = new Float32Array(buf);
        }
        return new WglArg(WglArg.MAT4_ARRAY_TYPE, name, buf);
      },
      vec4: function(name, x, y, z, t) {
        return new WglArg(WglArg.VEC4_TYPE, name, [x, y, z, t]);
      },
      mat4: function(name, cellsRowByRow) {
        return new WglArg(WglArg.MAT4_TYPE, name, cellsRowByRow);
      },
      texture: function(name, wglTexture) {
        return new WglArg(WglArg.WGL_TEXTURE_TYPE, name, wglTexture);
      },
      webGlTexture: function(name, webGlTexture) {
        return new WglArg(WglArg.WEB_GL_TEXTURE_TYPE, name, webGlTexture);
      }
    });
  }();
  WglArg.BOOL_TYPE = "bool";
  WglArg.FLOAT_TYPE = "float";
  WglArg.INT_TYPE = "int";
  WglArg.VEC2_TYPE = "vec2";
  WglArg.FLOAT_ARRAY_TYPE = "float[]";
  WglArg.VEC2_ARRAY_TYPE = "vec2[]";
  WglArg.VEC4_ARRAY_TYPE = "vec4[]";
  WglArg.MAT4_ARRAY_TYPE = "mat4[]";
  WglArg.VEC4_TYPE = "vec4";
  WglArg.MAT4_TYPE = "mat4";
  WglArg.WGL_TEXTURE_TYPE = "wgl_texture";
  WglArg.WEB_GL_TEXTURE_TYPE = "web_gl_texture";
  WglArg.INPUT_ACTION_MAP = new Map([[WglArg.BOOL_TYPE, function(ctx, loc, val) {
    return ctx.gl.uniform1f(loc, val ? 1 : 0);
  }], [WglArg.INT_TYPE, function(ctx, loc, val) {
    return ctx.gl.uniform1i(loc, val);
  }], [WglArg.FLOAT_TYPE, function(ctx, loc, val) {
    return ctx.gl.uniform1f(loc, val);
  }], [WglArg.VEC2_TYPE, function(ctx, loc, $__1) {
    var $__3,
        $__4;
    var $__2 = $__1,
        x = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
        y = ($__4 = $__3.next()).done ? void 0 : $__4.value;
    return ctx.gl.uniform2f(loc, x, y);
  }], [WglArg.FLOAT_ARRAY_TYPE, function(ctx, loc, buf) {
    return ctx.gl.uniform1fv(loc, buf);
  }], [WglArg.VEC2_ARRAY_TYPE, function(ctx, loc, buf) {
    return ctx.gl.uniform2fv(loc, buf);
  }], [WglArg.VEC4_ARRAY_TYPE, function(ctx, loc, buf) {
    return ctx.gl.uniform4fv(loc, buf);
  }], [WglArg.MAT4_ARRAY_TYPE, function(ctx, loc, buf) {
    return ctx.gl.uniformMatrix4fv(loc, false, buf);
  }], [WglArg.VEC4_TYPE, function(ctx, loc, $__1) {
    var $__3,
        $__4;
    var $__2 = $__1,
        r = ($__3 = $__2[Symbol.iterator](), ($__4 = $__3.next()).done ? void 0 : $__4.value),
        g = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        b = ($__4 = $__3.next()).done ? void 0 : $__4.value,
        a = ($__4 = $__3.next()).done ? void 0 : $__4.value;
    return ctx.gl.uniform4f(loc, r, g, b, a);
  }], [WglArg.MAT4_TYPE, function(ctx, loc, val) {
    return ctx.gl.uniformMatrix4fv(loc, false, val);
  }], [WglArg.WGL_TEXTURE_TYPE, function(ctx, loc, texture, coop) {
    var unit = coop.coopTextureUnit++;
    if (unit >= ctx.maxTextureUnits) {
      throw new Error(("Uniform texture argument uses texture unit " + unit + " but max ") + ("is " + ctx.maxTextureUnits + "."));
    }
    if (texture.width > ctx.maxTextureSize || texture.height > ctx.maxTextureSize) {
      throw new Error(("Uniform texture argument is " + texture.width + "x" + texture.height + ", but max ") + ("texture diameter is " + ctx.maxTextureSize + "."));
    }
    var gl = ctx.gl;
    gl.uniform1i(loc, unit);
    gl.activeTexture(WebGLRenderingContext.TEXTURE0 + unit);
    gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, texture.initializedTexture());
  }], [WglArg.WEB_GL_TEXTURE_TYPE, function(ctx, loc, texture, coop) {
    var unit = coop.coopTextureUnit++;
    if (unit >= ctx.maxTextureUnits) {
      throw new Error(("Uniform texture argument uses texture unit " + unit + " but max ") + ("is " + ctx.maxTextureUnits + "."));
    }
    var gl = ctx.gl;
    gl.uniform1i(loc, unit);
    gl.activeTexture(WebGLRenderingContext.TEXTURE0 + unit);
    gl.bindTexture(WebGLRenderingContext.TEXTURE_2D, texture);
  }]]);
  return {get WglArg() {
      return WglArg;
    }};
});
//# sourceURL=src/webgl/WglArg.js
;$traceurRuntime.registerModule("src/webgl/WglConfiguredShader.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglConfiguredShader.js";
  var Matrix = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/math/Matrix.js", "src/webgl/WglConfiguredShader.js")).Matrix;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexture.js", "src/webgl/WglConfiguredShader.js")).WglTexture;
  var currentShaderCoder = undefined;
  var WglTexturePool;
  function provideWorkingShaderCoderToWglConfiguredShader(newCurrentShaderCoder) {
    currentShaderCoder = newCurrentShaderCoder;
  }
  function provideWglTexturePoolToWglConfiguredShader(pool) {
    WglTexturePool = pool;
  }
  var WglConfiguredShader = function() {
    function WglConfiguredShader(renderToFunc) {
      this.renderToFunc = renderToFunc;
    }
    return ($traceurRuntime.createClass)(WglConfiguredShader, {
      renderTo: function(texture) {
        var shouldBeUndefined = this.renderToFunc(texture);
        if (shouldBeUndefined instanceof WglConfiguredShader) {
          throw new Error("Returned a WglConfiguredShader instead of calling renderTo on it.");
        }
      },
      _renderToElseDealloc: function(texture) {
        var didPass = false;
        try {
          this.renderTo(texture);
          didPass = true;
        } finally {
          if (!didPass) {
            texture.deallocByDepositingInPool("_renderToElseDealloc");
          }
        }
      },
      _renderReadDealloc: function(texture) {
        try {
          this.renderTo(texture);
          return texture.readPixels();
        } finally {
          texture.deallocByDepositingInPool();
        }
      },
      toRawByteTexture: function(sizePower) {
        var texture = WglTexturePool.takeRawByteTex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      toRawFloatTexture: function(sizePower) {
        var texture = WglTexturePool.takeRawFloatTex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      readRawFloatOutputs: function(sizePower) {
        return this._renderReadDealloc(WglTexturePool.takeRawFloatTex(sizePower));
      },
      readRawByteOutputs: function(sizePower) {
        return this._renderReadDealloc(WglTexturePool.takeRawByteTex(sizePower));
      },
      readBoolOutputs: function(sizePower) {
        var pixels = this._renderReadDealloc(WglTexturePool.takeBoolTex(sizePower));
        var result = new Uint8Array(pixels.length >> 2);
        for (var i = 0; i < result.length; i++) {
          result[i] = pixels[i << 2] & 1;
        }
        return result;
      },
      readVecFloatOutputs: function(sizePower) {
        return currentShaderCoder().float.pixelsToData(this._renderReadDealloc(WglTexturePool.takeVecFloatTex(sizePower)));
      },
      readVec2Outputs: function(sizePower) {
        return currentShaderCoder().vec2.pixelsToData(this._renderReadDealloc(WglTexturePool.takeVec2Tex(sizePower)));
      },
      readVec2OutputsAsKet: function(sizePower) {
        return new Matrix(1, 1 << sizePower, this.readVec2Outputs(sizePower));
      },
      readVec4Outputs: function(sizePower) {
        return currentShaderCoder().vec4.pixelsToData(this._renderReadDealloc(WglTexturePool.takeVec4Tex(sizePower)));
      },
      toVecFloatTexture: function(sizePower) {
        var texture = WglTexturePool.takeVecFloatTex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      toVec2Texture: function(sizePower) {
        var texture = WglTexturePool.takeVec2Tex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      toVec4Texture: function(sizePower) {
        var texture = WglTexturePool.takeVec4Tex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      },
      toBoolTexture: function(sizePower) {
        var texture = WglTexturePool.takeBoolTex(sizePower);
        this._renderToElseDealloc(texture);
        return texture;
      }
    }, {});
  }();
  return {
    get WglConfiguredShader() {
      return WglConfiguredShader;
    },
    get provideWorkingShaderCoderToWglConfiguredShader() {
      return provideWorkingShaderCoderToWglConfiguredShader;
    },
    get provideWglTexturePoolToWglConfiguredShader() {
      return provideWglTexturePoolToWglConfiguredShader;
    }
  };
});
//# sourceURL=src/webgl/WglConfiguredShader.js
;$traceurRuntime.registerModule("src/webgl/WglContext.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglContext.js";
  var $__2 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/issues.js", "src/webgl/WglContext.js")),
      canvasCreatedForTesting = $__2.canvasCreatedForTesting,
      webglContextCreatedForTesting = $__2.webglContextCreatedForTesting;
  var WglContext = function() {
    function WglContext() {
      var canvas = arguments[0];
      var context = arguments[1];
      var $__1 = this;
      if (canvas === undefined) {
        canvas = document.createElement('canvas');
        context = undefined;
      }
      if (context === undefined) {
        context = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
      }
      this.canvas = canvas;
      this.gl = context;
      if ((this.gl) === null) {
        throw new Error('Error creating WebGL context.');
      }
      if (this.gl.getExtension('OES_texture_float') === undefined) {
        console.warn("OES_texture_float webgl extension not present.");
      }
      if (this.gl.getExtension('WEBGL_color_buffer_float') === undefined) {
        console.warn("WEBGL_color_buffer_float webgl extension not present.");
      }
      this.onContextRestored = undefined;
      this.lifetimeCounter = 0;
      this.canvas.addEventListener("webglcontextrestored", function(event) {
        event.preventDefault();
        $__1.recomputeProperties();
        if ($__1.onContextRestored !== undefined) {
          $__1.onContextRestored();
        }
      }, false);
      this.canvas.addEventListener('webglcontextlost', function(event) {
        event.preventDefault();
        $__1.lifetimeCounter++;
      }, false);
      this.recomputeProperties();
    }
    return ($traceurRuntime.createClass)(WglContext, {
      invalidateExistingResources: function() {
        this.lifetimeCounter++;
      },
      recomputeProperties: function() {
        this.lifetimeCounter++;
        this.maxTextureUnits = this.gl.getParameter(WebGLRenderingContext.MAX_TEXTURE_IMAGE_UNITS);
        this.maxTextureSize = this.gl.getParameter(WebGLRenderingContext.MAX_TEXTURE_SIZE);
        this.maximumShaderFloatPrecision = this._getMaximumShaderFloatPrecision();
      },
      _getMaximumShaderFloatPrecision: function() {
        var gl = this.gl;
        var GL = WebGLRenderingContext;
        var check = function(shaderType, precisionType) {
          var format = gl.getShaderPrecisionFormat(shaderType, precisionType);
          return gl.getError() === GL.NO_ERROR && format !== undefined && format !== null && format.precision > 0;
        };
        var hasHighPrecision = check(GL.VERTEX_SHADER, GL.HIGH_FLOAT) && check(GL.FRAGMENT_SHADER, GL.HIGH_FLOAT);
        if (hasHighPrecision) {
          return 'highp';
        }
        console.warn('WebGL high precision not available.');
        var hasMediumPrecision = check(GL.VERTEX_SHADER, GL.MEDIUM_FLOAT) && check(GL.FRAGMENT_SHADER, GL.MEDIUM_FLOAT);
        if (hasMediumPrecision) {
          return 'mediump';
        }
        console.warn('WebGL medium precision not available.');
        return 'lowp';
      }
    }, {});
  }();
  var __sharedInstance = undefined;
  function initializedWglContext() {
    if (__sharedInstance === undefined) {
      __sharedInstance = new WglContext(canvasCreatedForTesting, webglContextCreatedForTesting);
    }
    return __sharedInstance;
  }
  return {get initializedWglContext() {
      return initializedWglContext;
    }};
});
//# sourceURL=src/webgl/WglContext.js
;$traceurRuntime.registerModule("src/webgl/WglMortalValueSlot.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglMortalValueSlot.js";
  var WglMortalValueSlot = function() {
    function WglMortalValueSlot(initializer, deinitializer) {
      this.initializer = initializer;
      this.deinitializer = deinitializer;
      this.lifetimeId = undefined;
      this.mortalValue = undefined;
    }
    return ($traceurRuntime.createClass)(WglMortalValueSlot, {
      initializedValue: function(lifetimeCounter) {
        if (this.lifetimeId !== lifetimeCounter) {
          this.ensureDeinitialized();
          this.mortalValue = this.initializer();
          this.lifetimeId = lifetimeCounter;
        }
        return this.mortalValue;
      },
      ensureInitialized: function(lifetimeCounter) {
        this.initializedValue(lifetimeCounter);
      },
      ensureDeinitialized: function() {
        if (this.lifetimeId !== undefined) {
          var val = this.mortalValue;
          this.lifetimeId = undefined;
          this.mortalValue = undefined;
          this.deinitializer(val);
        }
      }
    }, {});
  }();
  return {get WglMortalValueSlot() {
      return WglMortalValueSlot;
    }};
});
//# sourceURL=src/webgl/WglMortalValueSlot.js
;$traceurRuntime.registerModule("src/webgl/WglShader.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglShader.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/webgl/WglShader.js")).Config;
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/webgl/WglShader.js")).DetailedError;
  var WglArg = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglArg.js", "src/webgl/WglShader.js")).WglArg;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglContext.js", "src/webgl/WglShader.js")).initializedWglContext;
  var WglMortalValueSlot = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglMortalValueSlot.js", "src/webgl/WglShader.js")).WglMortalValueSlot;
  var $__16 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglUtil.js", "src/webgl/WglShader.js")),
      checkGetErrorResult = $__16.checkGetErrorResult,
      checkFrameBufferStatusResult = $__16.checkFrameBufferStatusResult;
  var Seq = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Seq.js", "src/webgl/WglShader.js")).Seq;
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/webgl/WglShader.js")).WglConfiguredShader;
  var ENSURE_ATTRIBUTES_BOUND_SLOT = new WglMortalValueSlot(function() {
    var GL = WebGLRenderingContext;
    var gl = initializedWglContext().gl;
    var positionBuffer = gl.createBuffer();
    var positions = new Float32Array([-1, +1, +1, +1, -1, -1, +1, -1]);
    gl.bindBuffer(GL.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(GL.ARRAY_BUFFER, positions, GL.STATIC_DRAW);
    var indexBuffer = gl.createBuffer();
    var indices = new Uint16Array([0, 2, 1, 2, 3, 1]);
    gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(GL.ELEMENT_ARRAY_BUFFER, indices, GL.STATIC_DRAW);
    return {
      positionBuffer: positionBuffer,
      indexBuffer: indexBuffer
    };
  }, function() {});
  var WglShader = function() {
    function WglShader(fragmentShaderSourceGenerator) {
      if (typeof fragmentShaderSourceGenerator === 'string') {
        var fixedSource = fragmentShaderSourceGenerator;
        fragmentShaderSourceGenerator = function() {
          return fixedSource;
        };
      }
      this.fragmentShaderSourceGenerator = fragmentShaderSourceGenerator;
      this._compiledShaderSlot = undefined;
    }
    return ($traceurRuntime.createClass)(WglShader, {
      withArgs: function() {
        for (var uniformArguments = [],
            $__10 = 0; $__10 < arguments.length; $__10++)
          uniformArguments[$__10] = arguments[$__10];
        var $__2 = this;
        if (this._compiledShaderSlot === undefined) {
          var parameterNames = uniformArguments.map(function(e) {
            return e.name;
          });
          this._compiledShaderSlot = new WglMortalValueSlot(function() {
            return new WglCompiledShader($__2.fragmentShaderSourceGenerator(), parameterNames);
          }, function(compiledShader) {
            return compiledShader.free();
          });
        }
        return new WglConfiguredShader(function(texture) {
          if (texture.width === 0 || texture.height === 0) {
            return;
          }
          var GL = WebGLRenderingContext;
          var ctx = initializedWglContext();
          var gl = ctx.gl;
          ENSURE_ATTRIBUTES_BOUND_SLOT.ensureInitialized(ctx.lifetimeCounter);
          gl.bindFramebuffer(GL.FRAMEBUFFER, texture.initializedFramebuffer());
          checkGetErrorResult(gl, "framebufferTexture2D", true);
          checkFrameBufferStatusResult(gl, true);
          $__2._compiledShaderSlot.initializedValue(ctx.lifetimeCounter).useWithArgs(uniformArguments);
          gl.viewport(0, 0, texture.width, texture.height);
          gl.drawElements(GL.TRIANGLES, 6, GL.UNSIGNED_SHORT, 0);
          checkGetErrorResult(gl, "drawElements", true);
          texture.markRendered();
        });
      },
      ensureDeinitialized: function() {
        if (this._compiledShaderSlot !== undefined) {
          this._compiledShaderSlot.ensureDeinitialized();
        }
      },
      toString: function() {
        return ("WglShader(fragmentShaderSource: " + this.fragmentShaderSourceGenerator() + ")");
      }
    }, {});
  }();
  var WglCompiledShader = function() {
    function WglCompiledShader(fragmentShaderSource, uniformParameterNames) {
      var ctx = initializedWglContext();
      var precision = ctx.maximumShaderFloatPrecision;
      var vertexShader = ("\n            precision " + precision + " float;\n            precision " + precision + " int;\n            attribute vec2 position;\n            void main() {\n              gl_Position = vec4(position, 0, 1);\n            }");
      var fullFragmentShader = ("\n            precision " + precision + " float;\n            precision " + precision + " int;\n            " + fragmentShaderSource);
      var GL = WebGLRenderingContext;
      var gl = ctx.gl;
      var glVertexShader = WglCompiledShader.compileShader(gl, GL.VERTEX_SHADER, vertexShader);
      var glFragmentShader = WglCompiledShader.compileShader(gl, GL.FRAGMENT_SHADER, fullFragmentShader);
      var program = gl.createProgram();
      gl.attachShader(program, glVertexShader);
      gl.attachShader(program, glFragmentShader);
      gl.linkProgram(program);
      var warnings = gl.getProgramInfoLog(program).trim();
      if (warnings !== '' && warnings !== '\0' && Config.SUPPRESSED_GLSL_WARNING_PATTERNS.every(function(e) {
        return !e.test(warnings);
      })) {
        console.warn('Shader compile caused warnings', 'gl.getProgramInfoLog()', warnings);
      }
      if (gl.getProgramParameter(program, GL.LINK_STATUS) === false) {
        throw new Error("Failed to link shader program." + "\n" + "\n" + ("gl.VALIDATE_STATUS: " + gl.getProgramParameter(program, GL.VALIDATE_STATUS)) + "\n" + ("gl.getError(): " + gl.getError()));
      }
      gl.deleteShader(glVertexShader);
      gl.deleteShader(glFragmentShader);
      this.uniformLocations = new Seq(uniformParameterNames).toMap(function(e) {
        return e;
      }, function(e) {
        return gl.getUniformLocation(program, e);
      });
      this.positionAttributeLocation = gl.getAttribLocation(program, 'position');
      this.program = program;
    }
    return ($traceurRuntime.createClass)(WglCompiledShader, {
      useWithArgs: function(uniformArgs) {
        var ctx = initializedWglContext();
        var gl = ctx.gl;
        gl.useProgram(this.program);
        var coop = {coopTextureUnit: 0};
        var $__6 = true;
        var $__7 = false;
        var $__8 = undefined;
        try {
          for (var $__4 = void 0,
              $__3 = (uniformArgs)[Symbol.iterator](); !($__6 = ($__4 = $__3.next()).done); $__6 = true) {
            var arg = $__4.value;
            {
              var location = this.uniformLocations.get(arg.name);
              if (location === undefined) {
                throw new DetailedError("Unexpected uniform argument", {
                  arg: arg,
                  uniformArgs: uniformArgs
                });
              }
              WglArg.INPUT_ACTION_MAP.get(arg.type)(ctx, location, arg.value, coop);
            }
          }
        } catch ($__9) {
          $__7 = true;
          $__8 = $__9;
        } finally {
          try {
            if (!$__6 && $__3.return != null) {
              $__3.return();
            }
          } finally {
            if ($__7) {
              throw $__8;
            }
          }
        }
        gl.enableVertexAttribArray(this.positionAttributeLocation);
        gl.vertexAttribPointer(this.positionAttributeLocation, 2, WebGLRenderingContext.FLOAT, false, 0, 0);
      },
      free: function() {
        var gl = initializedWglContext().gl;
        gl.deleteProgram(this.program);
      }
    }, {compileShader: function(gl, shaderType, sourceCode) {
        var shader = gl.createShader(shaderType);
        gl.shaderSource(shader, sourceCode);
        gl.compileShader(shader);
        var info = gl.getShaderInfoLog(shader);
        if (info !== '') {
          console.warn("WebGLShader: gl.getShaderInfoLog() wasn't empty: " + gl.getShaderInfoLog(shader));
          console.warn("Source code was: " + sourceCode);
        }
        if (gl.getShaderParameter(shader, WebGLRenderingContext.COMPILE_STATUS) === false) {
          throw new Error(("WebGLShader: Shader compile failed.\n                Info: " + info + "\n                Source: " + sourceCode));
        }
        return shader;
      }});
  }();
  return {get WglShader() {
      return WglShader;
    }};
});
//# sourceURL=src/webgl/WglShader.js
;$traceurRuntime.registerModule("src/webgl/WglTexture.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglTexture.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/webgl/WglTexture.js")).DetailedError;
  var Util = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/Util.js", "src/webgl/WglTexture.js")).Util;
  var WglMortalValueSlot = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglMortalValueSlot.js", "src/webgl/WglTexture.js")).WglMortalValueSlot;
  var initializedWglContext = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglContext.js", "src/webgl/WglTexture.js")).initializedWglContext;
  var $__9 = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglUtil.js", "src/webgl/WglTexture.js")),
      checkGetErrorResult = $__9.checkGetErrorResult,
      checkFrameBufferStatusResult = $__9.checkFrameBufferStatusResult;
  var WglTexture = function() {
    function WglTexture(width, height) {
      var pixelType = arguments[2] !== (void 0) ? arguments[2] : WebGLRenderingContext.FLOAT;
      var $__2 = this;
      if (width === 0 && height === 0) {
        this.width = 0;
        this.height = 0;
        this.pixelType = pixelType;
        this._hasBeenRenderedTo = true;
        this._textureAndFrameBufferSlot = new WglMortalValueSlot(function() {
          throw new DetailedError("Touched a zero-size texture.", $__2);
        }, function() {
          throw new DetailedError("Touched a zero-size texture.", $__2);
        });
        return;
      }
      if (!Util.isPowerOf2(width) || !Util.isPowerOf2(height)) {
        throw new DetailedError("Sizes must be a power of 2.", {
          width: width,
          height: height,
          pixelType: pixelType
        });
      }
      this.width = width;
      this.height = height;
      this.pixelType = pixelType;
      this._hasBeenRenderedTo = false;
      this._textureAndFrameBufferSlot = new WglMortalValueSlot(function() {
        return $__2._textureAndFramebufferInitializer();
      }, function(e) {
        return WglTexture._deinitialize(e);
      });
    }
    return ($traceurRuntime.createClass)(WglTexture, {
      sizePower: function() {
        if (this.width === 0) {
          return -Infinity;
        }
        return Math.round(Math.log2(this.width * this.height));
      },
      toString: function() {
        return 'Texture(' + [this.width + 'x' + this.height, this.pixelType === WebGLRenderingContext.FLOAT ? 'FLOAT' : this.pixelType === WebGLRenderingContext.UNSIGNED_BYTE ? 'UNSIGNED_BYTE' : this.pixelType, this._hasBeenRenderedTo ? 'rendered' : 'not rendered'].join(', ') + ')';
      },
      markRendered: function() {
        this._hasBeenRenderedTo = true;
      },
      invalidateButMoveToNewInstance: function(details) {
        var result = new WglTexture(this.width, this.height, this.pixelType);
        result._textureAndFrameBufferSlot = this._textureAndFrameBufferSlot;
        var invalidated = function() {
          throw new DetailedError("WglTexture's value accessed after invalidation.", details);
        };
        this._textureAndFrameBufferSlot = new WglMortalValueSlot(invalidated, invalidated);
        return result;
      },
      initializedTexture: function() {
        if (!this._hasBeenRenderedTo) {
          throw new Error("Called initializedTexture on a texture that hasn't been rendered to.");
        }
        return this._textureAndFrameBufferSlot.initializedValue(initializedWglContext().lifetimeCounter).texture;
      },
      initializedFramebuffer: function() {
        return this._textureAndFrameBufferSlot.initializedValue(initializedWglContext().lifetimeCounter).framebuffer;
      },
      ensureDeinitialized: function() {
        this._textureAndFrameBufferSlot.ensureDeinitialized();
      },
      _textureAndFramebufferInitializer: function() {
        var GL = WebGLRenderingContext;
        var gl = initializedWglContext().gl;
        var result = {
          texture: gl.createTexture(),
          framebuffer: gl.createFramebuffer()
        };
        gl.bindTexture(GL.TEXTURE_2D, result.texture);
        gl.bindFramebuffer(GL.FRAMEBUFFER, result.framebuffer);
        try {
          gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.NEAREST);
          gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.NEAREST);
          gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
          gl.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
          gl.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, this.width, this.height, 0, GL.RGBA, this.pixelType, null);
          checkGetErrorResult(gl, "texImage2D");
          gl.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, result.texture, 0);
          checkGetErrorResult(gl, "framebufferTexture2D");
          checkFrameBufferStatusResult(gl);
        } finally {
          gl.bindTexture(GL.TEXTURE_2D, null);
          gl.bindFramebuffer(GL.FRAMEBUFFER, null);
        }
        return result;
      },
      readPixels: function() {
        var isOnHotPath = arguments[0] !== (void 0) ? arguments[0] : true;
        var GL = WebGLRenderingContext;
        if (!this._hasBeenRenderedTo) {
          throw new Error("Called readPixels on a texture that hasn't been rendered to.");
        }
        var outputBuffer;
        switch (this.pixelType) {
          case GL.UNSIGNED_BYTE:
            outputBuffer = new Uint8Array(this.width * this.height * 4);
            break;
          case GL.FLOAT:
            outputBuffer = new Float32Array(this.width * this.height * 4);
            break;
          default:
            throw new Error("Unrecognized pixel type.");
        }
        if (this.width === 0 || this.height === 0) {
          return outputBuffer;
        }
        var gl = initializedWglContext().gl;
        gl.bindFramebuffer(GL.FRAMEBUFFER, this.initializedFramebuffer());
        checkGetErrorResult(gl, "framebufferTexture2D", isOnHotPath);
        checkFrameBufferStatusResult(gl, isOnHotPath);
        gl.readPixels(0, 0, this.width, this.height, GL.RGBA, this.pixelType, outputBuffer);
        checkGetErrorResult(gl, ("readPixels(..., RGBA, " + this.pixelType + ", ...)"), isOnHotPath);
        return outputBuffer;
      }
    }, {
      preferredWidthHeightForSizePower: function(sizePower) {
        var w = 1 << Math.ceil(sizePower / 2);
        var h = 1 << Math.floor(sizePower / 2);
        if (w === 2 && h === 2) {
          w = 4;
          h = 1;
        }
        return {
          w: w,
          h: h
        };
      },
      _deinitialize: function($__3) {
        var $__4 = $__3,
            texture = $__4.texture,
            framebuffer = $__4.framebuffer;
        var gl = initializedWglContext().gl;
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(framebuffer);
      }
    });
  }();
  return {get WglTexture() {
      return WglTexture;
    }};
});
//# sourceURL=src/webgl/WglTexture.js
;$traceurRuntime.registerModule("src/webgl/WglTexturePool.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglTexturePool.js";
  var DetailedError = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/base/DetailedError.js", "src/webgl/WglTexturePool.js")).DetailedError;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexture.js", "src/webgl/WglTexturePool.js")).WglTexture;
  var provideWglTexturePoolToWglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/webgl/WglTexturePool.js")).provideWglTexturePoolToWglConfiguredShader;
  var currentShaderCoder = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/ShaderCoders.js", "src/webgl/WglTexturePool.js")).currentShaderCoder;
  var FLOAT_POOL = [];
  var BYTE_POOL = [];
  var unreturnedTextureCount = 0;
  var WglTexturePool = function() {
    function WglTexturePool() {}
    return ($traceurRuntime.createClass)(WglTexturePool, {}, {
      _bucketFor: function(sizePower, pixelType) {
        if (!Number.isInteger(sizePower) || sizePower < 0 || sizePower > 50) {
          throw new DetailedError("Bad sizePower", {
            sizePower: sizePower,
            pixelType: pixelType
          });
        }
        var pool = pixelType === WebGLRenderingContext.FLOAT ? FLOAT_POOL : BYTE_POOL;
        while (pool.length <= sizePower) {
          pool.push([]);
        }
        return pool[sizePower];
      },
      take: function(sizePower, pixelType) {
        if (sizePower === -Infinity) {
          return new WglTexture(0, 0, pixelType);
        }
        var bucket = WglTexturePool._bucketFor(sizePower, pixelType);
        unreturnedTextureCount++;
        if (unreturnedTextureCount > 1000) {
          console.warn(("High borrowed texture count: " + unreturnedTextureCount + ". (Maybe a leak?)"));
        }
        if (bucket.length > 0) {
          return bucket.pop();
        }
        var $__2 = WglTexture.preferredWidthHeightForSizePower(sizePower),
            w = $__2.w,
            h = $__2.h;
        return new WglTexture(w, h, pixelType);
      },
      deposit: function(texture) {
        var detailsShownWhenUsedAfterDone = arguments[1] !== (void 0) ? arguments[1] : '[no dealloc details]';
        if (!(texture instanceof WglTexture)) {
          throw new DetailedError("Not a texture", {
            texture: texture,
            detailsShownWhenUsedAfterDone: detailsShownWhenUsedAfterDone
          });
        }
        if (texture.width === 0) {
          return;
        }
        var bucket = WglTexturePool._bucketFor(texture.sizePower(), texture.pixelType);
        unreturnedTextureCount--;
        bucket.push(texture.invalidateButMoveToNewInstance(detailsShownWhenUsedAfterDone));
      },
      takeSame: function(texture) {
        return WglTexturePool.take(texture.sizePower(), texture.pixelType);
      },
      getUnReturnedTextureCount: function() {
        return unreturnedTextureCount;
      },
      takeRawFloatTex: function(sizePower) {
        return WglTexturePool.take(sizePower, WebGLRenderingContext.FLOAT);
      },
      takeRawByteTex: function(sizePower) {
        return WglTexturePool.take(sizePower, WebGLRenderingContext.UNSIGNED_BYTE);
      },
      takeBoolTex: function(sizePower) {
        return WglTexturePool.take(sizePower, WebGLRenderingContext.UNSIGNED_BYTE);
      },
      takeVecFloatTex: function(sizePower) {
        return WglTexturePool.take(sizePower + currentShaderCoder().float.powerSizeOverhead, currentShaderCoder().float.pixelType);
      },
      takeVec2Tex: function(sizePower) {
        return WglTexturePool.take(sizePower + currentShaderCoder().vec2.powerSizeOverhead, currentShaderCoder().vec2.pixelType);
      },
      takeVec4Tex: function(sizePower) {
        return WglTexturePool.take(sizePower + currentShaderCoder().vec4.powerSizeOverhead, currentShaderCoder().vec4.pixelType);
      }
    });
  }();
  WglTexture.prototype.deallocByDepositingInPool = function() {
    var detailsShownWhenUsedAfterDone = arguments[0];
    WglTexturePool.deposit(this, detailsShownWhenUsedAfterDone);
  };
  provideWglTexturePoolToWglConfiguredShader(WglTexturePool);
  return {get WglTexturePool() {
      return WglTexturePool;
    }};
});
//# sourceURL=src/webgl/WglTexturePool.js
;$traceurRuntime.registerModule("src/webgl/WglTextureTrader.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglTextureTrader.js";
  var WglConfiguredShader = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglConfiguredShader.js", "src/webgl/WglTextureTrader.js")).WglConfiguredShader;
  var WglTexture = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexture.js", "src/webgl/WglTextureTrader.js")).WglTexture;
  var WglTexturePool = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/webgl/WglTexturePool.js", "src/webgl/WglTextureTrader.js")).WglTexturePool;
  var WglTextureTrader = function() {
    function WglTextureTrader(texture) {
      this.currentTexture = texture;
      this._dontDeallocFlag = false;
    }
    return ($traceurRuntime.createClass)(WglTextureTrader, {
      dontDeallocCurrentTexture: function() {
        this._dontDeallocFlag = true;
        return this.currentTexture;
      },
      shadeAndTrade: function(shaderFunc) {
        var newTexture = arguments[1];
        var src = this.currentTexture;
        var deallocSrc = !this._dontDeallocFlag;
        var dst = newTexture || WglTexturePool.takeSame(src);
        var configuredShader = shaderFunc instanceof WglConfiguredShader ? shaderFunc : shaderFunc(src);
        configuredShader.renderTo(dst);
        this.currentTexture = dst;
        this._dontDeallocFlag = false;
        if (deallocSrc) {
          src.deallocByDepositingInPool('WglTexturePool shadeAndTrade');
        }
      },
      shadeHalveAndTrade: function(reducingShaderFunc) {
        this.shadeAndTrade(reducingShaderFunc, WglTexturePool.take(Math.max(0, this.currentTexture.sizePower() - 1), this.currentTexture.pixelType));
      },
      shadeQuarterAndTrade: function(reducingShaderFunc) {
        this.shadeAndTrade(reducingShaderFunc, WglTexturePool.take(Math.max(0, this.currentTexture.sizePower() - 2), this.currentTexture.pixelType));
      }
    }, {});
  }();
  WglTexture.prototype.tradeThrough = function(traderFunc) {
    var keepInput = arguments[1] !== (void 0) ? arguments[1] : false;
    var t = new WglTextureTrader(this);
    if (keepInput) {
      t.dontDeallocCurrentTexture();
    }
    traderFunc(t);
    return t.currentTexture;
  };
  return {get WglTextureTrader() {
      return WglTextureTrader;
    }};
});
//# sourceURL=src/webgl/WglTextureTrader.js
;$traceurRuntime.registerModule("src/webgl/WglUtil.js", [], function() {
  "use strict";
  var __moduleName = "src/webgl/WglUtil.js";
  var Config = $traceurRuntime.getModule($traceurRuntime.normalizeModuleName("src/Config.js", "src/webgl/WglUtil.js")).Config;
  function checkGetErrorResult(gl, previousOperationDescription) {
    var isOnHotPath = arguments[2] !== (void 0) ? arguments[2] : false;
    var $__1;
    if (isOnHotPath && !Config.CHECK_WEB_GL_ERRORS_EVEN_ON_HOT_PATHS) {
      return;
    }
    var code = gl.getError();
    var GL = WebGLRenderingContext;
    if (code === GL.NO_ERROR) {
      return;
    }
    var msgs = ($__1 = {}, Object.defineProperty($__1, 0x0500, {
      value: "INVALID_ENUM [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0501, {
      value: "INVALID_VALUE [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0502, {
      value: "INVALID_OPERATION [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0505, {
      value: "OUT_OF_MEMORY [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0506, {
      value: "INVALID_FRAMEBUFFER_OPERATION [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x9242, {
      value: "CONTEXT_LOST_WEBGL [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_ENUM, {
      value: "INVALID_ENUM",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_VALUE, {
      value: "INVALID_VALUE",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_OPERATION, {
      value: "INVALID_OPERATION",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.OUT_OF_MEMORY, {
      value: "OUT_OF_MEMORY",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_FRAMEBUFFER_OPERATION, {
      value: "INVALID_FRAMEBUFFER_OPERATION",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.CONTEXT_LOST_WEBGL, {
      value: "CONTEXT_LOST_WEBGL",
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1);
    var d = msgs[code] !== undefined ? msgs[code] : "?";
    throw new Error(("gl.getError() returned 0x" + code.toString(16) + " (" + d + ") after " + previousOperationDescription + "."));
  }
  function checkFrameBufferStatusResult(gl) {
    var isOnHotPath = arguments[1] !== (void 0) ? arguments[1] : false;
    var $__1;
    if (isOnHotPath && !Config.CHECK_WEB_GL_ERRORS_EVEN_ON_HOT_PATHS) {
      return;
    }
    var GL = WebGLRenderingContext;
    var code = gl.checkFramebufferStatus(GL.FRAMEBUFFER);
    if (code === GL.FRAMEBUFFER_COMPLETE) {
      return;
    }
    var msgs = ($__1 = {}, Object.defineProperty($__1, 0, {
      value: "Argument wasn't a frame buffer",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x0500, {
      value: "INVALID_ENUM [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x8CD6, {
      value: "FRAMEBUFFER_INCOMPLETE_ATTACHMENT [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x8CD7, {
      value: "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x8CD9, {
      value: "FRAMEBUFFER_INCOMPLETE_DIMENSIONS [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, 0x8CDD, {
      value: "FRAMEBUFFER_UNSUPPORTED [+constant not found]",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.INVALID_ENUM, {
      value: "INVALID_ENUM",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.FRAMEBUFFER_INCOMPLETE_ATTACHMENT, {
      value: "FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT, {
      value: "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.FRAMEBUFFER_INCOMPLETE_DIMENSIONS, {
      value: "FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
      configurable: true,
      enumerable: true,
      writable: true
    }), Object.defineProperty($__1, GL.FRAMEBUFFER_UNSUPPORTED, {
      value: "FRAMEBUFFER_UNSUPPORTED",
      configurable: true,
      enumerable: true,
      writable: true
    }), $__1);
    var d = msgs[code] !== undefined ? msgs[code] : "?";
    throw new Error(("gl.checkFramebufferStatus() returned 0x" + code.toString(16) + " (" + d + ")."));
  }
  return {
    get checkGetErrorResult() {
      return checkGetErrorResult;
    },
    get checkFrameBufferStatusResult() {
      return checkFrameBufferStatusResult;
    }
  };
});
//# sourceURL=src/webgl/WglUtil.js
;$traceurRuntime.getModule("src/main.js");

        </script>
    </body>
</html>
